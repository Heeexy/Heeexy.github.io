<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<link rel="alternate" href="/atom.xml" title="街上的动物园"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="http://heeexy.com/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" /><script type="text/x-mathjax-config">
    MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-103584593-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-103584593-1');
</script><script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":true};
</script>

    <title>街上的动物园</title>
  <meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="街上的动物园" type="application/atom+xml">
</head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">街上的动物园</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">首页
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">归档
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签
          </li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">街上的动物园</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            归档
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            标签
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/categories/">
            分类
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><section id="posts" class="posts"><article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2020/07/16/Redisson-IllegalMonitorStateException/">Redisson分布式锁报错问题排查</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-07-16
        </span><span class="post-category">
            <a href="/categories/Redisson/">Redisson</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h2 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h2><p>业务线测试同学反馈压测时，有以下报错日志：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalMonitorStateException: attempt to unlock lock, not locked by current thread by node id: def1bd2c-<span class="number">1f</span>49-<span class="number">4802</span>-b635-<span class="number">5</span>ea78543c033 thread-id: <span class="number">109</span></span><br><span class="line">	at org.redisson.RedissonLock.unlock(RedissonLock.java:<span class="number">366</span>)</span><br></pre></td></tr></table></figure>

<h2 id="先抛结论"><a href="#先抛结论" class="headerlink" title="先抛结论"></a>先抛结论</h2><p>建议遇到类似问题的人先检查项目中是否确保了 <strong>redissonClient 的单例</strong>。（单线程当然也是必须的，不过排查起来很简单，估计看到文章的人首先已经排查过单线程的问题了）</p>
<p>本次报错是因为:</p>
<ol>
<li><p>redissonClient 虽然是单例的静态成员变量，但初始化时未加锁，而是简单使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> RedissonClient redisson = <span class="keyword">null</span>;</span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RedissonClient <span class="title">getRedisson</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(redisson == <span class="keyword">null</span>)&#123;</span><br><span class="line">      RedissonManager.init(); <span class="comment">//初始化</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> redisson;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>加锁解锁没有同一个 lock，而是每次都使用<code>getRedisson().getLock(key)</code> 。导致解锁时从另一个 redissonClient 并没有获取到锁。<br>换言之，报错里的<code>not locked by current thread by node id: def1bd2c-1f49-4802-b635-5ea78543c033 thread-id: 109</code> 其实关键问题在于<code>by node id</code> ，而不是线程id。</p>
</li>
</ol>
<h2 id="定位问题依据"><a href="#定位问题依据" class="headerlink" title="定位问题依据"></a>定位问题依据</h2><p>不需要改代码、加日志甚至debug，只需要搜索日志里是否有两行</p>
<p><code>13:58:07.972 [main] INFO org.redisson.Version - Redisson 2.8.2</code></p>
<p>打印两次版本信息说明肯定初始化了两次 Redisson。</p>
<p>是的，定位和结论就这么简单，如果能早点知道，我就能省下这十几个小时和一大把头发了。</p>
<h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><h3 id="一、搜索解决方案"><a href="#一、搜索解决方案" class="headerlink" title="一、搜索解决方案"></a>一、搜索解决方案</h3><p>把报错信息复制出去很容易就搜到了一些文章遇到类似的报错，解决方式就是解锁前判断是否自己持有的这个锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(lock.isHeldByCurrentThread())&#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且从“源码”级别解释了lock方法catch了InterruptedException等概念。</p>
<h3 id="二、质疑解决方案"><a href="#二、质疑解决方案" class="headerlink" title="二、质疑解决方案"></a>二、质疑解决方案</h3><p>很显然加上这一行代码，不会再报错了，但是这给我带来的问题更多了。</p>
<ol>
<li><p>自己手写demo里将线程interrupt复现这个问题可以理解，但是我们实际项目中线程被谁interrupt了？</p>
</li>
<li><p>加了<code>if(lock.isHeldByCurrentThread())</code>的确不报错了，但这个线程本质上就没拿到这个分布式锁，在else中还是应该手动抛个异常出去的。轻度压测都出现这种情况，那项目岂不是毫无并发度可言？</p>
</li>
<li><p>Redisson 应该也是个成熟的框架了，为什么特地暴露个 lock 接口出来，实际功能只是隐藏掉<code>InterruptedException</code>? 如果我们实际项目中线程被 interrupt 是常态，那暴露这种接口岂不是挖坑？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        lockInterruptibly(leaseTime, unit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>看来问题并非一行代码就能掩盖过去的，事情开始变得有意思了。</p>
<h3 id="三、排查线程问题"><a href="#三、排查线程问题" class="headerlink" title="三、排查线程问题"></a>三、排查线程问题</h3><p>既然网上文章都说源码里catch 了 InterruptedException，那就研究下源码看是不是有地方会interrupt。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     <span class="keyword">long</span> threadId = Thread.currentThread().getId();</span><br><span class="line">   <span class="comment">//先获取一次锁试试看</span></span><br><span class="line">     Long ttl = tryAcquire(leaseTime, unit, threadId);</span><br><span class="line">     <span class="comment">// lock acquired</span></span><br><span class="line">     <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">//拿不到锁就订阅channel</span></span><br><span class="line">     RFuture&lt;RedissonLockEntry&gt; future = subscribe(threadId);</span><br><span class="line">     commandExecutor.syncSubscription(future);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//循环获取锁</span></span><br><span class="line">         <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">             ttl = tryAcquire(leaseTime, unit, threadId);</span><br><span class="line">             <span class="comment">// lock acquired</span></span><br><span class="line">             <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// waiting for message</span></span><br><span class="line">             <span class="keyword">if</span> (ttl &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//事实上通常等锁都会走到这，内部是semaphore在等资源。而发生InterruptedException也是在这里面。</span></span><br><span class="line">                 getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 getEntry(threadId).getLatch().acquire();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         unsubscribe(future, threadId);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>而这边用到的Semaphore其实是0个permmit的，作用就是用来阻塞线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.latch = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>再继续深入无非就只有Semaphore和AQS的基础知识了。有处理interrupted的地方，但是没有手动interrupt()的地方。</p>
<p><code>unlock()</code> 方法则更为简单，就是用脚本去redis查这个锁，解锁。失败的话会报我们遇到的错误。</p>
<p>源码再加上一些手动实验，都无法知道何时被interrupt，此时线程中断的排查似乎走到了死胡同。</p>
<h3 id="四、排查client问题"><a href="#四、排查client问题" class="headerlink" title="四、排查client问题"></a>四、排查client问题</h3><p>经过一番沟通和折腾，终于测试同学可以压测我的电脑上部署的项目。</p>
<p>前后压了5、6遍，几十万次请求，流量近10倍于压测环境。</p>
<p>然而只有第一次和第三次压复现了异常，而第一次压时发现原项目日志用的还是<code>System.out.println</code>，打印的信息也不完善，无法帮助排查。第三次压刚启动进了异常断点，以为是项目启动有问题，放掉断点跑了十几万次请求都OK。</p>
<p>全部压测结束，最后几次也无法复现问题，到了收工时间，无法再压测。</p>
<p>再回过头看唯一一次有记录的异常日志信息，发现日志里显示的是 “interrupted:false,hold:true”。表明线程没被中断过，但是并不是这个锁的持有者。</p>
<p>只能继续带着更多的问题去做推测&amp;验证。</p>
<p>Q1:会不会是加锁和解锁用到的两个方法各自去获取的lock对象不一致导致的问题？</p>
<p>A1:自己试验了很多遍，两个对象不一致并不影响结果。</p>
<p>Q2:会不会是项目启动的初始化redissonClient没加锁导致了异常？</p>
<p>A2:翻了下日志，项目打印日志多，请求量又特别大，几十万行的日志中找到报错位置和项目启动位置似乎时间间隔有点长，应该不是这个原因。（就是这里第一次错过了正确的答案。。。）</p>
<p>Q3:会不会是因为加锁解锁间隔过短，两个lock对象分别连接了master和slave，主从延迟导致的？(半夜刷牙想到这个，似乎非常有可能，高兴坏了)</p>
<p>A3:第二天来公司用demo验证，用了半天时间，各自改代码，几百上千个线程跑了很多遍都没复现这个问题，redis都打得有节点连接不上了，跑得我都要怀疑人生了。</p>
<p>Q4:试验中发现解锁用到的lock2对象如果是通过redissonClient2获取的，能稳定复现这个问题，是否与我们的项目遇到的异常有关联呢？</p>
<p>A4:再去看了下项目代码，除了初始化redissonClient没加锁之外，运行过程中用的都是静态变量指向的redissonClient，应该是同一个，与这个试验场景不一样。（第二次错过正确答案。。。）</p>
<p>没有了思路，只能逐行debug，走一行看一眼Redisson打的长串日志。</p>
<p>观察发现调用 <code>lock.isHeldByCurrentThread()</code> 等方法其实都是在请求redis，并非像普通的java对象一样读取成员变量。</p>
<p>仔细看每个lock的每次查询是否用了相同的connection，搜索每个connection的id发现，每次并不相同，且应该都是从初始化连接池中拿的。</p>
<p>排除了各种情况的答案后，我发现了请求redis的脚本中元素的key其实有规律，是id+key，而id就是这个client初始化时生成的uuid，稍加验证，很轻松解释了之前的Q4中能稳定复现这个异常的原因。就是多个client就相当于分布式的多个jvm，即使同一个线程，使用的锁id肯定也是不一样的。</p>
<p>因此我又把目光转回了多个client的这个问题，光看代码的确是有这个可能性，现在还需要在错误日志里找到相应的依据去证实自己的猜测。</p>
<p>回到Q2位忽略掉的日志，在vscode中打开庞大的日志文件，CTRL+F搜索异常的时间点等信息，发现了自己之前的一个误解，其实 项目启动!=client初始化， client是等到请求打过来才初始化的。</p>
<p>再稍加搜索，虽然日志中没有打印client的id，但是两个不同的线程打印了两次Redission的版本信息便足以佐证我的猜测了。</p>
<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>十几个小时的排查过程虽然学到了很多，但是自己的几个失误其实大大拉长了这痛苦的时间。</p>
<ol>
<li><p>没有第一时间去加日志，压测，复现问题。</p>
<p>如果在原项目中加上日志看下锁的 <code>isInterrupted()</code> 和 <code>isHeldByCurrentThread()</code>状态，其实很快就能发现线程根本没有被 interrupt，不用往那个方向排查。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">"lock:"</span> + lock.toString() + <span class="string">",interrupted:"</span> + Thread.currentThread().isInterrupted() </span><br><span class="line">         + <span class="string">",hold:"</span> + lock.isHeldByCurrentThread() + <span class="string">",threadId:"</span> + Thread.currentThread().getId());</span><br></pre></td></tr></table></figure>
</li>
<li><p>多次错过了正确答案。</p>
</li>
</ol>
<p>其实也主要是因为不是自己的项目，在改代码、发布、压测、日志、监控这些方面都缺乏掌控，因此难免走了一些弯路。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2020/06/28/elasticsearch-segment-merge/">日志ES集群的潜在性能瓶颈--段合并</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-06-28
        </span><span class="post-category">
            <a href="/categories/ElasticSearch/">ElasticSearch</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h2 id="先抛结论"><a href="#先抛结论" class="headerlink" title="先抛结论"></a>先抛结论</h2><p>如果日志型ES集群system load 过高，I/O打满，尤其是在<strong>读写低谷时间段 read 异常高</strong>，可以考虑排查段合并的问题。</p>
<p>如果的确是遇到了段合并问题，可以考虑两个方向：</p>
<ol>
<li>机械硬盘升级为SSD。</li>
<li>大索引拆分成小索引。</li>
</ol>
<blockquote>
<p>PS. 再附送一个潜在的查询问题可能导致的IO打满：通配符查询，参见<a href="https://elasticsearch.cn/article/171" target="_blank" rel="noopener">文章</a>。</p>
</blockquote>
<h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><p>详细的排查过程就不赘述了，无非是加监控，包括业务层面、ES层面、机器层面，然后横向、纵向的分析各种监控指标。</p>
<p>这里分享几个容易被忽略的指标/api</p>
<ol>
<li><p>查看最大的索引的 _stats 中merge部分：</p>
<p>total_stopped_time_in_millis ：通常应该是0</p>
<p>total_size_in_bytes：总共merge了这么多数据，你会发现远大于索引大小。下文会介绍这一指标。</p>
</li>
<li><p>观察线程状况，api详细参数可以查阅<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-nodes-hot-threads.html#cluster-nodes-hot-threads-api-query-params" target="_blank" rel="noopener">官方文档</a>。我在定位问题时还不知道hot_threads这个api，如果提前知道的话可能就省下不少时间了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET _cat/thread_pool?v</span><br><span class="line">GET /_nodes/hot_threads</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>段合并的基本原理很简单，两个（多个）已提交的段写入一个新的段。</p>
<p><img src="https://www.elastic.co/guide/cn/elasticsearch/guide/current/images/elas_1110.png" alt=""></p>
<p>这种读写除了尚在内存中的部分，就难免需要消耗磁盘IO了。</p>
<p>而从<a href="http://blog.mikemccandless.com/2011/02/visualizing-lucenes-segment-merges.html" target="_blank" rel="noopener">可视化Lucene段合并</a>一文中得知，这种类似于<a href="https://en.wikipedia.org/wiki/Write_amplification" target="_blank" rel="noopener">SSD写放大</a>的过程其实是一种浪费（文中称为tax），一个最终1G的索引可能由于merge而需要读写10G磁盘。</p>
<p>段合并算法优化的一个目标就是降低这种浪费，更高效地做段合并。</p>
<p>而减小我们索引的体积就可以轻松的带来显著的提升。</p>
<p><img src="http://img.heeexy.com/es-io.png" alt="es-io"></p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2020/02/17/optimization-experience/">QPS从1k到2w，我做了什么</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-02-17
        </span><span class="post-category">
            <a href="/categories/%E5%B0%8F%E7%BB%93/">小结</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p>这两年有幸参与了商品列表系统的两次黑五挑战，QPS从最开始的1k都顶不住，到1w，再到2w，加上支持大量的AB实验，排序千人千面，功能越来越复杂，系统越来越庞大，可能这样的机会都不会常有，在此简单记录一下做系统优化的实践心得。</p>
<h1 id="要素"><a href="#要素" class="headerlink" title="要素"></a>要素</h1><p>仔细想想，做优化其实并没有很多门道，个人总结起来就三个要素：</p>
<ol>
<li>业务</li>
<li>工具</li>
<li>人</li>
</ol>
<h3 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h3><p>业务就是你的任务，是优化的目标，业务的复杂性和独特性决定了你的问题只有自己去解决，网上没有答案，即使挖个大神来也不能立马帮到你。</p>
<p>业务不仅仅包括公司对外提供的服务，还包括项目内部的一切细枝末节，比如代码的逻辑、服务器的部署、后台的配置、数据的流转，甚至不同团队间的分工合作等等。</p>
<p>我们要做的其实就是优化这些业务，业务中的任何一个点都可以是优化的方向。</p>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>我们能用到的一切手段都是工具，有直接应对线上流量的服务器、代码、JVM、DB，也有间接可以帮助我们做优化的辅助工具，监控(Prometheus/Grafana)、日志(ELK)、压测(Goreplay)、诊断工具(Arthas)等等。</p>
<h3 id="人"><a href="#人" class="headerlink" title="人"></a>人</h3><p>只了解业务的人面对问题束手无策，只钻研技术的人能解决的问题往往被技术限制了天花板。</p>
<p>我们需要的是<strong>精通业务，善用工具</strong>的人，能从监控数据中发现蛛丝马迹，能从复杂的业务关系中抽丝剥茧，能利用手上一切工具，发挥它们最大的作用。</p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>抛开搭建环境、压测、回归测试等工作，优化步骤最精简的话只有两步：</p>
<ol>
<li>找系统瓶颈</li>
<li>优化，突破瓶颈</li>
</ol>
<h3 id="找系统瓶颈"><a href="#找系统瓶颈" class="headerlink" title="找系统瓶颈"></a>找系统瓶颈</h3><p>找瓶颈就需要有依据，依据就是监控指标。</p>
<p>监控指标的全面对于一个庞大的系统来说至关重要，不仅包括接口的耗时、JVM的状态、机器的负载等一些常见的指标，更需要细致到收集缓存的命中率、不同逻辑分支的占比、每张表的读写频率等具体业务相关的指标。</p>
<p>如果缺少了业务指标的监控，定位问题很可能定位不到根源，能优化的空间也会受到技术的限制。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>找到瓶颈之后，看起来问题很快就能解决了，JVM顶不住就调heap，调GC，DB顶不住就加副本，优化sql，毕竟我们学习的时候学的就是这些，面试的时候考的也是这些。</p>
<p>然而真正漫长而痛苦的优化过程中，这些直接了当的解决方式往往不会带来多少提升，因为简单的方法可能在我们当初开发功能时都已经做过。</p>
<p>通常想要成倍的提高吞吐量，我们需要做更多<strong>看似侧面的工作，解决根源上的问题</strong>。</p>
<h4 id="几个例子"><a href="#几个例子" class="headerlink" title="几个例子"></a>几个例子</h4><p>当我们吞吐量在1k不到时，JVM顶不住，这时候不管是升机器配置，还是JVM调优都没有明显效果。因为我们有很多慢接口，即使只占请求总量的1%不到，在大流量下也是拖垮服务的重要因素。我们采用了使用ES的一些高级特性，同时将数据准备成便于查询的结构（见<a href="/2018/12/02/es-for-search/">ElasticSearch在高并发复杂查询业务场景的应用</a>）等一系列措施，消灭了慢查询接口。</p>
<p>当慢接口处理完，吞吐量提升到了一定程度，JVM还是状况不佳，我们就考虑改善缓存。原本使用的JVM内缓存，尝试了调整缓存参数，使用集中式缓存Redis等方案后都没效果。最终通过Nginx层的缓存和一致性哈希大幅减轻了压力。</p>
<p>当接口都很快，DB（Elasticsearch）开始顶不住，我们尝试了加机器、扩副本、调堆内存大小等手段，最终还是通过将商品详情的查询移出ES，由单独的服务通过查Redis来提供，减轻了ES大半的压力。</p>
<p>。。。</p>
<p>以上的手段未必适合其它项目，但系统的优化就是这样，从来就没有标准答案。</p>
<p>我们能做的就只有深入业务，利用好每一种工具，然后充满信心地迎接下一个挑战。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2020/02/03/ClassLoader/">JDBC为什么不需要Class.forName()</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-02-03
        </span><span class="post-category">
            <a href="/categories/JVM/">JVM</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h3 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h3><p>在初学JDBC时，总是记得开头就要来这么一句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br></pre></td></tr></table></figure>

<p>然而今天学习类加载机制时偶然知道不需要这句也同样可以正常运行，测试的确如此，看了一眼源码，看似原因很简单，因为无论写不写那段<code>Class.forName</code>，在触发加载DriverManager时，会运行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load the initial JDBC drivers by checking the System property</span></span><br><span class="line"><span class="comment"> * jdbc.properties and then use the &#123;<span class="doctag">@code</span> ServiceLoader&#125; mechanism</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    loadInitialDrivers();</span><br><span class="line">    println(<span class="string">"JDBC DriverManager initialized"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>都会扫描到这个Driver，注册到<code>registeredDrivers</code>中。</p>
<hr>
<p>如果只要回答这个问题，可能上面的答案就已经足够了。</p>
<p>然而兴趣来了，总想把源码继续看下去到底扫描了啥，咋扫描的，明明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>这里是 <code>java.sql.Driver</code> 接口，上哪找出来的实现类？</p>
<p>我们就一层层的往下看吧。</p>
<h3 id="ServiceLoader"><a href="#ServiceLoader" class="headerlink" title="ServiceLoader"></a>ServiceLoader</h3><p>主要做了两点</p>
<ol>
<li>设置ClassLoader为当前线程的。（破坏双亲委派，让它rt.jar包中的类可以通过AppClassLoader获取到外部的类，很多讲双亲委派机制的文章已经大书特书过了）</li>
<li>初始化了一个懒加载的迭代器 <code>lookupIterator = new LazyIterator(service, loader);</code>。正是这个迭代器中最终帮我们找到了各种driver注册进去。</li>
</ol>
<h3 id="LazyIterator"><a href="#LazyIterator" class="headerlink" title="LazyIterator"></a>LazyIterator</h3><p>既然是迭代器，最重要的当然是hasNext()和next()方法。</p>
<p>在next()方法中，已经拿到了nextName完整的”com.mysql.cj.jdbc.Driver”类名，说明还是hasNext()方法干了真正的扫描工作。</p>
<p>hasNext()方法的主要工作也都放在了hasNextService()中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nextName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//此处拼出了全名为 META-INF/services/java.sql.Driver</span></span><br><span class="line">            String fullName = PREFIX + service.getName();</span><br><span class="line">            <span class="keyword">if</span> (loader == <span class="keyword">null</span>)</span><br><span class="line">                configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                configs = loader.getResources(fullName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">            fail(service, <span class="string">"Error locating configuration files"</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pending = parse(service, configs.nextElement());</span><br><span class="line">    &#125;</span><br><span class="line">    nextName = pending.next();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来不算复杂，我们拿着”META-INF/services/java.sql.Driver”去AppClassLoader找个configs。</p>
<p>但是debug的时候并不直观，因为debug的时候看到config似乎包含了各层类加载器扫出来的几十个jar包，然而到configs.nextElement()时突然就直接拿到了<code>jar:file:/C:/Users/dell/.m2/repository/mysql/mysql-connector-java/8.0.13/mysql-connector-java-8.0.13.jar!/META-INF/services/java.sql.Driver</code>的完整路径。最后发现实在是源码作者太喜欢实现hasNext()和next()方法（<code>hasMoreElements</code>和<code>nextElement</code>）了，一层又一层的把人看晕了。</p>
<p>我们先跟进这段代码<code>configs = loader.getResources(fullName);</code>，看configs是如何拿到的吧。</p>
<h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Enumeration&lt;URL&gt; <span class="title">getResources</span><span class="params">(String name)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Enumeration&lt;URL&gt;[] tmp = (Enumeration&lt;URL&gt;[]) <span class="keyword">new</span> Enumeration&lt;?&gt;[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        tmp[<span class="number">0</span>] = parent.getResources(name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tmp[<span class="number">0</span>] = getBootstrapResources(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//AppClassLoader和ExtClassLoader都是调用父类URLClassLoader的findResources方法</span></span><br><span class="line">    tmp[<span class="number">1</span>] = findResources(name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CompoundEnumeration&lt;&gt;(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遵循了双亲委派机制，先向上找parent，一直找到顶部的Bootstrap启动类加载器。再向下一直找到自身类加载器。 当然此处由于可以返回多层结果，因此返回的最终是<code>CompoundEnumeration</code> 组合的结果，而不是单条数据。</p>
<p>后面我们会看到，不同的实现的Enumeration的<code>hasMoreElements</code>和<code>nextElement</code>真是花里胡哨。用<code>Enumeration&lt;URL&gt;</code> 这个看似最简单的只有两个方法的<code>Interface</code>作为返回类型，真是给作者玩出花来了。</p>
<p>三层找的结果如下图。</p>
<p><img src="http://img.heeexy.com/BootstrapResouces.png" alt=""></p>
<p><img src="http://img.heeexy.com/ExtResouces.png" alt=""></p>
<p><img src="http://img.heeexy.com/AppResources.png" alt=""></p>
<p>debug看完三层扫描的结果，三层类加载器一共扫了一百多个jar包出来，貌似没毛病，但是明明我传了name进去找resource的啊，如果你要返回全部jar包，还要我传name干啥？要是遍历一百多个jar包的话，<code>pending = parse(service, configs.nextElement());</code>这要遍历一百多次去找<code>java.sql.Driver</code>的实现类？</p>
<p>但是debug到<code>configs.nextElement()</code>时突然就直接拿到了<code>jar:file:/C:/Users/dell/.m2/repository/mysql/mysql-connector-java/8.0.13/mysql-connector-java-8.0.13.jar!/META-INF/services/java.sql.Driver</code>的完整路径。我们先看一眼这个jar包中的内容，</p>
<p><img src="http://img.heeexy.com/TargetDriverMetaInf.png" alt=""></p>
<p>的确这就是我们要找的jar包和配置文件，里面写明了我们要注册的Driver的实现类就是”com.mysql.cj.jdbc.Driver”。</p>
<p>那这到底是什么时候遍历出来的呢？看来返回的这个<code>configs</code>中间大有玄机，我们继续跟进它的<strong>迭代</strong>的方法。</p>
<h3 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h3><p>AppClassLoader和ExtClassLoader都是继承于URLClassLoader，且它们的<code>findResources</code>方法都是使用父类的。</p>
<p>而URLClassLoader的这个方法的核心又是调用URLClassPath的<code>findResources</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> Enumeration&lt;URL&gt; <span class="title">findResources</span><span class="params">(<span class="keyword">final</span> String name)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Enumeration&lt;URL&gt; e = ucp.findResources(name, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//这里还是在URLClassPath返回的Enumeration上再包了一次，又实现了一遍Enumeration</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Enumeration&lt;URL&gt;() &#123;</span><br><span class="line">          <span class="keyword">private</span> URL url = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">          <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          ...</span><br><span class="line">              <span class="comment">//这里额外加上的checkURL方法，连name都没带，肯定也不是校验我们java.sql.Driver的，只是简单校验下路径合法或者存在。</span></span><br><span class="line">              url = ucp.checkURL(u);</span><br><span class="line">          ...</span><br><span class="line">          &#125;</span><br><span class="line">          ...</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="URLClassPath"><a href="#URLClassPath" class="headerlink" title="URLClassPath"></a>URLClassPath</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Enumeration&lt;URL&gt; <span class="title">findResources</span><span class="params">(<span class="keyword">final</span> String var1, <span class="keyword">final</span> <span class="keyword">boolean</span> var2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Enumeration&lt;URL&gt;() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] cache = URLClassPath.<span class="keyword">this</span>.getLookupCache(var1);</span><br><span class="line">        <span class="keyword">private</span> URL url = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.url != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    URLClassPath.Loader var1x;</span><br><span class="line">                    <span class="comment">//终于找到遍历jar包的地方，此处的var1x就是每个jar包</span></span><br><span class="line">                    <span class="keyword">if</span> ((var1x = URLClassPath.<span class="keyword">this</span>.getNextLoader(<span class="keyword">this</span>.cache, <span class="keyword">this</span>.index++)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">					<span class="comment">//findResource就是从这个jar包中找出我们要的META-INF/services/java.sql.Driver</span></span><br><span class="line">                    <span class="keyword">this</span>.url = var1x.findResource(var1, var2);</span><br><span class="line">                &#125; <span class="keyword">while</span>(<span class="keyword">this</span>.url == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://img.heeexy.com/URLClassPath.png" alt=""></p>
<p>在一个jar包中，又有很多的配置文件路径，如何找到我们要的那个的呢？</p>
<p>这里var1x就是JarLoader，用了其中的getResource方法。</p>
<h3 id="JarLoader"><a href="#JarLoader" class="headerlink" title="JarLoader"></a>JarLoader</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Resource <span class="title">getResource</span><span class="params">(String var1, <span class="keyword">boolean</span> var2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//关键就在这个metaIndex中，mayContain方法去查了jar包中是否包含我们要找的目标文件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.metaIndex != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.metaIndex.mayContain(var1)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.ensureOpen();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(var5);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        JarEntry var3 = <span class="keyword">this</span>.jar.getJarEntry(var1);</span><br><span class="line">        <span class="keyword">if</span> (var3 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.checkResource(var1, var2, var3);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.index == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HashSet var4 = <span class="keyword">new</span> HashSet();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getResource(var1, var2, var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://img.heeexy.com/JarLoader.png" alt=""></p>
<p>至此，我们已经找到了全部遍历的地方，URLClassLoader加载了全部jar包之后，在开始迭代时，URLClassPath 遍历每个jar包，JarLoader查找每个jar包中是否有目标文件META-INF/services/java.sql.Driver。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/12/23/router/">WIFI里都是自由的香味----软路由</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-12-23
        </span><span class="post-category">
            <a href="/categories/%E9%A3%9E%E8%B7%83%E9%95%BF%E5%9F%8E/">飞跃长城</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p><img src="http://img.heeexy.com/route.png" alt="网络拓扑"></p>
<h1 id="教程-amp-踩过的坑"><a href="#教程-amp-踩过的坑" class="headerlink" title="教程&amp;踩过的坑"></a>教程&amp;踩过的坑</h1><h3 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h3><ol>
<li>科学上网能力。SSR/V2ray等，最好自己搭过服务端，说明有基础能力。</li>
<li>鼠标&amp;键盘&amp;显示器&amp;网线。为什么要单独拎出来，因为需要这些东西，说明你在操作时，可能至少需要有：<ol>
<li>笔记本电脑，用来看教程，搜各种问题，远程连工控机</li>
<li>台式机，其实是用来拆鼠标&amp;键盘&amp;显示器给工控机使用</li>
</ol>
</li>
<li>U盘。用于给工控机重新安装ESXi系统</li>
<li>为科学上网花钱的心理准备。因为至少需要购买一台工控机，要求高一点的还可以购买ROS正版授权，机场（For Netflix）</li>
<li>折腾的耐心。如果没有耐心又想要路由器科学上网，其实工控机+OpenWrt已经非常棒了。</li>
</ol>
<h3 id="选购软路由"><a href="#选购软路由" class="headerlink" title="选购软路由"></a>选购软路由</h3><p><a href="https://www.youtube.com/watch?v=rGIUouvATqc" target="_blank" rel="noopener">https://www.youtube.com/watch?v=rGIUouvATqc</a></p>
<p>建议预装个LEDE，等玩明白了再折腾虚拟机。</p>
<h4 id="安装EXSi"><a href="#安装EXSi" class="headerlink" title="安装EXSi"></a>安装EXSi</h4><p>官网 <a href="https://my.vmware.com/en/web/vmware/info/slug/datacenter_cloud_infrastructure/vmware_vsphere/6_7" target="_blank" rel="noopener">https://my.vmware.com/en/web/vmware/info/slug/datacenter_cloud_infrastructure/vmware_vsphere/6_7</a></p>
<p>教程</p>
<p><a href="https://www.cnblogs.com/xiaoyou2018/p/11122144.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaoyou2018/p/11122144.html</a></p>
<p><a href="https://www.vediotalk.com/archives/2356" target="_blank" rel="noopener">https://www.vediotalk.com/archives/2356</a></p>
<p>心得：</p>
<ol>
<li>小白需要记住有这么一个设置静态ip的操作，可能你最终部署的网络环境不是你当前操作安装的网络，这个静态ip地址等改了网络环境就需要改。</li>
<li>按照<a href="http://www.oadun.com/2019/01/277.html" target="_blank" rel="noopener">教程</a>部署端口组。</li>
</ol>
<h4 id="安装ROS"><a href="#安装ROS" class="headerlink" title="安装ROS"></a>安装ROS</h4><p>官网</p>
<p><a href="https://mikrotik.com/download" target="_blank" rel="noopener">https://mikrotik.com/download</a></p>
<p>教程</p>
<p><a href="https://www.youtube.com/watch?v=mkJxDSMPlPU" target="_blank" rel="noopener">https://www.youtube.com/watch?v=mkJxDSMPlPU</a></p>
<p><a href="https://www.youtube.com/watch?v=h6K5FThk-T4" target="_blank" rel="noopener">https://www.youtube.com/watch?v=h6K5FThk-T4</a></p>
<p><a href="https://www.youtube.com/watch?v=jgSM3vXGJ3c" target="_blank" rel="noopener">https://www.youtube.com/watch?v=jgSM3vXGJ3c</a></p>
<p>心得：</p>
<ol>
<li>官网下载的需要正版授权，否则仅能试用24h</li>
<li>洋葱的教程很好，可惜只有PPPOE拨号的方式，自动获取ip的上网方式可以参考Vedio Talk或其他人的教程</li>
<li>安装调试好记得设置虚拟机开机自启动！！！</li>
<li>ROS是整个系列里最核心也是最复杂的地方，稍微配置错一点，就无法上网。不过回想起整个过程，收获最大的也是这里，非常宝贵的网络实战经验！</li>
</ol>
<h4 id="安装OpenWrt"><a href="#安装OpenWrt" class="headerlink" title="安装OpenWrt"></a>安装OpenWrt</h4><p>恩山论坛 <a href="https://www.right.com.cn/forum/forum.php" target="_blank" rel="noopener">https://www.right.com.cn/forum/forum.php</a></p>
<p>安装教程 </p>
<p><a href="https://www.youtube.com/watch?v=n0aqV8rbKmE" target="_blank" rel="noopener">https://www.youtube.com/watch?v=n0aqV8rbKmE</a></p>
<p><a href="http://www.oadun.com/2019/01/277.html" target="_blank" rel="noopener">http://www.oadun.com/2019/01/277.html</a></p>
<p>心得：</p>
<ol>
<li>安装调试好记得设置虚拟机开机自启动！！！</li>
</ol>
<h5 id="拓展延伸"><a href="#拓展延伸" class="headerlink" title="拓展延伸"></a>拓展延伸</h5><p>源码 <a href="https://github.com/coolsnowwolf/lede" target="_blank" rel="noopener">https://github.com/coolsnowwolf/lede</a></p>
<p>使用Github Actions 云编译 <a href="https://www.youtube.com/watch?v=2Y8DN-ROYIs" target="_blank" rel="noopener">https://www.youtube.com/watch?v=2Y8DN-ROYIs</a></p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/06/18/memsql/">MemSQL简介</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-06-18
        </span><span class="post-category">
            <a href="/categories/MemSQL/">MemSQL</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h2 id="为什么要看MemSQL"><a href="#为什么要看MemSQL" class="headerlink" title="为什么要看MemSQL"></a>为什么要看MemSQL</h2><p>因为 MemSQL 自称突出一个快！而我们团队的数据平台正需要一个ms级别查询的数据库，因此花了一点时间来调研 MemSQL 。</p>
<h2 id="初体验结果"><a href="#初体验结果" class="headerlink" title="初体验结果"></a>初体验结果</h2><p>MemSQL与我们期望的ms级别查询相差甚远，最简单的查询也通常是500ms返回，并不能应对线上的高并发实时查询系统。秒级查询已经有presto等各种大数据组件，对于我们团队已经没有理由再来深入使用MemSQL。</p>
<p>MemSQL 其实有很多优点，有完善的文档，精致的页面管理工具，方便的安装，甚至一键导入大量数据来方便用户体验 （就差把sql的耗时贴出来了，要是贴出来就省了我调研的时间了），可惜在同一梯队还有太多免费、开源、有活跃社区的竞争对手。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>MemSQL属于商业公司，免费4 units.   (每8核32G 为1 unit)，不开源</li>
<li>自带portal界面管理，MemSQL Studio，自带安装工具</li>
<li>完全支持mysql语法，jdbc，增删改查</li>
<li>支持 in-memory rowstore  &amp;&amp;  on-disk columnstore</li>
<li>大吞吐量数据写入(loading TPC-H SF100 (approximately 100 GBs of row files) will take around four minutes)</li>
<li>exactly-once</li>
<li>aggregator节点运行sql，聚合结果；leaf节点存储&amp;处理数据</li>
</ul>
<h2 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h2><ol>
<li>file , 指定分隔符</li>
<li>Streaming  (Kafka , S3 , Azure Blob , Filesystem) 通过Pipelines</li>
<li>MySQL (sql文件)</li>
</ol>
<h2 id="选择-shard-key-类似ES的routing"><a href="#选择-shard-key-类似ES的routing" class="headerlink" title="选择 shard key   (类似ES的routing)"></a>选择 shard key   (类似ES的routing)</h2><ul>
<li><p>Using a column or set of columns unique enough to minimize skew.</p>
<p>独特的key，使数据均匀分布</p>
</li>
<li><p>Sharding on columns which you expect to filter or join on often. This allows the optimizer to minimize network traffic during the execution of the query (see [Distributed DML] for more details).</p>
<p>使用你经常要join或过滤的字段，减小网络传输。比如订单相关，使用user_id</p>
</li>
</ul>
<h2 id="查询调优"><a href="#查询调优" class="headerlink" title="查询调优"></a>查询调优</h2><ol>
<li>加index 优化过滤  groupby sort</li>
<li>shard key    :    Gather partitions:all 优化为  Gather partitions:single</li>
<li>Reference Tables   小表，不常更新 ，每个节点都有复制</li>
</ol>
<p><img src="http://img.heeexy.com/memsql-profile.png" alt="profile"></p>
<h2 id="表结构优化"><a href="#表结构优化" class="headerlink" title="表结构优化"></a>表结构优化</h2><h3 id="Rowstore-vs-Columnstore"><a href="#Rowstore-vs-Columnstore" class="headerlink" title="Rowstore vs. Columnstore"></a>Rowstore vs. Columnstore</h3><p><a href="https://docs.memsql.com/tutorials/v6.8/optimizing-table-data-structures/" target="_blank" rel="noopener">https://docs.memsql.com/tutorials/v6.8/optimizing-table-data-structures/</a></p>
<p>Rowstore : 查询指定列，并发更新。使用无锁索引，支持多索引。频繁更新的事务场景。unique constraints 。同样会往disk写一份 用于恢复。</p>
<p>Columnstore： 顺序扫描，单索引。适用场景：聚合仅很少列（10列内）,扫描大量行，很少频繁单行删改，更新应该是大批量的修改</p>
<h2 id="分布式SQL"><a href="#分布式SQL" class="headerlink" title="分布式SQL"></a>分布式SQL</h2><h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><ul>
<li>每一个并行的查询都在每个leaf的每个partition上分开执行。</li>
<li>默认每个leaf的partition数量=cpu数量</li>
<li>每个partition都是个单独的库</li>
<li>reference tables在每个aggregator和leaf都有一份复制，适合小表</li>
<li>shard key   决定数据落到哪一partition</li>
<li>主键和unique key 需要包含shard key ，例如：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> clicks (</span><br><span class="line">        click_id <span class="built_in">BIGINT</span> AUTO_INCREMENT,</span><br><span class="line">        user_id <span class="built_in">INT</span>,</span><br><span class="line">        page_id <span class="built_in">INT</span>,</span><br><span class="line">        SHARD <span class="keyword">KEY</span> (user_id),</span><br><span class="line">        PRIMARY <span class="keyword">KEY</span> (click_id, user_id)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><ul>
<li>分布式join 相同的shard key来join可以提升性能</li>
<li>分布式事务，等待每个partition都ready，再一起提交</li>
<li>引用表必须具有显式主键。 分布式表中的AUTO_INCREMENT列必须是BIGINT。 自动增量值在每个聚合器上单调递增，但在整个群集中不连续。 分片表不支持唯一键（除非唯一键是分片键的超集）。 分片表不支持修改分片键的UPDATE查询。 分片表不支持UPDATE … LIMIT。</li>
</ul>
<h2 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h2><ol>
<li><p>mysql front连接不上</p>
<p>换用其它客户端可以，比如idea</p>
</li>
<li><p><a href="https://docs.memsql.com/tutorials/v6.8/build-stock-trade-database/" target="_blank" rel="noopener">https://docs.memsql.com/tutorials/v6.8/build-stock-trade-database/</a> 导入csv文件提示找不到文件</p>
<p>docker cp /home/hxy/download/companylist.csv 62b8df2d8761://usr/share</p>
</li>
</ol>
<h2 id="性能体验"><a href="#性能体验" class="headerlink" title="性能体验"></a>性能体验</h2><h3 id="测试机器"><a href="#测试机器" class="headerlink" title="测试机器"></a>测试机器</h3><p>AWS  8c32g  </p>
<h3 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h3><p>官方S3的数据，我们使用 columnstore 和 rowstore 各测一次sql查询。</p>
<p><a href="https://docs.memsql.com/guides/latest/load-data/pipelines/step-1/" target="_blank" rel="noopener">https://docs.memsql.com/guides/latest/load-data/pipelines/step-1/</a></p>
<h4 id="columnstore数据"><a href="#columnstore数据" class="headerlink" title="columnstore数据"></a><strong>columnstore数据</strong></h4><p><img src="http://img.heeexy.com/columnstore.png" alt="columnstore.png"></p>
<h4 id="rowstore-数据"><a href="#rowstore-数据" class="headerlink" title="rowstore 数据"></a><strong>rowstore</strong> <strong>数据</strong></h4><p><img src="http://img.heeexy.com/rowstore.png" alt="rowstore.png"></p>
<p>由于150W行数据存disk 占1G，存memory需要占5G，发现机器内存不足，只导入了一张150W行和一张25行的表。</p>
<h4 id="执行sql耗时"><a href="#执行sql耗时" class="headerlink" title="执行sql耗时"></a>执行sql耗时</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from nation limit 20;</span><br></pre></td></tr></table></figure>

<p><strong>columnstore</strong> 770ms  </p>
<p><strong>rowstore</strong> 700ms</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">select l_returnflag,</span><br><span class="line">l_linestatus,</span><br><span class="line">sum(l_quantity) as sum_qty,</span><br><span class="line">sum(l_extendedprice) as sum_base_price,</span><br><span class="line">sum(l_extendedprice * (1 - l_discount)) as sum_disc_price,</span><br><span class="line">sum(l_extendedprice * (1 - l_discount) * (1 + l_tax)) as sum_charge,</span><br><span class="line">avg(l_quantity) as avg_qty,</span><br><span class="line">avg(l_extendedprice) as avg_price,</span><br><span class="line">avg(l_discount) as avg_disc,</span><br><span class="line">count(*) as count_order</span><br><span class="line">from lineitem</span><br><span class="line">where l_shipdate &lt;&#x3D; date(&#39;1998-12-01&#39; - interval &#39;90&#39; day)</span><br><span class="line">group by l_returnflag, l_linestatus</span><br><span class="line">order by l_returnflag, l_linestatus;</span><br></pre></td></tr></table></figure>

<p><strong>columnstore   19s   5s  5s</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">l_orderkey,</span><br><span class="line">sum(l_extendedprice * (1 - l_discount)) as revenue,</span><br><span class="line">o_orderdate,</span><br><span class="line">o_shippriority</span><br><span class="line">from</span><br><span class="line">customer,</span><br><span class="line">orders,</span><br><span class="line">lineitem</span><br><span class="line">where</span><br><span class="line">c_mktsegment &#x3D; &#39;BUILDING&#39;</span><br><span class="line">and c_custkey &#x3D; o_custkey</span><br><span class="line">and l_orderkey &#x3D; o_orderkey</span><br><span class="line">and o_orderdate &lt; date(&#39;1995-03-15&#39;)</span><br><span class="line">and l_shipdate &gt; date(&#39;1995-03-15&#39;)</span><br><span class="line">group by</span><br><span class="line">l_orderkey,</span><br><span class="line">o_orderdate,</span><br><span class="line">o_shippriority</span><br><span class="line">order by</span><br><span class="line">revenue desc,</span><br><span class="line">o_orderdate</span><br><span class="line">limit 10;</span><br></pre></td></tr></table></figure>

<p><strong>columnstore</strong> 10s  5s  5s</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">c_custkey,</span><br><span class="line">c_name,</span><br><span class="line">sum(l_extendedprice * (1 - l_discount)) as revenue,</span><br><span class="line">c_acctbal,</span><br><span class="line">n_name,</span><br><span class="line">c_address,</span><br><span class="line">c_phone,</span><br><span class="line">c_comment</span><br><span class="line">from</span><br><span class="line">customer,</span><br><span class="line">orders,</span><br><span class="line">lineitem,</span><br><span class="line">nation</span><br><span class="line">where</span><br><span class="line">c_custkey &#x3D; o_custkey</span><br><span class="line">and l_orderkey &#x3D; o_orderkey</span><br><span class="line">and o_orderdate &gt;&#x3D; date(&#39;1993-10-01&#39;)</span><br><span class="line">and o_orderdate &lt; date(&#39;1993-10-01&#39;) + interval &#39;3&#39; month</span><br><span class="line">and l_returnflag &#x3D; &#39;R&#39;</span><br><span class="line">and c_nationkey &#x3D; n_nationkey</span><br><span class="line">group by</span><br><span class="line">c_custkey,</span><br><span class="line">c_name,</span><br><span class="line">c_acctbal,</span><br><span class="line">c_phone,</span><br><span class="line">n_name,</span><br><span class="line">c_address,</span><br><span class="line">c_comment</span><br><span class="line">order by</span><br><span class="line">revenue desc</span><br><span class="line">limit 20;</span><br></pre></td></tr></table></figure>

<p><strong>columnstore</strong> 12s  9s   9s</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">nation,</span><br><span class="line">o_year,</span><br><span class="line">sum(amount) as sum_profit</span><br><span class="line">from</span><br><span class="line">(</span><br><span class="line">select</span><br><span class="line">n_name as nation,</span><br><span class="line">extract(year from o_orderdate) as o_year,</span><br><span class="line">l_extendedprice * (1 - l_discount) - ps_supplycost * l_quantity as amount</span><br><span class="line">from</span><br><span class="line">part,</span><br><span class="line">supplier,</span><br><span class="line">lineitem,</span><br><span class="line">partsupp,</span><br><span class="line">orders,</span><br><span class="line">nation</span><br><span class="line">where</span><br><span class="line">s_suppkey &#x3D; l_suppkey</span><br><span class="line">and ps_suppkey &#x3D; l_suppkey</span><br><span class="line">and ps_partkey &#x3D; l_partkey</span><br><span class="line">and p_partkey &#x3D; l_partkey</span><br><span class="line">and o_orderkey &#x3D; l_orderkey</span><br><span class="line">and s_nationkey &#x3D; n_nationkey</span><br><span class="line">and p_name like &#39;%green%&#39;</span><br><span class="line">) as profit</span><br><span class="line">group by</span><br><span class="line">nation,</span><br><span class="line">o_year</span><br><span class="line">order by</span><br><span class="line">nation,</span><br><span class="line">o_year desc;</span><br></pre></td></tr></table></figure>

<p><strong>columnstore</strong> 32s   19s 19s</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from customer c</span><br><span class="line">left join orders o on c.c_custkey &#x3D; o.o_custkey</span><br><span class="line">left join nation n on c.c_nationkey &#x3D; n.n_nationkey</span><br><span class="line">where c.c_custkey &#x3D; &#39;8367&#39;</span><br><span class="line">limit 10;</span><br></pre></td></tr></table></figure>

<p><strong>columnstore</strong> 32s  4s  4s</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from customer c</span><br><span class="line">left join orders o on c.c_custkey &#x3D; o.o_custkey and o_custkey &#x3D; &#39;2141&#39;</span><br><span class="line">left join nation n on c.c_nationkey &#x3D; n.n_nationkey</span><br><span class="line">where c.c_custkey &#x3D; &#39;2141&#39;</span><br><span class="line">limit 10;</span><br></pre></td></tr></table></figure>

<p><strong>columnstore  2s 1s 1s</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from customer c</span><br><span class="line">where c.c_custkey &#x3D; &#39;2141&#39;</span><br><span class="line">limit 10;</span><br></pre></td></tr></table></figure>

<p><strong>rowstore</strong>  500ms</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/12/02/es-for-search/">ElasticSearch在高并发复杂查询业务场景的应用</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-12-02
        </span><span class="post-category">
            <a href="/categories/ElasticSearch/">ElasticSearch</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p>说起 ElasticSearch，往往大家想到的都是 ELK 的一套，但是作为 NoSQL，ES 有极快的响应速度，强大的聚合功能，支持复杂的查询条件，应对高并发的复杂查询的业务场景其实也是非常强力的。</p>
<blockquote>
<p>You Know, for Search</p>
</blockquote>
<p>我们团队就一直使用 ES 作为主力数据库， 从一开始做全文检索，到现在承担全部的商品列表页查询。近几个月将查询系统的 qps 从 1k 优化到了 10k+，其中 ES 的优化占了很重要一部分，准确的来说，应该是对 ES 特性的扬长避短起到了非常大的作用。</p>
<p><img src="http://img.heeexy.com/webpage.png" alt=""></p>
<h2 id="数组-amp-嵌套结构"><a href="#数组-amp-嵌套结构" class="headerlink" title="数组 &amp; 嵌套结构"></a>数组 &amp; 嵌套结构</h2><p>ES 没有 join，很多人直接就会认为 ES 无法处理一对多的情况，其实还有<a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.5/array.html" target="_blank" rel="noopener">数组</a>和<a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.5/nested.html" target="_blank" rel="noopener">嵌套结构</a>可以应付常见的业务场景。</p>
<p>比如一个商品拥有多种属性，都存放在一个数组字段中，使用 must 和 must_not 就可以灵活地进行查询筛选。</p>
<p>比如同款不同色的几件T恤，使用嵌套结构保存，搜索时只需要其中一件满足筛选条件，便可以全部带出来，在页面上以多个小色块展示，而无需占用多个展示位。并且还可以拿满足筛选条件的商品中的某属性最大值/最小值等进行排序，如官网给出的<a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.5/search-request-sort.html" target="_blank" rel="noopener">示例</a>:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"query"</span>: &#123;</span><br><span class="line">      <span class="attr">"nested"</span>: &#123;</span><br><span class="line">         <span class="attr">"path"</span>: <span class="string">"parent"</span>,</span><br><span class="line">         <span class="attr">"query"</span>: &#123;</span><br><span class="line">            <span class="attr">"bool"</span>: &#123;</span><br><span class="line">                <span class="attr">"must"</span>: &#123;<span class="attr">"range"</span>: &#123;<span class="attr">"parent.age"</span>: &#123;<span class="attr">"gte"</span>: <span class="number">21</span>&#125;&#125;&#125;,</span><br><span class="line">                <span class="attr">"filter"</span>: &#123;</span><br><span class="line">                    <span class="attr">"nested"</span>: &#123;</span><br><span class="line">                        <span class="attr">"path"</span>: <span class="string">"parent.child"</span>,</span><br><span class="line">                        <span class="attr">"query"</span>: &#123;<span class="attr">"match"</span>: &#123;<span class="attr">"parent.child.name"</span>: <span class="string">"matt"</span>&#125;&#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"sort"</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"parent.child.age"</span> : &#123;</span><br><span class="line">            <span class="attr">"mode"</span> :  <span class="string">"min"</span>,</span><br><span class="line">            <span class="attr">"order"</span> : <span class="string">"asc"</span>,</span><br><span class="line">            <span class="attr">"nested"</span>: &#123;</span><br><span class="line">               <span class="attr">"path"</span>: <span class="string">"parent"</span>,</span><br><span class="line">               <span class="attr">"filter"</span>: &#123;</span><br><span class="line">                  <span class="attr">"range"</span>: &#123;<span class="attr">"parent.age"</span>: &#123;<span class="attr">"gte"</span>: <span class="number">21</span>&#125;&#125;</span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">"nested"</span>: &#123;</span><br><span class="line">                  <span class="attr">"path"</span>: <span class="string">"parent.child"</span>,</span><br><span class="line">                  <span class="attr">"filter"</span>: &#123;</span><br><span class="line">                     <span class="attr">"match"</span>: &#123;<span class="attr">"parent.child.name"</span>: <span class="string">"matt"</span>&#125;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>商品列表页面能用到聚合的场景非常多，比如聚合出分类下（可能多达数万个商品）的各子分类，各属性的数量，并且需要支持复杂的筛选条件，比如库存，价格范围等等，并且这种查询速度远比 RDS 的 join + group by + count 快。</p>
<p>又比如需要查出最近10天内有新商品的日期列表，那就可以用到 date_histogram 聚合函数。</p>
<h2 id="动态字段"><a href="#动态字段" class="headerlink" title="动态字段"></a>动态字段</h2><p>动态字段的设计也为我们的业务提供了很大便利，由于与具体业务关联性太强，就不详细展开了。</p>
<p>ES能支持的动态字段数量非常的多，不过这里要留意的就是动态字段一个比较容易出问题的地方，就是瞬时写入大量的动态字段会导致集群索引的元数据大量变动，master 节点负载暴涨甚至挂掉。</p>
<h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><ol>
<li>没有 join。ES 的查询速度非常的快，但是不能 join 毕竟还是有一些业务场景无法使用。当然话又说回来，在高并发量下，多表 join 能不能抗得住也是个问题。对于查询，我们一贯的原则还是：<strong>把数据离线准备成便于查询的结构，线上实时查询尽可能的简单，一步到位</strong>。</li>
<li>由于要把数据离线准备好，这便带来了数据同步更新的问题，数据的时效性、准确性都需要保证，数组与嵌套结构的数据更新也不够方便高效，这些都会增加很多的工作量。</li>
</ol>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/09/01/upgrade-ElasticSearch/">ElasticSearch 2.3升级至6.3</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-09-01
        </span><span class="post-category">
            <a href="/categories/ElasticSearch/">ElasticSearch</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h1 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h1><h3 id="节点分配"><a href="#节点分配" class="headerlink" title="节点分配"></a>节点分配</h3><p>原集群 master*3 data*12 client*0</p>
<p>新集群  master*3 data*12  injest*0 coordinating*0</p>
<p>ingest 节点用于支持 pipeline 操作 对bulk和index文档进行预处理</p>
<p>coordinating 功能主要是分发请求,聚合各节点的处理结果,负载均衡,大规模集群可以设置一个给读,一个给写。但coordinating 数量也不宜过多,会拖慢选举主节点的时间,并且data节点其实也可以处理这些请求.</p>
<h3 id="节点设置"><a href="#节点设置" class="headerlink" title="节点设置"></a>节点设置</h3><p>search.remote.connect: false<br>node.ingest: false</p>
<h1 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h1><h3 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h3><p>由于有数据源及同步方案,所以只需数据全量导入6.3版本的集群即可.</p>
<h3 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h3><p>目前生产环境有300个索引需要同步,要检查同步脚本的创建索引,切别名等步骤.</p>
<h3 id="mapping设置"><a href="#mapping设置" class="headerlink" title="mapping设置"></a>mapping设置</h3><ol>
<li>type 只支持1种，自 ES7.0 起将不再支持 type—<a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.3/removal-of-types.html" target="_blank" rel="noopener">官方说明</a></li>
<li>对可以使用自增 id 的索引使用自增 id</li>
<li>对大多数字符串字段使用 keyword 类型</li>
<li>对不用于数值范围查找的数值类型改为keyword类型</li>
<li><a href="https://www.jianshu.com/p/d53ef9aa8416" target="_blank" rel="noopener">分词插件可能需要改动</a></li>
<li>index: no   改为   index:false</li>
<li>index: not_analyzed 删掉</li>
</ol>
<h3 id="提高迁移速度"><a href="#提高迁移速度" class="headerlink" title="提高迁移速度"></a>提高迁移速度</h3><ol>
<li>sudo swapoff -a</li>
<li>副本设置为0</li>
<li>refresh_interval 设置为 -1 （对线上生产集群上索引批量导入时，设置-1后，重新打开时可能会导致集群压力暴增）</li>
<li>导入数据</li>
<li>refresh_interval 设置为30</li>
<li>确认数据正确性</li>
<li>POST /_forcemerge     max_num_segments=1（对于大索引可能非常耗时）</li>
<li>副本设置为1</li>
</ol>
<h1 id="scala项目升级"><a href="#scala项目升级" class="headerlink" title="scala项目升级"></a>scala项目升级</h1><ol>
<li>scala &amp; play 升级, 尤其是play的升级会导致大量代码改动</li>
<li><a href="https://github.com/sksamuel/elastic4s" target="_blank" rel="noopener">elastic4s</a> 依赖升级，注意除了core包还需要http包 。</li>
<li>原本的获取client, 构建dsl,excute,解析response的大量代码要修改，尤其是构建dsl涉及大量业务，需要逐一比对修改。</li>
</ol>
<h1 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h1><p>Prometheus + Grafana 主要是获取ES信息的api随之升级，改动通常不大</p>
<p>另外推荐 xpack 的 monitor，收集了 segment 的数据，收集了每个索引的请求量，响应时间等信息，信息集成进了 kibana</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/04/03/MyBatis-ClasspathMapperScanner/">使用MyBatis时为什么Dao层不需要@Repository</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-03
        </span><span class="post-category">
            <a href="/categories/MyBatis%E7%AC%94%E8%AE%B0/">MyBatis笔记</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>Service层注入Dao时，  Intellij 总会以红色波浪线提示我们</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure>

<p>Could not autowire. No beans of ‘UserDao’ type found.<br>Checks autowiring problems in a bean class.</p>
<p>尽管我们都知道 Dao 层的 Bean 实际上都是有的，并且可以设置关闭这恼人的提示，但是我们有没有想过为什么 Intellij 就找不到这个 Bean 呢？甚至有人有这种做法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来避免提示，但是这种做法正确么？</p>
<p>所以今天我们的疑问就是</p>
<ol>
<li>为什么 Dao 层不需要加 @Repository 注解，源码里到底做了什么？</li>
<li>加了 @Repository 注解有什么影响？</li>
</ol>
<h1 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h1><ol>
<li><p>关键在于 ClassPathMapperScanner 对指定包的扫描，并且扫描过程对 Spring 原本的扫描 Bean 的步骤 “加了料” ，Spring 本身只扫实现类，但 MyBatis 的扫描器<strong>扫了接口</strong> 。并且扫完接口之后，为接口配了个 <strong>BeanDefinition</strong> ,并且这个 bd 的 BeanClass 是 <strong>MapperFactoryBean</strong> 。</p>
<blockquote>
<p>对于 BeanDefinition 和 MapperFactoryBean 不了解的同学请查询相关资料和源码</p>
</blockquote>
</li>
<li><p>仅仅只能解决 Intellij 静态查找 bean 的问题，没有实际作用。即使加了注解，比如@Controller，@Service 等等，也会被 Spring 的扫描器给忽略掉，因为<strong>扫描器会过滤掉接口</strong>。</p>
</li>
</ol>
<h1 id="源码探索"><a href="#源码探索" class="headerlink" title="源码探索"></a>源码探索</h1><blockquote>
<p>下面的源码部分如果读者提前有 MyBatis 的 Bean 的执行流程，和 Spring 的 Bean加载的相关知识就更好理解。</p>
</blockquote>
<h3 id="1-分析问题"><a href="#1-分析问题" class="headerlink" title="1. 分析问题"></a>1. 分析问题</h3><p>关于为什么不需要注解就能获取到 Dao 层的 Bean，看似答案很简单，因为配置了扫描指定这个包里的 xxxDao.class 啊，比如使用注解 @MapperScan(“com.example.dao”)。</p>
<p>这个答案太过表面，觉得问题简单只是因为对 Spring 的 Bean 不熟悉。</p>
<p>我们何时见过 @Component 及其衍生的3个注解 @Controller、@Service、@Repository <strong>加在接口上面</strong>的？</p>
<p>自己测试新建个接口，上面加注解，然后找个 Controller 里 @Autowired 注入一下，项目立马会报错 NoSuchBeanDefinitionException 。</p>
<h3 id="2-切入源码"><a href="#2-切入源码" class="headerlink" title="2. 切入源码"></a>2. 切入源码</h3><h4 id="切入点"><a href="#切入点" class="headerlink" title="切入点"></a>切入点</h4><p>既然使用注解 @MapperScan 就好使，那么我们就从这个点切入源码看一下，先找出源码中何处用了此注解，非常幸运的是，只有一处用到了此注解 ：MapperScannerRegistrar.registerBeanDefinitions() 。</p>
<p>并且从类名和方法名就可以很清楚的看出这个类的功能是扫描 Mapper 并注册，方法的功能就是注册 BeanDefinitions 到 Spring 中。方法的源码我就不贴了，很容易看出来是创建一个扫描器 <code>ClassPathMapperScanner</code> ，设置好一系列属性比如 Spring 的注册表之后，执行 doScan() 方法去扫描 @MapperScan 提供的包。</p>
<h4 id="doScan-扫描资源，转换为-BeanDefinition"><a href="#doScan-扫描资源，转换为-BeanDefinition" class="headerlink" title="doScan() 扫描资源，转换为 BeanDefinition"></a>doScan() 扫描资源，转换为 BeanDefinition</h4><p>doScan() 方法也很简单，就是两步：</p>
<ol>
<li>调用父类 ClassPathBeanDefinitionScanner 的doScan()方法，也就是 Spring 扫描BeanDefinition 的方法。过程不是很重要，我们需要知道这个扫描方法的一个关键就是</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br></pre></td></tr></table></figure>

<p>在其中对所有的候选者使用 isCandidateComponent() 方法判断是否为符合要求的 BeanDefinition。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.excludeFilters) &#123;</span><br><span class="line">   <span class="keyword">if</span> (tf.match(metadataReader, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.includeFilters) &#123;</span><br><span class="line">   <span class="keyword">if</span> (tf.match(metadataReader, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">      <span class="keyword">return</span> isConditionMatch(metadataReader);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这有两组过滤器来过滤扫描到的资源。<strong>Spring 默认的过滤器是排除掉抽象类/接口的。而MyBatis 的扫描器重新注册了过滤器，默认对接口放行。</strong></p>
<blockquote>
<p>其实还有一些其它的过滤要求，但是不影响我们本问题的探究，所以不深入解读了。</p>
</blockquote>
<p>源码读到这里，我们先找到了本文的第二个问题的答案。也就是 Spring 会忽略掉接口上面的注解，不会添加它进入 BeanDefiniiton ,也就难怪测试的时候会抛出 NoSuchBeanDefinitionException 的异常了。而 MyBatis 则会把这些接口拉过来注册BD 。</p>
<h4 id="对-BeanDefinition-的加工"><a href="#对-BeanDefinition-的加工" class="headerlink" title="对 BeanDefinition 的加工"></a>对 BeanDefinition 的加工</h4><p>读到这里我们可能有了更大的疑问，拿接口注册 BeanDefinition ，那获取 Bean 的时候如何去实例化这个对象啊？接口可是不能实例化出对象的啊，而且我们也没有做实现。</p>
<p>原来是 MyBatis 的扫描器在调用完父类的扫描方法后，对 BeanDefinition 进行了加工 processBeanDefinitions() 。其中最关键的两行代码是 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">definition.getConstructorArgumentValues().addGenericArgumentValue(definition.getBeanClassName()); </span><br><span class="line">definition.setBeanClass(<span class="keyword">this</span>.mapperFactoryBean.getClass());</span><br></pre></td></tr></table></figure>

<p>第一行，我们发现把这个<strong>接口的类名塞到了构造器参数中</strong>。</p>
<blockquote>
<p>小彩蛋，这里塞的是 String ，而我们的构造器参数其实要的是 Class 。但是 Spring 的 ConstructorResolver.autowireConstructor 中用到了 Object[] argsToUse 去做了个转换 。</p>
</blockquote>
<p>第二行，beanDefinition 的 <strong>BeanClass 被设置成了 MapperFactoryBean</strong> !</p>
<p>熟悉 Spring 和 MyBatis 的读者肯定一下就明白了，就是这个地方进行了”偷梁换柱”！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure>

<p>还是拿 UserDao 为例，我们向 Spring 容器说 “给我来个 UserDao 的实例”，而 Spring 根据注册时候的 BeanDefinition ，去工厂( <strong>MapperFactoryBean</strong>  )里面扔了个 UserDao.class 的参数进去，工厂的 getObject() 方法给我们返回了它制造的 userDao 。</p>
<p>就这样，我们没有去写实现类，轻轻松松拿到了我们需要的 userDao 。</p>
<p>至于 <strong>MapperFactoryBean</strong>  里做了什么返回了 userDao 出来？其实就是它的 getObject 方法返回的是 DefaultSqlSession.getMapper(Class<T> type)方法，返回的是 MapperProxy 代理的类，而这个代理类的 invoke 方法并不像我们平时见到的代理中的 invoke 方法一样调用原始目标的 method.invoke ，而是去找 MapperMethod 执行了。</p>
<h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><p>这次的源码探究下来，收获的不仅仅是了解了 Dao 层 Bean 的注入，更是串起了我们最常用的 Spring 和 MyBatis ，换句话说，我们打通了从 Service 层到 Dao 层。</p>
<p>在以往 Debug 代码时看到的 MapperProxy，MapperMethod，我们清楚了这是从何而来，也对 MyBatis 中代理的巧妙运用更加熟悉。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://blog.csdn.net/java280580332/article/details/72123890" target="_blank" rel="noopener">https://blog.csdn.net/java280580332/article/details/72123890</a> </p>
<p><a href="https://blog.csdn.net/mingtian625/article/details/47684271" target="_blank" rel="noopener">https://blog.csdn.net/mingtian625/article/details/47684271</a></p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/01/28/recent-summary/">近期阅读源码的总结与转变</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-01-28
        </span><span class="post-category">
            <a href="/categories/%E5%B0%8F%E7%BB%93/">小结</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h2 id="阅读源码"><a href="#阅读源码" class="headerlink" title="阅读源码"></a>阅读源码</h2><h3 id="初读-Spring"><a href="#初读-Spring" class="headerlink" title="初读 Spring"></a>初读 Spring</h3><p>2017年9月开始阅读 Spring 源码，便在博客上记录自己的阅读笔记，阅读的过程真的是恨痛苦，一个月的时间两大章节还没读完，效果上也不明显。</p>
<p>后面几个月公司业务繁忙更是停下了读源码的节奏。</p>
<h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><p>而12月入了一本《MyBatis 技术内幕》，介绍 MyBatis 的书，想从 MyBatis 入手，并且带着自己的小问题去研究 MyBatis 的源码，去探究一下我用 JSONObject 为什么就可以替代 JavaBean 。</p>
<p>花了一个月的时间便读完了第一遍书，也大致解答了自己的疑惑。发现研究起 MyBatis 确实是轻松很多，总结一下有以下方面的原因：</p>
<ul>
<li>MyBatis 源码量小很多，层次结构清晰，功能明确，确实比 Spring 要简单很多</li>
<li>作者划分章节层次合适</li>
<li>学会了 Debug 源码</li>
<li>拿起了实体书…比9月看电子书时确实方便很多</li>
</ul>
<p>一本书走完一遍，感觉清楚了很多，对于 MyBatis 剩下的任务，就是再读一遍，特别是带着问题再读，比如去研究它的缓存、配置、反射。</p>
<h3 id="再读-Spring"><a href="#再读-Spring" class="headerlink" title="再读 Spring"></a>再读 Spring</h3><p>1月再回过头继续学习 Spring ，其实最大的转变就是，不再执着于见到一段代码就想一直钻到底弄清楚了，Spring 的层次太深，特别容易钻着钻着就把自己绕得不知道在哪了。因此，还是根据书本介绍，文档注释和函数/变量名称大概了解函数的作用先，待刷完一遍之后再回过头二刷再追求搞明白吧。</p>
<h2 id="转变"><a href="#转变" class="headerlink" title="转变"></a>转变</h2><h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p>关于博客的记录，也要做一做转变了。起初写得东西只是笔记，渐渐加入了自己的理解，但是目前来看质量还是不够，有一个很重要的原因就是自己对一些还没有深刻的认识。</p>
<p>前阵子想独立钻研一波 Spring 的 autowiredByType，就匆匆忙忙开了一文，结果读着读着才发现这坑深不见底，实在不该在第一遍时就去碰…</p>
<p>因此，计划博客向更有营养的方向发展，尽量让博客能记录、传播一些能提升自己和其他读者认识的东西。像上一文自己动手实现解决循环依赖就是一个很好的主题，虽然文章写得不够好，技术含量也不够高，但是至少方向上来说确实能学到新东西。</p>
<h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p>博客的更新频率将会降低，一方面是要自己先学透，提示博文质量，另一方面也是其实后面一段时间将会将重心放在找工作上。毕竟对于技术面试和以前的考试差不多，精读源码实在是性价比有点低，全面复习准备面试题效果更好。虽然我是不喜欢准备面试题的，但没有办法，下一份工作很关键，只有找到稳定的，能追求技术的团队，才能提供安心的钻研技术的环境。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/01/28/IoC/">极简 Spring 框架 -- 浅析循环依赖</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-01-28
        </span><span class="post-category">
            <a href="/categories/Spring%E7%AC%94%E8%AE%B0/">Spring笔记</a>
            </span>
        </div>
    </header>

    <div class="post-content"><blockquote>
<p> 从网上看到一篇博文 <a href="https://diaozxin007.github.io/2018/01/08/spring-ioc/" target="_blank" rel="noopener">徒手撸框架–实现IoC</a> ，写得很棒，作者抛开了 Spring 源码中复杂的校验，拓展等功能，实现了一个极简的 IoC 框架，让 Spring 源码初学者可以清楚的看到 IOC 的实现流程。</p>
<p> 本文就借其框架，略加改造，再次介绍一下 Spring 是如何处理循环依赖的。</p>
</blockquote>
<p>了解本项目核心代码需要先参考原作者的博文 <a href="https://diaozxin007.github.io/2018/01/08/spring-ioc/" target="_blank" rel="noopener">徒手撸框架–实现IoC</a> 。</p>
<h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><p>其实很好理解，A 类依赖 B，B 又依赖 A。</p>
<p>说具体点就是 ，我们要 getBean(“a”)， A 在实例化时需要为类型为 B 的成员变量赋值，因此去 getBean(“b”)，而 getBean(“b”) 的时候又需要为其类型为A 的成员变量赋值，此时又会回过头去实例化 A ，导致无限循环。</p>
<p>用代码展示就是 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="meta">@AutoWired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="meta">@AutoWired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码改造"><a href="#代码改造" class="headerlink" title="代码改造"></a>代码改造</h3><p>最主要的代码改造在于 BeanFactoryImpl 内， 添加了成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>
<p>用于缓存正在创建中的，提前暴露出来的单例 bean。</p>
<p>在获取 bean 时，会在创建之前先从此 Map 中尝试获取，而这就是解决循环依赖的关键。</p>
<p>以上面的例子来说，就是一开始 getBean(“a”) 时，将未完成的 a 放入缓存，getBean(“b”) 时，需要去获取 a ,会从缓存中获取，而不是再去实例化 a。</p>
<p><img src="http://img.heeexy.com/CyclicDependence.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//查找对象是否已经实例化过</span></span><br><span class="line">    Object bean = beanMap.get(name);</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    Object earlyBean = earlySingletonObjects.get(name);</span><br><span class="line">    <span class="keyword">if</span> (earlyBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"循环依赖，提前返回尚未加载完成的bean:"</span> + name);</span><br><span class="line">        <span class="keyword">return</span> earlyBean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没有实例化，那就需要调用createBean来创建对象</span></span><br><span class="line">    BeanDefinition beanDefinition = beanDefineMap.get(name);</span><br><span class="line">    bean = createBean(beanDefinition);</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">        earlySingletonObjects.put(name, bean);</span><br><span class="line">        <span class="comment">//对象创建成功以后，注入对象需要的参数</span></span><br><span class="line">        populatebean(bean, beanDefinition);</span><br><span class="line">        <span class="comment">//再吧对象存入Map中方便下次使用。</span></span><br><span class="line">        beanMap.put(name, bean);</span><br><span class="line">        <span class="comment">//从早期单例Map中移除</span></span><br><span class="line">        earlySingletonObjects.remove(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结束返回</span></span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h3><p>Q: 构造器循环依赖为什么无法解决？</p>
<p>A: 从上面代码可以看出，需要在 createBean 之后，才能将其放入缓存，而构造过程是在 createBean 之内的，此时尚未构造好一个基本的 bean ,拿什么放入缓存呢？</p>
<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>上面只贴了 getBean 的代码，仅仅修改了原作者不到 10 行代码，其实在修改原框架，实现我们要的功能时不止这么多，包括调整对 json 的解析，对 bean 的填充等。</p>
<p>感受到 Spring 框架真的是很复杂很全面，这复杂程度靠说是说不清楚的，也不是翻一遍书看看源码就能明白的。而且看源码其实还是似懂非懂，中间的细节迷迷糊糊就可能跳过去了。</p>
<p>在追随 Spring 脚步，复现其代码的时候，才更深刻的理解其中很多操作，很多类的作用。比如说 BeanDefinition,  BeanWrapper , PropertyDescriptor 这些类在我想要实现一些功能的时候才能体会到 Spring 创造它们的重要性。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/01/24/beanNamesForTypeIncludingAncestors/">Spring 源码笔记-2.8 根据类型寻找 bean--找出所有匹配类型的 beanName</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-01-24
        </span><span class="post-category">
            <a href="/categories/Spring%E7%AC%94%E8%AE%B0/">Spring笔记</a>
            </span>
        </div>
    </header>

    <div class="post-content"><blockquote>
<p><a href="/2018/01/23/findAutowireCandidates/">前文</a></p>
</blockquote>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>入参说明</p>
<ul>
<li>includeNonSingletons：是否包括非单例的 bean，比如 prototype scope</li>
<li>allowEagerInit：为了这个检查（找出所有匹配类型的 beanName），是否初始化 lazy-init 单例和由 FactoryBeans 创建的对象。此处我们传入的值为 true。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String[] beanNamesForTypeIncludingAncestors(</span><br><span class="line">			ListableBeanFactory lbf, Class&lt;?&gt; type, <span class="keyword">boolean</span> includeNonSingletons, <span class="keyword">boolean</span> allowEagerInit) &#123;</span><br><span class="line"></span><br><span class="line">		Assert.notNull(lbf, <span class="string">"ListableBeanFactory must not be null"</span>);</span><br><span class="line">  <span class="comment">//方法主干还是在这行 getBeanNamesForType</span></span><br><span class="line">		String[] result = lbf.getBeanNamesForType(type, includeNonSingletons, allowEagerInit);</span><br><span class="line">  <span class="comment">//下面的内容就是从 bf 的 parent 中找，</span></span><br><span class="line">		<span class="keyword">if</span> (lbf <span class="keyword">instanceof</span> HierarchicalBeanFactory) &#123;</span><br><span class="line">			HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf;</span><br><span class="line">			<span class="keyword">if</span> (hbf.getParentBeanFactory() <span class="keyword">instanceof</span> ListableBeanFactory) &#123;</span><br><span class="line">  <span class="comment">//此处以 parent 再来调此方法，合并结果。</span></span><br><span class="line">				String[] parentResult = beanNamesForTypeIncludingAncestors(</span><br><span class="line">						(ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit);</span><br><span class="line">				List&lt;String&gt; resultList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">				resultList.addAll(Arrays.asList(result));</span><br><span class="line">				<span class="keyword">for</span> (String beanName : parentResult) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!resultList.contains(beanName) &amp;&amp; !hbf.containsLocalBean(beanName)) &#123;</span><br><span class="line">						resultList.add(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				result = StringUtils.toStringArray(resultList);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p> 看来我们还需要继续深入到 <code>getBeanNamesForType</code>中去一探究竟。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] getBeanNamesForType(Class&lt;?&gt; type, <span class="keyword">boolean</span> includeNonSingletons, <span class="keyword">boolean</span> allowEagerInit) &#123;</span><br><span class="line">  <span class="comment">//configurationFrozen：判断所有 bean 的 定义元数据是否可以被缓存</span></span><br><span class="line">  <span class="comment">//如果不能缓存 或没type 或不允许急切初始化，则直接查 doGetBeanNamesForType</span></span><br><span class="line">   <span class="keyword">if</span> (!isConfigurationFrozen() || type == <span class="keyword">null</span> || !allowEagerInit) &#123;</span><br><span class="line">      <span class="keyword">return</span> doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, allowEagerInit);</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="comment">//否则先查缓存，没有缓存的话再查 doGetBeanNamesForType 并塞入缓存</span></span><br><span class="line">   Map&lt;Class&lt;?&gt;, String[]&gt; cache =</span><br><span class="line">         (includeNonSingletons ? <span class="keyword">this</span>.allBeanNamesByType : <span class="keyword">this</span>.singletonBeanNamesByType);</span><br><span class="line">   String[] resolvedBeanNames = cache.get(type);</span><br><span class="line">   <span class="keyword">if</span> (resolvedBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> resolvedBeanNames;</span><br><span class="line">   &#125;</span><br><span class="line">   resolvedBeanNames = doGetBeanNamesForType(ResolvableType.forRawClass(type), includeNonSingletons, <span class="keyword">true</span>);</span><br><span class="line">  <span class="comment">//判断是否缓存安全：依据我们目标class 和当前beanFactory的classLoader是否一致</span></span><br><span class="line">   <span class="keyword">if</span> (ClassUtils.isCacheSafe(type, getBeanClassLoader())) &#123;</span><br><span class="line">      cache.put(type, resolvedBeanNames);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> resolvedBeanNames;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再深入一层到 <code>doGetBeanNamesForType</code>  ，其中逻辑外层是遍历所有的 beanName, 对于不是别名的进行处理，处理过程如下（省略了 try-catch ）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先获取这个beanName对应的mbd，它的相关定义配置信息</span></span><br><span class="line">RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"><span class="comment">// Only check bean definition if it is complete.</span></span><br><span class="line"><span class="comment">// 不是抽象的</span></span><br><span class="line"><span class="comment">// 并且 允许急切初始化 或 （此bean不需要急切初始化 且（有beanClass 或 不是lazyInit 或 允许急切的类加载，即使是懒惰的初始化bean））</span></span><br><span class="line"><span class="keyword">if</span> (!mbd.isAbstract() &amp;&amp; (allowEagerInit ||</span><br><span class="line">      ((mbd.hasBeanClass() || !mbd.isLazyInit() || isAllowEagerClassLoading())) &amp;&amp;</span><br><span class="line">            !requiresEagerInitForType(mbd.getFactoryBeanName()))) &#123;</span><br><span class="line"><span class="comment">// In case of FactoryBean, match object created by FactoryBean.</span></span><br><span class="line"><span class="comment">//判断是否 FactoryBean</span></span><br><span class="line">   <span class="keyword">boolean</span> isFactoryBean = isFactoryBean(beanName, mbd);</span><br><span class="line">   BeanDefinitionHolder dbd = mbd.getDecoratedDefinition();</span><br><span class="line"><span class="comment">//接下来又是一段非常长的逻辑判断，判断是否匹配</span></span><br><span class="line">   <span class="keyword">boolean</span> matchFound =</span><br><span class="line">         (allowEagerInit || !isFactoryBean ||</span><br><span class="line">               (dbd != <span class="keyword">null</span> &amp;&amp; !mbd.isLazyInit()) || containsSingleton(beanName)) &amp;&amp;</span><br><span class="line">         (includeNonSingletons ||</span><br><span class="line">               (dbd != <span class="keyword">null</span> ? mbd.isSingleton() : isSingleton(beanName))) &amp;&amp;</span><br><span class="line">         isTypeMatch(beanName, type);</span><br><span class="line">   <span class="keyword">if</span> (!matchFound &amp;&amp; isFactoryBean) &#123;</span><br><span class="line">      <span class="comment">// In case of FactoryBean, try to match FactoryBean instance itself next.</span></span><br><span class="line"><span class="comment">//如果不匹配，还要试试匹配FactoryBean本身，因为说不好要的就是这个FactoryBean呢</span></span><br><span class="line">      beanName = FACTORY_BEAN_PREFIX + beanName;</span><br><span class="line">      matchFound = (includeNonSingletons || mbd.isSingleton()) &amp;&amp; isTypeMatch(beanName, type);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (matchFound) &#123;</span><br><span class="line">      result.add(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查一遍手动的单例集合</span></span><br><span class="line"><span class="comment">//对于 FactoryBean ,如果匹配到它的getObject()满足，就不会继续去匹配它本身</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : <span class="keyword">this</span>.manualSingletonNames) &#123;</span><br><span class="line">				<span class="comment">// In case of FactoryBean, match object created by FactoryBean.</span></span><br><span class="line">				<span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">					<span class="keyword">if</span> ((includeNonSingletons || isSingleton(beanName)) &amp;&amp; isTypeMatch(beanName, type)) &#123;</span><br><span class="line">						result.add(beanName);</span><br><span class="line">						<span class="comment">// Match found for this bean: do not match FactoryBean itself anymore.</span></span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// In case of FactoryBean, try to match FactoryBean itself next.</span></span><br><span class="line">					beanName = FACTORY_BEAN_PREFIX + beanName;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// Match raw bean instance (might be raw FactoryBean).</span></span><br><span class="line">				<span class="keyword">if</span> (isTypeMatch(beanName, type)) &#123;</span><br><span class="line">					result.add(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>前一段的超长的逻辑判断看得人头疼，但是先看下半段的遍历，突然就找到了最关键判断类型匹配的函数 <code>isTypeMatch</code>，从名字就看出来，这应该就是判断类型匹配的地方啦。</p>
<p>然而点进去一看，居然是长达 100 行的函数。</p>
<h4 id="isTypeMatch"><a href="#isTypeMatch" class="headerlink" title="isTypeMatch"></a>isTypeMatch</h4><p>首先从单例中查找，匹配这个单例 bean 的类型和我们目标的类型，其中对 factoryBean 的处理也比较简单，就不再贴代码了。对于注册的 null instance ,也返回 false。</p>
<p>再从父工厂找，递归 isTypeMatch 。</p>
<p>再就是复杂的查找了。</p>
<p>先定义个 typesToMatch ，包括了目标类型和 FactoryBean .</p>
<p>然后我们再继续看代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check decorated bean definition, if any: We assume it'll be easier</span></span><br><span class="line"><span class="comment">// to determine the decorated bean's type than the proxy's type.</span></span><br><span class="line"><span class="comment">// 先检查 bean 的装饰definition。</span></span><br><span class="line">BeanDefinitionHolder dbd = mbd.getDecoratedDefinition();</span><br><span class="line"><span class="keyword">if</span> (dbd != <span class="keyword">null</span> &amp;&amp; !BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">   RootBeanDefinition tbd = getMergedBeanDefinition(dbd.getBeanName(), dbd.getBeanDefinition(), mbd);</span><br><span class="line">   Class&lt;?&gt; targetClass = predictBeanType(dbd.getBeanName(), tbd, typesToMatch);</span><br><span class="line">   <span class="keyword">if</span> (targetClass != <span class="keyword">null</span> &amp;&amp; !FactoryBean<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">targetClass</span>)) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> typeToMatch.isAssignableFrom(targetClass);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意此处predictBeanType返回了很关键的Class ,我们后面再详细分析此方法。</span></span><br><span class="line">Class&lt;?&gt; beanType = predictBeanType(beanName, mbd, typesToMatch);</span><br><span class="line"><span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check bean class whether we're dealing with a FactoryBean.</span></span><br><span class="line"><span class="comment">//接下来就是处理 FactoryBean</span></span><br><span class="line"><span class="keyword">if</span> (FactoryBean<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">beanType</span>)) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">      <span class="comment">// If it's a FactoryBean, we want to look at what it creates, not the factory class.</span></span><br><span class="line">      beanType = getTypeForFactoryBean(beanName, mbd);</span><br><span class="line">      <span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">   <span class="comment">// Special case: A SmartInstantiationAwareBeanPostProcessor returned a non-FactoryBean</span></span><br><span class="line">   <span class="comment">// type but we nevertheless are being asked to dereference a FactoryBean...</span></span><br><span class="line">   <span class="comment">// Let's check the original bean class and proceed with it if it is a FactoryBean.</span></span><br><span class="line">   beanType = predictBeanType(beanName, mbd, FactoryBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   <span class="keyword">if</span> (beanType == <span class="keyword">null</span> || !FactoryBean<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">beanType</span>)) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对其 resolvableType 进行处理</span></span><br><span class="line">ResolvableType resolvableType = mbd.targetType;</span><br><span class="line"><span class="keyword">if</span> (resolvableType == <span class="keyword">null</span>) &#123;</span><br><span class="line">   resolvableType = mbd.factoryMethodReturnType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (resolvableType != <span class="keyword">null</span> &amp;&amp; resolvableType.resolve() == beanType) &#123;</span><br><span class="line">   <span class="keyword">return</span> typeToMatch.isAssignableFrom(resolvableType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果以上都没有处理掉的话， 则判读typeToMatch和 beanType </span></span><br><span class="line"><span class="keyword">return</span> typeToMatch.isAssignableFrom(beanType);</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<p>目前很遗憾 isTypeMatch 往下还有很复杂的逻辑暂时不能看懂，但是从外层的逻辑大致知道寻找所有匹配的beanName 的方法非常的“复杂粗暴”。遍历 beanDefinitionNames 已定义的所有 bean，即使是一个小型的项目也有近200个 bean 需要遍历，并且这数百个 beanName 还要遍历非常多次。</p>
<p>只能说根据 type 寻找 bean 实在是比根据 name 复杂了太多太多，从源码看真是深坑，理解了为什么作者直接忽略了这部分…应该是第二遍或第三遍阅读 Spring 源码时才能理解。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/01/23/findAutowireCandidates/">Spring 源码笔记-2.7 根据类型寻找 bean</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-01-23
        </span><span class="post-category">
            <a href="/categories/Spring%E7%AC%94%E8%AE%B0/">Spring笔记</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Spring 装配 bean 有两种类型：<code>autowireByName</code> 和 <code>autowireByType</code> 。</p>
<p><code>autowireByName</code> 通过名称查找很直接，就是我们一直在学的 getBean() 。</p>
<p>而 <code>autowireByType</code> 根据类型查找相比起来就要复杂一些了，《 Spring 源码深度解析 》 中有介绍过的部分我就不再重复贴了，但是书中遗漏了一处重要的部分—— <strong>findAutowireCandidates 查找所有合适的 bean</strong>，还有一处新版本 Spring 中升级的部分——<strong>如果只需要一个但是找出多个 bean 该怎么处理</strong>，今天我们先来学习第一部分。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="本函数要做什么"><a href="#本函数要做什么" class="headerlink" title="本函数要做什么"></a>本函数要做什么</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/article"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ArticleService articleService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在初始化 ArticleController 的过程中，我们要为其装配 ArticleService 。</p>
<p>忽略掉外面代码一层一层的包裹之后，我们走到 <code>DefaultListableBeanFactory.findAutowireCandidates</code> 这个函数中，要寻找合适的候选 bean 。由于可能会找到多个，因此返回结果是候选 bean 的名称和其对应实例构成的 Map 。</p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三个参数的含义依次是 </span></span><br><span class="line"><span class="comment">// 正在解析的 beanName, 本例中即 "articleController"</span></span><br><span class="line"><span class="comment">// 需要装配的 bean 类型, 本例中即 ArticleService.class</span></span><br><span class="line"><span class="comment">// 对当前依赖关系的解析类，记录了 ArticleController 和 ArticleService 的依赖关系</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title">findAutowireCandidates</span><span class="params">(String beanName,</span></span></span><br><span class="line"><span class="function"><span class="params">   Class&lt;?&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params"> DependencyDescriptor descriptor)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//第一步就是查找出所有符合类型的 beanName 。</span></span><br><span class="line">  <span class="comment">//似乎第一句就干完全部逻辑了？？？稍后我们再详细分析这个方法。</span></span><br><span class="line">	String[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">				<span class="keyword">this</span>, requiredType, <span class="keyword">true</span>, descriptor.isEager());</span><br><span class="line">		Map&lt;String, Object&gt; result = <span class="keyword">new</span> LinkedHashMap&lt;String, Object&gt;(candidateNames.length);</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *	resolvableDependencies 记录了 依赖类型--具体装配值 的映射</span></span><br><span class="line"><span class="comment">   *  	遍历 resolvableDependencies。如果该类型是我们需要的类型（ArticleService），</span></span><br><span class="line"><span class="comment">   *	</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">		<span class="keyword">for</span> (Class&lt;?&gt; autowiringType : <span class="keyword">this</span>.resolvableDependencies.keySet()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (autowiringType.isAssignableFrom(requiredType)) &#123;</span><br><span class="line">				Object autowiringValue = <span class="keyword">this</span>.resolvableDependencies.get(autowiringType);</span><br><span class="line">              <span class="comment">//key值是我们需要的类型，但value值未必。</span></span><br><span class="line">              <span class="comment">//value可能是ObjectFactory，就得调用它的 getObject() 来获取真正的bean.</span></span><br><span class="line">				autowiringValue = AutowireUtils.resolveAutowiringValue(autowiringValue, requiredType);</span><br><span class="line">				<span class="keyword">if</span> (requiredType.isInstance(autowiringValue)) &#123;</span><br><span class="line">                  <span class="comment">//如果类型匹配，则塞入result</span></span><br><span class="line">					result.put(ObjectUtils.identityToString(autowiringValue), autowiringValue);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (String candidate : candidateNames) &#123;</span><br><span class="line">          <span class="comment">//如果不是自己依赖自己 ， 并且符合装配候选，就塞入result。</span></span><br><span class="line">          <span class="comment">//何为符合装配候选（isAutowireCandidate）呢？稍后我们再详细分析。</span></span><br><span class="line">			<span class="keyword">if</span> (!isSelfReference(beanName, candidate) &amp;&amp; isAutowireCandidate(candidate, descriptor)) &#123;</span><br><span class="line">				addCandidateEntry(result, candidate, descriptor, requiredType);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (result.isEmpty() &amp;&amp; !indicatesMultipleBeans(requiredType)) &#123;</span><br><span class="line">		<span class="comment">// Consider fallback matches if the first pass failed to find anything...</span></span><br><span class="line">          <span class="comment">//如果之前一轮都没找到，则考虑回退匹配，什么是回退匹配？稍后再分析。</span></span><br><span class="line">			DependencyDescriptor fallbackDescriptor = descriptor.forFallbackMatch();</span><br><span class="line">			<span class="keyword">for</span> (String candidate : candidateNames) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!isSelfReference(beanName, candidate) &amp;&amp; isAutowireCandidate(candidate, fallbackDescriptor)) &#123;</span><br><span class="line"><span class="comment">//再执行一遍上面的方法。如果不是自己依赖自己，并且符合装配候选，就塞入result。</span></span><br><span class="line">					addCandidateEntry(result, candidate, descriptor, requiredType);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (result.isEmpty()) &#123;</span><br><span class="line"><span class="comment">// Consider self references as a final pass...</span></span><br><span class="line"><span class="comment">// but in the case of a dependency collection, not the very same bean itself.</span></span><br><span class="line"><span class="comment">// 如果依然没找到结果，那么满足以下条件的也是我们的目标。</span></span><br><span class="line"><span class="comment">// 1.是自引用</span></span><br><span class="line"><span class="comment">// 2.依赖不是多元素依赖 或者 bean名和候选者名字不相等（这里就避免了自引用导致无限循环）</span></span><br><span class="line"><span class="comment">// 3.候选者符合回退匹配之后的装配候选</span></span><br><span class="line">				<span class="keyword">for</span> (String candidate : candidateNames) &#123;</span><br><span class="line">					<span class="keyword">if</span> (isSelfReference(beanName, candidate) &amp;&amp;</span><br><span class="line">							(!(descriptor <span class="keyword">instanceof</span> MultiElementDescriptor) || !beanName.equals(candidate)) &amp;&amp;</span><br><span class="line">							isAutowireCandidate(candidate, fallbackDescriptor)) &#123;</span><br><span class="line">						addCandidateEntry(result, candidate, descriptor, requiredType);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>看完主干自然还是有点迷糊，我们留下了三个问题要继续研究：</p>
<ul>
<li><a href="/2018/01/24/beanNamesForTypeIncludingAncestors/">如何查找出所有符合类型的 beanName</a></li>
<li>什么是符合装配候选</li>
<li>什么是回退匹配</li>
</ul>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/01/19/BeanWrapper/">Spring 源码笔记-2.6 BeanWrapper 对比 MyBatis</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-01-19
        </span><span class="post-category">
            <a href="/categories/Spring%E7%AC%94%E8%AE%B0/">Spring笔记</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h2 id="Spring-vs-MyBatis"><a href="#Spring-vs-MyBatis" class="headerlink" title="Spring vs MyBatis"></a>Spring vs MyBatis</h2><p>Spring 和 MyBatis 中都有 BeanWrapper , Spring 中为接口， 实现类为 BeanWrapperImpl , 为了方便后面区分，本文用 SB 指代 Spring 的 BeanWrapperImpl ，用 MB 指代 MyBatis 中的 BeanWrapper。</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>BeanWrapper 都属于各自框架的<strong>反射工具箱</strong>的重要组成部分。都是创建实例并且为其属性赋值的。以 SB 为例，下面的代码应该很容易看明白它的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">BeanWrapper company = BeanWrapperImpl(<span class="keyword">new</span> Company());</span><br><span class="line"><span class="comment">// setting the company name..</span></span><br><span class="line">company.setPropertyValue(<span class="string">"name"</span>, <span class="string">"Some Company Inc."</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... can also be done like this:</span></span><br><span class="line">PropertyValue value = <span class="keyword">new</span> PropertyValue(<span class="string">"name"</span>, <span class="string">"Some Company Inc."</span>);</span><br><span class="line">company.setPropertyValue(value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok, let's create the director and tie it to the company:</span></span><br><span class="line">BeanWrapper jim = BeanWrapperImpl(<span class="keyword">new</span> Employee());</span><br><span class="line">jim.setPropertyValue(<span class="string">"name"</span>, <span class="string">"Jim Stravinsky"</span>);</span><br><span class="line">company.setPropertyValue(<span class="string">"managingDirector"</span>, jim.getWrappedInstance());</span><br><span class="line"></span><br><span class="line"><span class="comment">// retrieving the salary of the managingDirector through the company</span></span><br><span class="line">Float salary = (Float) company.getPropertyValue(<span class="string">"managingDirector.salary"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h2><ol>
<li><strong>核心功能</strong>功能基本相同</li>
<li>对要生成的类的要求规范也相同，有 get set 方法。</li>
<li>它们的<strong>底层</strong>也没有什么秘密，归根到底都是使用 <code>java.lang.reflect</code> 包下的 Constructor , Method 等等工具。</li>
</ol>
<h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><p>可能是我刚开始研究 SB 的原因，感觉 SB 源码更加复杂，结构也没那么清楚，关联了向下层级的工具类，很长很长一段的源码。 <a href="http://blog.csdn.net/zhiweianran/article/details/7919129" target="_blank" rel="noopener">这篇博文</a> 分析了其中一部分。</p>
<p>得益于已经学习过结构更为清晰的 MB，尽管 SB 源码复杂，但是读的时候不再会恐惧，因为简略的Debug 一遍就知道它底层还是调 getter/setter 的反射。再复杂的结构也离不开这最终的方法。</p>
<p>已目前对 SB 粗浅的了解来说，感受到最大的区别就是在工具箱中的<strong>结构地位不同</strong>。</p>
<p>MB 属于<code>BaseWrapper</code> 的子类之一，同级别的还有 MapWrapper ，上级还有 CollectionWrapper 。</p>
<p>而 SB 就已经是在创建 Bean 时直接使用到的接口了。</p>
<p>像<strong>解析嵌套参数名</strong> (比如 user.name  /  address.city.mailcode)，<strong>类型转换</strong>这些事情，SB 都能处理完。而 MB 都是先要使用其它工具类处理，比如依靠 PropertyTokenizer 。</p>
<p>总而言之，SB 就是对外的一个大接口，包含很多功能，MB 则是MyBatis 反射工具箱内的一个小的工具实现。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/01/18/createBean/">Spring源码笔记-2.5 createBean</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-01-18
        </span><span class="post-category">
            <a href="/categories/Spring%E7%AC%94%E8%AE%B0/">Spring笔记</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p>此方法交给了 <code>AbstractBeanFactory</code> 的子类 <code>AbstractAutowireCapableBeanFactory</code> 去实现。</p>
<p>并且不管这个bean是单例还是 prototype 还是其它 scope ,最终都是会走到此处，只是前后的一些验证、处理有区别。比如单例的就要先去缓存中获取，prototype 就不需要。</p>
<p>源码阅读到这里，我们已经习惯了一层一层剥。createBean 依然还是没有直接地把 bean 创建出来（当然我所期望的看到创建 bean 就是看到它的反射源码为止）。</p>
<p>createBean 的大致步骤为:</p>
<ol>
<li>根据 RootBeanDefinition 来获取要创建 bean 的 class 。这 class 还有可能为 null。</li>
<li>prepareMethodOverrides 。准备 override 方法，对 override 属性进行验证。</li>
<li>给后处理器一个机会来返回代理，替代真正的 bean.</li>
<li>doCreateBean 创建真正的 bean 实例。</li>
</ol>
<h3 id="prepareMethodOverrides"><a href="#prepareMethodOverrides" class="headerlink" title="prepareMethodOverrides"></a>prepareMethodOverrides</h3><p>首先去温习一遍 lookup-method 和 replace-method 吧。<a href="http://blog.csdn.net/qq_22912803/article/details/52503914" target="_blank" rel="noopener">博文</a> </p>
<p>其实就是通过配置把原本 bean 中的某个方法给替代掉。</p>
<p>此处我们先只是确认一遍指定的替代方法存在于要生成的 bean 中。</p>
<p>顺带看一看这个方法有没有重载overload)，做个标记。</p>
<h3 id="resolveBeforeInstantiation"><a href="#resolveBeforeInstantiation" class="headerlink" title="resolveBeforeInstantiation"></a>resolveBeforeInstantiation</h3><p>经过一波预处理器<code>InstantiationAwareBeanPostProcessor</code> ，如果生产出了 bean，再经过一波后处理器。</p>
<p>一旦生产出 bean，则立即将此 bean 返回。</p>
<p>此处就是留下了一个拓展点，经过此方法之后，bean可能已经不是我们认为的 bean 了，而可能已经变成了一个经过处理的代理 bean 。</p>
<h1 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h1><h4 id="构造器循环依赖"><a href="#构造器循环依赖" class="headerlink" title="构造器循环依赖"></a>构造器循环依赖</h4><p>如果是 prototype，无法解决，只能抛错。</p>
<p>代码在 <code>AbstractBeanFactory</code> : 256 <code>doGetBean()</code> 。</p>
<p>当创建 bean 时，首先去“当前创建 bean 池”查找是否当前 bean 正在创建，如果发现存在，则表示循环依赖了。抛出 BeanCurrentlyInCreationExcetion 。</p>
<p>当前创建 bean 池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Object&gt; prototypesCurrentlyInCreation =</span><br><span class="line">      <span class="keyword">new</span> NamedThreadLocal&lt;Object&gt;(<span class="string">"Prototype beans currently in creation"</span>);</span><br></pre></td></tr></table></figure>



<h4 id="setter-循环依赖"><a href="#setter-循环依赖" class="headerlink" title="setter 循环依赖"></a>setter 循环依赖</h4><p>只能解决单例的情况。</p>
<p>在创建单例 bean 时，提前暴露刚完成构造器但未完成其他步骤（如 setter 注入）的 bean 。</p>
<p>通过提前暴露这个单例工厂方法，从而使其他 bean 能够引用到此 bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">            <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   addSingletonFactory(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">//注意这里返回的是 早期引用</span></span><br><span class="line">         <span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(singletonFactory, <span class="string">"Singleton factory must not be null"</span>);</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">              <span class="comment">//单例工厂注册</span></span><br><span class="line">				<span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">              <span class="comment">//早期单例移出</span></span><br><span class="line">				<span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">              <span class="comment">//注册单例加入</span></span><br><span class="line">				<span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>简单地记一下这里解决步骤：</p>
<p>testA 先创建，并且暴露一个工厂出去，进行 setter 注入 testB.</p>
<p>testB 创建，并且暴露一个工厂，进行 setter 注入 testA.</p>
<p>在这里想用 testA 时，<strong>由于发现提前暴露的工厂，从而在此处走了另一条路</strong>，使用此工厂来创建 testA ,在此处解决了循环问题。</p>
<p>再返回回去继续完成 testA 的 setter 注入。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/01/04/TypeHandlerRegistry/">MyBatis 对未知数据类型的转换(二)TypeHandlerRegistry</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-01-04
        </span><span class="post-category">
            <a href="/categories/MyBatis%E7%AC%94%E8%AE%B0/">MyBatis笔记</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>上一篇我们讲到，对于未知数据类型的解析，UnknownTypeHandler 把部分任务交给了 TypeHandlerRegistry ,甚至可能仅仅只丢了一个 javaType 过来就要求返回一个合适的解析器回去 。TypeHandlerRegistry 到底里面做了啥可以找到合适的解析器呢？</p>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>从类的名字我们就知道这个类的功能大概就是个注册表，而且很可能是全局共用的，记录各种 javaType,jdbcType,TypeHandler 的映射关系。实际这个类的核心也就是维护了几个 map 。 </p>
<h1 id="核心字段"><a href="#核心字段" class="headerlink" title="核心字段"></a>核心字段</h1><h3 id="JDBC-TYPE-HANDLER-MAP"><a href="#JDBC-TYPE-HANDLER-MAP" class="headerlink" title="JDBC_TYPE_HANDLER_MAP"></a>JDBC_TYPE_HANDLER_MAP</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; JDBC_TYPE_HANDLER_MAP = <span class="keyword">new</span> EnumMap&lt;JdbcType, TypeHandler&lt;?&gt;&gt;(JdbcType<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>这个很直观，就是注册 jdbcType 和解析器的对应关系。</p>
<h3 id="TYPE-HANDLER-MAP"><a href="#TYPE-HANDLER-MAP" class="headerlink" title="TYPE_HANDLER_MAP"></a>TYPE_HANDLER_MAP</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt; TYPE_HANDLER_MAP = <span class="keyword">new</span> ConcurrentHashMap&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt;();</span><br></pre></td></tr></table></figure>

<p>书上原文是：“记录了 java 类型向指定的 JdbcType 转换时，需要使用的 TypeHandler 对象。例如：Java 类型中的 String 转换成数据库的 char 、varchar 等多种类型，所以存在一对多关系”。</p>
<p>Type 是 java.lang.reflect 包下的接口，Class 类实现了此接口。所以此 map 的 key 值是 javaType ,比如 String.class 。</p>
<h3 id="UNKNOWN-TYPE-HANDLER"><a href="#UNKNOWN-TYPE-HANDLER" class="headerlink" title="UNKNOWN_TYPE_HANDLER"></a>UNKNOWN_TYPE_HANDLER</h3><p>就是上一篇文章学习过的 UnknownTypeHandler 的实例，主要用在 Object.class 和 JdbcType.OTHER 上。</p>
<h3 id="ALL-TYPE-HANDLERS-MAP"><a href="#ALL-TYPE-HANDLERS-MAP" class="headerlink" title="ALL_TYPE_HANDLERS_MAP"></a>ALL_TYPE_HANDLERS_MAP</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt; ALL_TYPE_HANDLERS_MAP = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure>

<p>key 是解析器的 class ,value 是解析器自身。</p>
<p>记录了全部的解析器的类型及该类型相对应的 TypeHandler 对象。</p>
<h3 id="NULL-TYPE-HANDLER-MAP"><a href="#NULL-TYPE-HANDLER-MAP" class="headerlink" title="NULL_TYPE_HANDLER_MAP"></a>NULL_TYPE_HANDLER_MAP</h3><p>仅仅是一个空 TypeHandler 集合的标识。因为 TYPE_HANDLER_MAP 是ConcurrentHashMap, 不能塞 null 值，因此在需要的地方以此空标识作为 value 替代null塞入。</p>
<h1 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h1><p>在构造方法中，就调用了大量的 register(…) 的方法，注册了很多映射关系。</p>
<p>register 有很多重载方法，除了简单的向 JDBC_TYPE_HANDLER_MAP 注册之外，全都最终指向了下面的重载方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Type javaType, JdbcType jdbcType, TypeHandler&lt;?&gt; handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (javaType != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; map = TYPE_HANDLER_MAP.get(javaType);</span><br><span class="line">    <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">      map = <span class="keyword">new</span> HashMap&lt;JdbcType, TypeHandler&lt;?&gt;&gt;();</span><br><span class="line">      TYPE_HANDLER_MAP.put(javaType, map);</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(jdbcType, handler);</span><br><span class="line">  &#125;</span><br><span class="line">  ALL_TYPE_HANDLERS_MAP.put(handler.getClass(), handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法并不复杂，我们只需要理解的是这里为两个 map 中都塞入了值，一个是 key 为 javaType 的 map , 也就是 String 与 char/varchar 的一对多的关系。另一个则是记录全部 handler 的map。</p>
<p>这里有一点需要特别留意的就是，比如 String 类，除了映射  char/varchar 之外，还<strong>映射 null</strong> ，对应的解析器也是 StringTypeHandler 。</p>
<p><img src="http://ots7yt7am.bkt.clouddn.com/blog/registerString.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这一行就是javaType为String.class jdbcType 为null 的解析器注册</span></span><br><span class="line">register(String<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">StringTypeHandler</span>())</span>;</span><br><span class="line"><span class="comment">//这是普通的注册</span></span><br><span class="line">register(String<span class="class">.<span class="keyword">class</span>, <span class="title">JdbcType</span>.<span class="title">CHAR</span>, <span class="title">new</span> <span class="title">StringTypeHandler</span>())</span>;</span><br></pre></td></tr></table></figure>

<h1 id="查找-TypeHandler"><a href="#查找-TypeHandler" class="headerlink" title="查找 TypeHandler"></a>查找 TypeHandler</h1><p>终于到了查找 TypeHandler 的部分了，看了这么久，是不是差点晕得都忘了我们的这个注册表最核心的功能在这呢？</p>
<p>根据 jdbcType 和 typeHandler 的class 查找解析器的功能都很简单，就是上面的 JDBC_TYPE_HANDLER_MAP 和 ALL_TYPE_HANDLERS_MAP 中取值。</p>
<p>关键的在于根据 javaType 寻找解析器。而且我们的在上一篇也讲到了 PreparedStatement 在赋值的时候，我们没有提供 jdbcType ( null ), 仅仅只有 javaType 。</p>
<p> getTypeHandler 其实就是从 TYPE_HANDLER_MAP 取值.我们入参类型为 String 为例来看看其查找解析器的过程 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">TypeHandler&lt;T&gt; <span class="title">getTypeHandler</span><span class="params">(Type type, JdbcType jdbcType)</span> </span>&#123;</span><br><span class="line"><span class="comment">//首先根据 String.class 查找其一对多的解析器集合.</span></span><br><span class="line">  Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; jdbcHandlerMap = getJdbcHandlerMap(type);</span><br><span class="line">  TypeHandler&lt;?&gt; handler = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (jdbcHandlerMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="comment">//然后根据其指定的 jdbcType 来找对应的解析器。而此处我们的 jdbcType 是null</span></span><br><span class="line">  <span class="comment">//但是在注册的时候我们留意过，对于 null ,同样也进行了注册</span></span><br><span class="line">  <span class="comment">//就相当于是给了个默认的解析器</span></span><br><span class="line">    handler = jdbcHandlerMap.get(jdbcType);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">      handler = jdbcHandlerMap.get(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">      handler = pickSoleHandler(jdbcHandlerMap);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (TypeHandler&lt;T&gt;) handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>目前我们已经接触过了两种方式对明确指明的 javaType 的转换。主要可以分为两大类：</p>
<h3 id="ObjectTypeHandler"><a href="#ObjectTypeHandler" class="headerlink" title="ObjectTypeHandler"></a>ObjectTypeHandler</h3><p>这个主要依靠 JDBC 底层的方法来查找合适的 javaType ，大量的 switch-case 语句。主要用在将返回值的封装到 JSONObject 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (field.getSQLType()) &#123;</span><br><span class="line"><span class="keyword">case</span> Types.TINYINT:</span><br><span class="line">    <span class="keyword">if</span> (!field.isUnsigned()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(getByte(columnIndex));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Integer.valueOf(getInt(columnIndex));</span><br><span class="line"><span class="keyword">case</span> Types.SMALLINT:</span><br><span class="line">    <span class="keyword">return</span> Integer.valueOf(getInt(columnIndex));</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TypeHandlerRegistry"><a href="#TypeHandlerRegistry" class="headerlink" title="TypeHandlerRegistry"></a>TypeHandlerRegistry</h3><p>注册表功能，将常规的数十种关系映射在初始化时就都注册好，也就是提前存入 map 中，需要的时候去 map 中取。</p>
<p>尤其是将 javaType 和 TypeHandler 关联起来，并对一些类型注册了默认的解析器，即 jdbcType 未指明时所要采用的解析器。</p>
<p>这个更多是用在 PreparedStatement  入参的赋值时。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/01/02/TypeHandler/">MyBatis 对未知数据类型的转换(一)TypeHandler</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-01-02
        </span><span class="post-category">
            <a href="/categories/MyBatis%E7%AC%94%E8%AE%B0/">MyBatis笔记</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>前面说到，我们可以用 JSONObject 替代习惯使用的 JavaBean ，而之所以能用 JSONObject 主要就是因为它实现了 <code>Map&lt;String,Object&gt;</code>  。</p>
<p>实际使用我们就会发现，MyBatis 使用JSONObject 封装返回结果的时候很“智能”，数据库里字段是 varchar 类型，JSONObject 中返回值就是 String 类型，数据库字段是 int/float 类型，JSONObject 中返回值就是对应的数值类型。甚至通过 debug 发现数据库中保存了datetime 类型的数据，JSONObject 中保存的是 <code>java.sql.timestamp</code> 类型，而<code>timestamp</code> 类型继承了常见的 <code>java.util.Date</code> 。</p>
<p><img src="http://img.heeexy.com/DataType.png" alt=""></p>
<p>为什么 MyBatis 可以用得这么爽呢？我们实现可完全没声明需要此字段的 javaType 呢。而且用得爽了，类型转换会不会导致程序性能大打折扣呢？</p>
<p>今天我们就从深入源码，探究一番 MyBatis 到底是怎样做到对未明确声明的字段处理返回类型的。</p>
<h1 id="TypeHandler"><a href="#TypeHandler" class="headerlink" title="TypeHandler"></a>TypeHandler</h1><p>MyBatis 类型转换的核心就是这个接口，定义的方法可以看做就两种 setParameter 和 getResult ,很好理解，我们传参和接收 sql 结果时就调用这个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, T parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">getResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">getResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">getResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类 BaseTypeHandler 部分实现了 TypeHandler ,主要完成了对空值的处理。 非空值的处理全部交给了子类完成。</p>
<p>BaseTypeHandler 子类非常多，对应了数据库的各种数据类型，实现都很简单，比如<code>SqlTimestampTypeHandler</code> 处理 Timestamp 类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, Timestamp parameter, JdbcType jdbcType)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ps.setTimestamp(i, parameter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Timestamp <span class="title">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> rs.getTimestamp(columnName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>都是直接调用了 PreparedStatement 和 ResultSet 处理相应类型字段的方法。</p>
<p>很明显，一旦指明了我们需要 MyBatis 给我们返回的此字段类型，MyBatis 肯定就去找到对应的 TypeHandler 实现类去处理。而我们没有指定返回类型的是怎么处理的呢？或者说，对于 Object 类型是怎么处理的呢？</p>
<h1 id="ObjectTypeHandler"><a href="#ObjectTypeHandler" class="headerlink" title="ObjectTypeHandler"></a>ObjectTypeHandler</h1><p>我们先来看看这个类，看名字就会猜可能估计未知类型全靠它了吧。提前预告下，并不是哦，getNullableResult 还算经常使用，入参赋值就没见用了，毕竟入参的 JavaType 我们通过反射还是可以找到的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, Object parameter, JdbcType jdbcType)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ps.setObject(i, parameter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> rs.getObject(columnName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一看这实现，居然还是调用的 JDBC 底层的对应方法。事实上 <code>com.mysql.jdbc</code> 在处理<code>Object</code> 类型是也是通过大量的 if-else 或 switch-case 来找到本数据真正的类型的。入参绑定依据 parameterObj instanceof 各种类型，返回结果类型依据 field.getSQLType 的各种类型。</p>
<h1 id="UnknownTypeHandler"><a href="#UnknownTypeHandler" class="headerlink" title="UnknownTypeHandler"></a>UnknownTypeHandler</h1><p>事实上，MyBatis 在很多我们没有指明参数类型的情况下，都是使用 UnknownTypeHandler 来解决类型转换的。UnknownTypeHandler 中的核心<code>resolveTypeHandler</code> 方法，就是查找对应数据的类型解析器（TypeHandler) ， 再用这个合适的 typeHandler 进行解析。</p>
<p><code>resolveTypeHandler</code> 方法的重载有3种，主要的两种就是一种处理入参的，一种处理返回结果的。</p>
<h3 id="入参类型解析"><a href="#入参类型解析" class="headerlink" title="入参类型解析"></a>入参类型解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> TypeHandler&lt;? extends Object&gt; resolveTypeHandler(Object parameter, JdbcType jdbcType) &#123;</span><br><span class="line">  TypeHandler&lt;? extends Object&gt; handler;</span><br><span class="line">  <span class="keyword">if</span> (parameter == <span class="keyword">null</span>) &#123;</span><br><span class="line">    handler = OBJECT_TYPE_HANDLER;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    handler = typeHandlerRegistry.getTypeHandler(parameter.getClass(), jdbcType);</span><br><span class="line">    <span class="comment">// check if handler is null (issue #270)</span></span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span> || handler <span class="keyword">instanceof</span> UnknownTypeHandler) &#123;</span><br><span class="line">      handler = OBJECT_TYPE_HANDLER;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在入参为 null 或者实在找不到解析器的情况下，就会返回我们上面讲的 ObjectTypeHandler 。</p>
<p>而这里面关键的方法就是</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeHandlerRegistry.getTypeHandler(parameter.getClass(), jdbcType);</span><br></pre></td></tr></table></figure>

<p>typeHandlerRegistry 可以理解为全局共用的各种类型与解析器关系的注册表，后面的文章还会继续深入讲解，我们首先注意这个方法的入参，第一个参数拿到了参数的 class , 第二个参数拿到了 jdbcType 。这不就相当于javaType 和 jdbcType 都有了吗？那即使还没研究 typeHandlerRegistry 到底干了啥，但是条件给的这么充分了，注册表的任务也太轻松了吧！</p>
<p>等等，我们的 DAO 层给入参是 JSONObject 类型,里面 username 字段是 String 类型，money 字段是 float 类型，这些都能通过 getClass() 获取到确实没毛病。但是 jdbcType 是哪来的呢？我们现在可是在处理 PreparedStatement 呢！</p>
<p>通过 debug 我们发现，这里的 jdbcType 我们没有指明的情况下，确实都是 null 。说明 typeHandlerRegistry 里仅仅是通过 javaType 来寻找解析器的。所以 typeHandlerRegistry  还是有很多门道等着我们去探索哦。</p>
<h3 id="返回结果类型解析"><a href="#返回结果类型解析" class="headerlink" title="返回结果类型解析"></a>返回结果类型解析</h3><p>对 ResultSet 的解析有两种方式，首先查看此结果字段–比如nickname–在 field 中的序号，如果没序号，则直接返回 ObjectTypeHandler 。如果有序号，则进入下面的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> TypeHandler&lt;?&gt; resolveTypeHandler(ResultSetMetaData rsmd, Integer columnIndex) <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  TypeHandler&lt;?&gt; handler = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">//通过下面两个方法获取到jdbcType和javaType</span></span><br><span class="line">  JdbcType jdbcType = safeGetJdbcTypeForColumn(rsmd, columnIndex);</span><br><span class="line">  Class&lt;?&gt; javaType = safeGetClassForColumn(rsmd, columnIndex);</span><br><span class="line">  <span class="comment">//后面的任务就还是交给了typeHandlerRegistry</span></span><br><span class="line">  <span class="keyword">if</span> (javaType != <span class="keyword">null</span> &amp;&amp; jdbcType != <span class="keyword">null</span>) &#123;</span><br><span class="line">    handler = typeHandlerRegistry.getTypeHandler(javaType, jdbcType);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (javaType != <span class="keyword">null</span>) &#123;</span><br><span class="line">    handler = typeHandlerRegistry.getTypeHandler(javaType);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (jdbcType != <span class="keyword">null</span>) &#123;</span><br><span class="line">    handler = typeHandlerRegistry.getTypeHandler(jdbcType);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的关键方法还是从 rsmd 中获取 jdbcType 和 javaType ，然后再通过 typeHandlerRegistry 去查找对应的 handler 。</p>
<p>debug 发现几乎每次从 rsmd 中获取 jdbcType 和 javaType 都获取到了，看来玄机都在<code>safeGetJdbcTypeForColumn</code> 和 <code>safeGetClassForColumn</code> 中了。</p>
<p>两个方法的关键代码分别如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> JdbcType.forCode(rsmd.getColumnType(columnIndex));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Resources.classForName(rsmd.getColumnClassName(columnIndex));</span><br></pre></td></tr></table></figure>

<h4 id="JdbcType"><a href="#JdbcType" class="headerlink" title="JdbcType"></a>JdbcType</h4><p><code>com.mysql.jdbc.ResultSetMetaData</code>  实现了 <code>java.sql.ResultSetMetaData</code> 接口，此处我们调用了其中的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getColumnType</span><span class="params">(<span class="keyword">int</span> column)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getField(column).getSQLType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>序号的作用就体现出来了，根据序号找到此 field ,再找其 SQLType ，根据 SQLType 去JdbcType 类 (enum类型) 内查找对应的 jdbcType。</p>
<p>JdbcType 类内维护了一个 map 类型静态变量 codeLookup ，类加载时为 codeLookup 添加了39个元素，key 值其实就是 SQLType ， int 类型，value 就是本 jdbcType 。</p>
<p>因此根据 SQLType 在此处就直接能毫不费力地找出对应的 jdbcType。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (JdbcType type : JdbcType.values()) &#123;</span><br><span class="line">    codeLookup.put(type.TYPE_CODE, type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="javaType"><a href="#javaType" class="headerlink" title="javaType"></a>javaType</h4><p>同样需要先找到 SQLType ，以及field 内的另外几个属性值，例如 isUnsigned 等一起进入 getClassNameForJavaType 方法找到对应类名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">getClassNameForJavaType</span><span class="params">(<span class="keyword">int</span> javaType, <span class="keyword">boolean</span> isUnsigned, <span class="keyword">int</span> mysqlTypeIfKnown, <span class="keyword">boolean</span> isBinaryOrBlob, <span class="keyword">boolean</span> isOpaqueBinary,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> treatYearAsDate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (javaType) &#123;</span><br><span class="line">        <span class="keyword">case</span> Types.BIT:</span><br><span class="line">        <span class="keyword">case</span> Types.BOOLEAN:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"java.lang.Boolean"</span>;</span><br><span class="line">        <span class="keyword">case</span> Types.TINYINT:</span><br><span class="line">            <span class="keyword">if</span> (isUnsigned) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"java.lang.Integer"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"java.lang.Integer"</span>;</span><br><span class="line">        <span class="comment">//......大量 case</span></span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"java.lang.Object"</span>;</span><br></pre></td></tr></table></figure>

<p>而这里的大量的 swtich-case 终于算是解除了我们一部分的疑惑了！底层终归还是通过 swtich-case 这种最原始的操作来把 jdbcType 映射到 java 类里去的！</p>
<h4 id="奇怪的现象"><a href="#奇怪的现象" class="headerlink" title="奇怪的现象"></a>奇怪的现象</h4><p>上面说到，如果没序号，则直接返回 ObjectTypeHandler。</p>
<p>序号是<code>getColumnType(int column)</code> 用于找到到对应的 field 的关键属性。</p>
<p>那么为什么有可能会没有序号呢？</p>
<p><img src="http://img.heeexy.com/debug-fields.png" alt=""></p>
<p>通过 debug 我们发现，明明 fields 内有 8 个元素，每个字段的原始名和别名都清清楚楚，到 columnIndexLookup 里居然只剩下 6 个？ 很显然，问题出在了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name = rsmd.getColumnName(i);</span><br></pre></td></tr></table></figure>

<p>中间有几次取出了重复的 name 。为什么会有重复的 name 呢，我们进入<code>getColumnName</code> 一探究竟。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getColumnName</span><span class="params">(<span class="keyword">int</span> column)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.useOldAliasBehavior) &#123;</span><br><span class="line">      <span class="comment">//如果设置了使用别名的属性，就获取此field的别名。</span></span><br><span class="line">        <span class="keyword">return</span> getField(column).getName();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//获取此field的name属性，而不是别名。</span></span><br><span class="line">    String name = getField(column).getNameNoAliases();</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="keyword">null</span> &amp;&amp; name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//如果连原始字段名都找不到，就还是获取别名</span></span><br><span class="line">        <span class="keyword">return</span> getField(column).getName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际debug发现，我们每次都是通过 getNameNoAliases 找到 name 的。再底层的代码就不需要贴了，看到这里我们就明白了。这里的 name 其实是每个字段的数据库内的字段名，而不是我们定义的别名，所以才会出现重复的情况，比如 user 表有 id 字段，address 表同样会有 id 字段。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天我们分析完了类型转换器，发现对于未知的数据类型，有一部分是通过ObjectTypeHandler 解析，其底层的用了<code>com.mysql.jdbc.ResultSetImpl.getObject</code> 内的依据 Field.SQLType 的 swtich-case 。</p>
<p>另一部分则是通过<code>UnknownTypeHandler</code> 去查找合适的解析器来解析。  </p>
<p>关于查找解析器的步骤，我们将进入下一层级<code>TypeHandlerRegistry</code>  来继续学习。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2017/12/31/One2Many/">MyBatis 中使用 JSONObject 处理一对多结果</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-12-31
        </span><span class="post-category">
            <a href="/categories/MyBatis%E7%AC%94%E8%AE%B0/">MyBatis笔记</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在<a href="/2017/12/30/JSONObject-in-MyBatis/">上一文</a>介绍了 JSONObject 接受 MyBatis 的结果集的简单用法，但是在处理一对多的情况时，单纯的JSONObject就不好使了。</p>
<p>比如要查询一个角色下的多个用户，resultMap如下定义</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"roleMap"</span> <span class="attr">type</span>=<span class="string">"com.alibaba.fastjson.JSONObject"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"roleId"</span> <span class="attr">property</span>=<span class="string">"roleId"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"roleName"</span> <span class="attr">property</span>=<span class="string">"roleName"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"users"</span> <span class="attr">ofType</span>=<span class="string">"com.alibaba.fastjson.JSONObject"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"userId"</span> <span class="attr">property</span>=<span class="string">"userId"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"nickname"</span> <span class="attr">property</span>=<span class="string">"nickname"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>期望查出来的<code>users</code> 属性对应着一个数组,</p>
<p><img src="http://img.heeexy.com/rightJson.png" alt=""></p>
<p>然而实际查出来只是一个对象，只有一条数据。</p>
<p><img src="http://img.heeexy.com/wrongJson.png" alt=""></p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>只需要建一个实体类继承 JSONObject ,里面有你要的集合类型的成员变量，就足够了。</p>
<p>比如我建的 One2Many 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">One2Many</span> <span class="keyword">extends</span> <span class="title">JSONObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;JSONObject&gt; users;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后xml改为</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"roleMap"</span> <span class="attr">type</span>=<span class="string">"com.heeexy.example.util.model.One2Many"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"roleId"</span> <span class="attr">property</span>=<span class="string">"roleId"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"roleName"</span> <span class="attr">property</span>=<span class="string">"roleName"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"users"</span> <span class="attr">ofType</span>=<span class="string">"com.alibaba.fastjson.JSONObject"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"userId"</span> <span class="attr">property</span>=<span class="string">"userId"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"nickname"</span> <span class="attr">property</span>=<span class="string">"nickname"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>是不是非常简单？</p>
<p>更棒的是，这个 One2Many 类是可以复用的，里面再添加其它的成员变量就 OK 了。而且 Dao 层不需要改动，外面正常的还是用 JSONObject 就可以了。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>MyBatis 在处理嵌套结果的时候，会判断这个属性的类型，如果是集合，就会初始化一个集合来接收这个属性，否则就只是一个普通的 Object 了。</p>
<p>什么，不满意这个答案？那就拿出源码来吧！</p>
<p>首先我们直接看到最底层判断这个属性是不是集合的这段源码：</p>
<p>DefaultResultSetHandler.instantiateCollectionPropertyIfAppropriate</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">instantiateCollectionPropertyIfAppropriate</span><span class="params">(ResultMapping resultMapping, MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> String propertyName = resultMapping.getProperty();</span><br><span class="line">  <span class="comment">//先去拿在metaObject已经存好的这个属性值，我们这里以users属性为例</span></span><br><span class="line">  Object propertyValue = metaObject.getValue(propertyName);</span><br><span class="line">  <span class="keyword">if</span> (propertyValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//在这里拿你的users的java类型，由于我们使用的是JSONObject,这里的类型都会返回Object，如果是One2Many,这里就会拿到List类型</span></span><br><span class="line">    Class&lt;?&gt; type = resultMapping.getJavaType();</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="keyword">null</span>) &#123;</span><br><span class="line">      type = metaObject.getSetterType(propertyName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//判断属性类型是不是集合，如果是结合才会初始化一个集合的值返回到下一步，否则都会返回null</span></span><br><span class="line">      <span class="keyword">if</span> (objectFactory.isCollection(type)) &#123;</span><br><span class="line">        propertyValue = objectFactory.create(type);</span><br><span class="line">        metaObject.setValue(propertyName, propertyValue);</span><br><span class="line">        <span class="keyword">return</span> propertyValue;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Error instantiating collection property for result '"</span> + resultMapping.getProperty() + <span class="string">"'.  Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (objectFactory.isCollection(propertyValue.getClass())) &#123;</span><br><span class="line">    <span class="comment">//propertyValue不为空的情况，即我们的JSONObject里已经塞入了users属性，即使是这样，MyBatis还是要求你塞入的users属性必须是集合，才返回到下一步，否则还是会返回null到下一步。</span></span><br><span class="line">    <span class="keyword">return</span> propertyValue;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面这段代码我们就知道 MyBatis 确实有做这个判断，你定义的 users 属性到底是不是集合类型，</p>
<ol>
<li>如果是并且没有初始化好的话，就帮你初始化一个集合到下一步，</li>
<li>如果已经初始化好了（通常这时候就是已经塞入了几个 user 对象了），就直接返回这个 users 的值到下一步</li>
<li>如果不是集合类型，就返回 null 到下一步。</li>
</ol>
<p>那么下一步到底是干啥呢？正常情况下应该就是继续往 users 集合里添加元素吧。</p>
<p> DefaultResultSetHandler.linkObjects</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkObjects</span><span class="params">(MetaObject metaObject, ResultMapping resultMapping, Object rowValue)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Object collectionProperty = instantiateCollectionPropertyIfAppropriate(resultMapping, metaObject);</span><br><span class="line">  <span class="keyword">if</span> (collectionProperty != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//如果上一步返回来的不是null,那就向这个集合里添加元素</span></span><br><span class="line">    <span class="keyword">final</span> MetaObject targetMetaObject = configuration.newMetaObject(collectionProperty);</span><br><span class="line">    targetMetaObject.add(rowValue);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//上一步返回了null,那就直接把这个属性赋上本值，就是这种情况导致了上面的第二张图片的情况，我们的users变成了一个对象，而不是想要的数组。</span></span><br><span class="line">    metaObject.setValue(resultMapping.getProperty(), rowValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2017/12/30/JSONObject-in-MyBatis/">MyBatis 中使用 JSONObject 替代 JavaBean</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-12-30
        </span><span class="post-category">
            <a href="/categories/MyBatis%E7%AC%94%E8%AE%B0/">MyBatis笔记</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>项目后端与前端全部使用 JSON 进行数据交互，比如查询用户列表，通常后端从数据库查出的数据放入实体类再转为 JSON 返回给前端，但是前端的小伙伴表示明明只需要 nickname,avatar,userId 三个字段，为什么传过来的数据多出 phone,address ,profile 之类十几个字段，里面都 null,0 等值？</p>
<p>其实是因为 User 实体类定义了太多字段，转为 JSON 的时候都被包括进去了。稍微多几个还能忍，但通常 User/Order 这些实体类字段特别多，对调试开发实在非常不友好。</p>
<p>因此本次任务就是：确保每个接口返回字段都与接口文档上一模一样，去除冗余字段。</p>
<p>解决过程就省略了，直接抛出我最后的解决方案吧：就是 MyBatis 的返回值几乎完全抛弃实体类，全部使用<code>com.alibaba.fastjson.JSONObject</code> 。</p>
<h1 id="使用-JSONObject"><a href="#使用-JSONObject" class="headerlink" title="使用 JSONObject"></a>使用 JSONObject</h1><p>先最简化直观的看一下 JSONObject 的使用吧。</p>
<p>Controller:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/list"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> JSONObject <span class="title">listUser</span><span class="params">(@RequestBody JSONObject requestJson)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.listUser(requestJson);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Service:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JSONObject <span class="title">listUser</span><span class="params">(JSONObject jsonObject)</span></span>;</span><br></pre></td></tr></table></figure>

<p>ServiceImpl:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JSONObject <span class="title">listUser</span><span class="params">(JSONObject jsonObject)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//fillPageParam是自定义的封装分页参数</span></span><br><span class="line">    CommonUtil.fillPageParam(jsonObject);</span><br><span class="line">    <span class="keyword">int</span> count = userDao.countUser(jsonObject);</span><br><span class="line">    List&lt;JSONObject&gt; list = userDao.listUser(jsonObject);</span><br><span class="line">    <span class="comment">//自定义successPage封装分页结果</span></span><br><span class="line">    <span class="keyword">return</span> CommonUtil.successPage(jsonObject, list, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dao:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countUser</span><span class="params">(JSONObject jsonObject)</span></span>;</span><br><span class="line">    <span class="function">List&lt;JSONObject&gt; <span class="title">listUser</span><span class="params">(JSONObject jsonObject)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserMapper.xml , 这里的 resultType 直接就是 JSONObject ,如果是一对多的情况，就要多加一步，请移步看<a href="/2017/12/31/One2Many">这篇文章</a>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"countUser"</span> <span class="attr">resultType</span>=<span class="string">"Integer"</span>&gt;</span></span><br><span class="line">    SELECT count(0)</span><br><span class="line">    FROM sys_user u</span><br><span class="line">  	WHERE age=#&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"users"</span> <span class="attr">resultType</span>=<span class="string">"com.alibaba.fastjson.JSONObject"</span>&gt;</span></span><br><span class="line">     SELECT</span><br><span class="line">   		id  		userId,</span><br><span class="line">   		nickname     	nickname,</span><br><span class="line">   		avatar       	avatar</span><br><span class="line">     FROM sys_user</span><br><span class="line">  	 WHERE age=#&#123;age&#125;</span><br><span class="line">     LIMIT #&#123;offSet&#125;, #&#123;pageRow&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="为什么可以使用JSONObject"><a href="#为什么可以使用JSONObject" class="headerlink" title="为什么可以使用JSONObject"></a>为什么可以使用JSONObject</h1><p>因为 JSONObject 实现了 <code>Map&lt;String,Object&gt;</code> , MyBatis 那边完全是把它当成 <code>Map&lt;String,Object&gt;</code>  处理的，相信不少人都直接用过 map 来接收MyBatis 返回结果。</p>
<blockquote>
<p> fastjson 是这样的，Gson 并不是，所以 Gson 的 JsonObject 是不可以的。</p>
</blockquote>
<p>有兴趣了解更深入的原理的话，请参考我此系列的其它文章。</p>
<h1 id="优劣对比"><a href="#优劣对比" class="headerlink" title="优劣对比"></a>优劣对比</h1><h4 id="便捷性"><a href="#便捷性" class="headerlink" title="便捷性"></a>便捷性</h4><p>JSONObject 便捷到可以说是无脑，接收参数、 sql 传参、封装 sql 结果、返回到前端，全程使用。</p>
<p>JavaBean 则接口层接收参数转为实体类，返回给前端再转为 json，新增一个业务通常还需要多建一个实体类。</p>
<h4 id="工具方法拓展"><a href="#工具方法拓展" class="headerlink" title="工具方法拓展"></a>工具方法拓展</h4><p>JSONObject 可以方便地封装出通用的工具方法，比如封装分页信息，比如封装处理结果的成功和失败信息，特别是校验参数字段非空，不同的接口通常需要校验的字段不同，如下面这个简单的方法就可以校验各字段是否都非空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hasAllRequired</span><span class="params">(<span class="keyword">final</span> JSONObject jsonObject, String requiredColumns)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!StringTools.isNullOrEmpty(requiredColumns)) &#123;</span><br><span class="line">        String[] columns = requiredColumns.split(<span class="string">","</span>);</span><br><span class="line">        String missCol = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (String column : columns) &#123;</span><br><span class="line">            Object val = jsonObject.get(column.trim());</span><br><span class="line">            <span class="keyword">if</span> (StringTools.isNullOrEmpty(val)) &#123;</span><br><span class="line">                missCol += column + <span class="string">"  "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!StringTools.isNullOrEmpty(missCol)) &#123;</span><br><span class="line">            jsonObject.clear();</span><br><span class="line">            jsonObject.put(<span class="string">"returnCode"</span>, ErrorEnum.E_90003.getErrorCode());</span><br><span class="line">            jsonObject.put(<span class="string">"returnMsg"</span>, <span class="string">"缺少必填参数:"</span> + missCol.trim());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CommonJsonException(jsonObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JavaBean 在处理分页上通常要引各自写的 PageBean 工具类 , 使用过程通常不会比上面ServiceImpl里的分页简单。</p>
<p>JavaBean 的参数校验都不用说，更头痛更复杂了，不知道有没有人有用起来很爽的方法。</p>
<h4 id="返回字段"><a href="#返回字段" class="headerlink" title="返回字段"></a>返回字段</h4><p>JSONObject 想返回几个字段就几个字段，而 JavaBean 如果只想返回某几个字段的话，就需要单独建个实体类。</p>
<p>字段有改动的话，JSONObject 灵活性就更强了，直接在 mapper.xml 里改下就完事。</p>
<h4 id="业务层"><a href="#业务层" class="headerlink" title="业务层"></a>业务层</h4><p>不可否认的是，JSONObject 在业务层进行处理时，失去了 JavaBean 的编译提示，也失去了 IDE 的快捷补全，更有可能出现取错值的情况。</p>
<p>比如 jsonObject.getString(“pasword”) ,输入错了单词都可能没注意，最终取出来 null 。</p>
<h4 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h4><p>通常大家可能认为 JavaBean 有更好的可读性，我觉得只要变量名取得好，JSONObject 也是没有什么问题的。毕竟类名是固定死的，变量名和参数名才能更好地反映此处业务的处理。</p>
<p>尤其是如今前后端分离的项目，前后端开发人员一般对照着文档确认字段含义。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JSONObject 开发非常方便，具有更强的灵活性，适用于中小型项目，简单业务的开发，也适用于<strong>文档至上</strong>的前后端分离开发与微服务项目。</p>
<p>更具体的用法，可以参考 <a href="https://github.com/Heeexy/SpringBoot-Shiro-Vue" target="_blank" rel="noopener">Github 项目</a>。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2017/12/14/mybatis_design_patterns/">MyBatis 的日志设计--适配器模式 & 工厂模式</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-12-14
        </span><span class="post-category">
            <a href="/categories/MyBatis%E7%AC%94%E8%AE%B0/">MyBatis笔记</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p>​    MyBatis 想要打印日志，时不时想要来句 log.debug() 、log.error() ，需要个打印机 ，可是自己又不想去实现（而且跟着整个项目用同样的打印系统才是王道啊），需要去用别人家的打印机，要用别人家的产品啊，那问题可就来了。</p>
<h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题 1"></a>问题 1</h2><p>​    市面上各家的打印机 slf4j、java.util.logging、log4j 甚至 System.out 都是各种不同的用法，这使用起来就太麻烦了。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>​    不管市面上打印机有多少型号，我家 MyBatis 包里的类只用自家的统一接口，我家的类只管 log.debug()、log.error()…</p>
<p>​    定义好了接口，就需要实现类 impl 来实现这些 debug()、error() 方法了 , 咱假装是自己来实现，其实去调用真正打印机 slf4、log4j 的方法，这样就把别人家的打印机和咱自家的接口关联起来啦。</p>
<p>​    这就是<strong>适配器模式</strong>。</p>
<p>​    我家的每个实现类其实就是一个适配器，每个适配器去适配一种打印机。比如 slf4jLoggerImpl 就完成了对 slf4j 打印机的适配，slf4jLoggerImpl .debug() 调用了slf4j.Logger.debug()。</p>
<p>​    这样市面上每多一种打印机，比如想用 log4j2 了，我就只需要加一种适配器 log4j2LoggerImpl 去适配它就可以了。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>​    定义接口 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(String s)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在实现类里完成适配，比如适配 slf4j 的 <code>Slf4jLoggerImpl</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.ibatis.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slf4jLoggerImpl</span> <span class="keyword">implements</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Logger log;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//注意这个地方，入参为 org.slf4j.Logger </span></span><br><span class="line">  <span class="comment">//说明咱这个适配器要用起来，是需要传入一个真正的 slf4j 家的打印机进来的</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Slf4jLoggerImpl</span><span class="params">(Logger logger)</span> </span>&#123;</span><br><span class="line">    log = logger;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//看似外面调用咱 MyBatis 的 Log 的 debug()</span></span><br><span class="line">  <span class="comment">//其实是调用 org.slf4j.Logger 的 debug() </span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.debug(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="问题-2"><a href="#问题-2" class="headerlink" title="问题 2"></a>问题 2</h2><p>​    适配器咱是做好了，slf4j、log4j、stdout…做了那么多适配器，可是怎么用啊？我真正要打印机的时候，怎么才能知道我该调用哪款适配器啊？难道每次取打印机的时候，都去查一遍咱的系统配了那款打印机（jar) 包么？而且以后多加了1种打印机，我还去每个地方都改一遍，都多加一道判断么？</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>​    这其实就是获取实例的时候的问题，咱获取实例太累了，不如来个统一的工厂吧，我每次想打印的时候，都去找工厂要一台打印机，你工厂按照我 Log 的接口给我一个实例就是了。我也不管你给的具体实现到底是 slf4j 家的，还是 log4j 的，甚至可能是 <code>NoLoggingImpl</code> 每次调接口都不处理的这种空壳打印机。</p>
<p>​    这样一来，有了统一的工厂，判断系统用哪种适配器的任务就可以在工厂完成了。</p>
<p>​    而且以后就算新加了打印机，也只要改改工厂的代码，在工厂里多加一重判断就可以了。</p>
<p>​    这就是<strong>工厂模式</strong>。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>​    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LogFactory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;? extends Log&gt; logConstructor;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    tryImplementation(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        useSlf4jLogging();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    tryImplementation(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        useCommonsLogging();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">LogFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// disable construction</span></span><br><span class="line">  &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Log <span class="title">getLog</span><span class="params">(String logger)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> logConstructor.newInstance(logger);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    LogFactory 提供了对外的 getLog(String logger) 方法，给需要 logger 的地方提供一个 Log 的实例。</p>
<p>​    内部的实现依靠 <code>logConstructor</code>  这个构造器通过反射来实例化一个 Log 的 Impl ，也就是之前的适配器，比如 Slf4jLoggerImpl 。</p>
<p>​    判断采用哪种<code>logConstructor</code> 的任务则在类初始化的时候就执行了，依次尝试了我们的每一款适配器，碰上报错就说明没 jar 包，下一款，全都没有的话，就用 NoLoggingImpl 了。</p>

        </div></article>
      <nav class="pagination"><a class="next" href="/page/2/">
        <span class="next-text">下一页</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></section></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:heeexy@gmail.com" class="iconfont icon-email" title="email"></a>
        <a href="https://github.com/Heeexy" target="_blank" rel="noopener" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">Even</a>
  </span>

  <span class="copyright-year">&copy;2017 - 2020<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">heeexy</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
