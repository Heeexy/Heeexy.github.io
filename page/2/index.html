<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<link rel="alternate" href="/atom.xml" title="街上的动物园"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="http://heeexy.com/page/2/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" /><script type="text/x-mathjax-config">
    MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-103584593-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-103584593-1');
</script><script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":true};
</script>

    <title>街上的动物园</title>
  <meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="街上的动物园" type="application/atom+xml">
</head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">街上的动物园</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">首页
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">归档
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签
          </li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">街上的动物园</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            归档
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            标签
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/categories/">
            分类
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><section id="posts" class="posts"><article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2017/12/14/mybatis_design_patterns/">MyBatis 的日志设计--适配器模式 & 工厂模式</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-12-14
        </span><span class="post-category">
            <a href="/categories/MyBatis%E7%AC%94%E8%AE%B0/">MyBatis笔记</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p>​    MyBatis 想要打印日志，时不时想要来句 log.debug() 、log.error() ，需要个打印机 ，可是自己又不想去实现（而且跟着整个项目用同样的打印系统才是王道啊），需要去用别人家的打印机，要用别人家的产品啊，那问题可就来了。</p>
<h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题 1"></a>问题 1</h2><p>​    市面上各家的打印机 slf4j、java.util.logging、log4j 甚至 System.out 都是各种不同的用法，这使用起来就太麻烦了。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>​    不管市面上打印机有多少型号，我家 MyBatis 包里的类只用自家的统一接口，我家的类只管 log.debug()、log.error()…</p>
<p>​    定义好了接口，就需要实现类 impl 来实现这些 debug()、error() 方法了 , 咱假装是自己来实现，其实去调用真正打印机 slf4、log4j 的方法，这样就把别人家的打印机和咱自家的接口关联起来啦。</p>
<p>​    这就是<strong>适配器模式</strong>。</p>
<p>​    我家的每个实现类其实就是一个适配器，每个适配器去适配一种打印机。比如 slf4jLoggerImpl 就完成了对 slf4j 打印机的适配，slf4jLoggerImpl .debug() 调用了slf4j.Logger.debug()。</p>
<p>​    这样市面上每多一种打印机，比如想用 log4j2 了，我就只需要加一种适配器 log4j2LoggerImpl 去适配它就可以了。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>​    定义接口 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(String s)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    在实现类里完成适配，比如适配 slf4j 的 <code>Slf4jLoggerImpl</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.ibatis.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slf4jLoggerImpl</span> <span class="keyword">implements</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Logger log;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//注意这个地方，入参为 org.slf4j.Logger </span></span><br><span class="line">  <span class="comment">//说明咱这个适配器要用起来，是需要传入一个真正的 slf4j 家的打印机进来的</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Slf4jLoggerImpl</span><span class="params">(Logger logger)</span> </span>&#123;</span><br><span class="line">    log = logger;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//看似外面调用咱 MyBatis 的 Log 的 debug()</span></span><br><span class="line">  <span class="comment">//其实是调用 org.slf4j.Logger 的 debug() </span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.debug(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="问题-2"><a href="#问题-2" class="headerlink" title="问题 2"></a>问题 2</h2><p>​    适配器咱是做好了，slf4j、log4j、stdout…做了那么多适配器，可是怎么用啊？我真正要打印机的时候，怎么才能知道我该调用哪款适配器啊？难道每次取打印机的时候，都去查一遍咱的系统配了那款打印机（jar) 包么？而且以后多加了1种打印机，我还去每个地方都改一遍，都多加一道判断么？</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>​    这其实就是获取实例的时候的问题，咱获取实例太累了，不如来个统一的工厂吧，我每次想打印的时候，都去找工厂要一台打印机，你工厂按照我 Log 的接口给我一个实例就是了。我也不管你给的具体实现到底是 slf4j 家的，还是 log4j 的，甚至可能是 <code>NoLoggingImpl</code> 每次调接口都不处理的这种空壳打印机。</p>
<p>​    这样一来，有了统一的工厂，判断系统用哪种适配器的任务就可以在工厂完成了。</p>
<p>​    而且以后就算新加了打印机，也只要改改工厂的代码，在工厂里多加一重判断就可以了。</p>
<p>​    这就是<strong>工厂模式</strong>。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>​    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LogFactory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;? extends Log&gt; logConstructor;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    tryImplementation(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        useSlf4jLogging();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    tryImplementation(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        useCommonsLogging();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">LogFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// disable construction</span></span><br><span class="line">  &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Log <span class="title">getLog</span><span class="params">(String logger)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> logConstructor.newInstance(logger);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    LogFactory 提供了对外的 getLog(String logger) 方法，给需要 logger 的地方提供一个 Log 的实例。</p>
<p>​    内部的实现依靠 <code>logConstructor</code>  这个构造器通过反射来实例化一个 Log 的 Impl ，也就是之前的适配器，比如 Slf4jLoggerImpl 。</p>
<p>​    判断采用哪种<code>logConstructor</code> 的任务则在类初始化的时候就执行了，依次尝试了我们的每一款适配器，碰上报错就说明没 jar 包，下一款，全都没有的话，就用 NoLoggingImpl 了。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2017/11/13/setup-SSR-in-GCE/">谷歌云搭建SSR</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-11-13
        </span><span class="post-category">
            <a href="/categories/%E9%A3%9E%E8%B7%83%E9%95%BF%E5%9F%8E/">飞跃长城</a>
            </span>
        </div>
    </header>

    <div class="post-content"><blockquote>
<p>在全国喜迎大会胜利召开的时候,墙出不去了,经常看到大家有这么一种想法 : 等会开完就好了……</p>
</blockquote>
<h1 id="为什么用GCE"><a href="#为什么用GCE" class="headerlink" title="为什么用GCE"></a>为什么用GCE</h1><ol>
<li><p><strong>速度快</strong>. 有台湾服务器,南京电信ping 稳定在40-60 ,youtube4K无压力.  Chrome可以愉快地把Google用作默认浏览器了</p>
</li>
<li><p><strong>免费一年</strong>. 只是需要提供一张外币信用卡,但是不会扣款,更不会在一年到期后自动扣款!(被AWS坑了几美元去)</p>
<p>​</p>
</li>
</ol>
<h1 id="如何申请GCE"><a href="#如何申请GCE" class="headerlink" title="如何申请GCE"></a>如何申请GCE</h1><p>​    网上搜到教程很多,就不细述了</p>
<p>​    有几个可能会卡时间的步骤包括</p>
<ul>
<li><p>选用静态IP</p>
</li>
<li><p>和AWS一样, 放开你要分配给SSR的端口 ,如果找不到这个菜单可以搜索Firewall rules</p>
</li>
<li><p>Xshell生成的SSH的私钥可能要在后面加上</p>
<p> <code>google-ssh {&quot;userName&quot;:&quot;xxxxx@gmail.com&quot;,&quot;expireOn&quot;:&quot;2017-11-10T04:39:03+0000&quot;}</code> </p>
<p>​</p>
</li>
</ul>
<h1 id="如何部署SSR"><a href="#如何部署SSR" class="headerlink" title="如何部署SSR"></a>如何部署SSR</h1><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>获取root权限</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装SSR</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -N --no-check-certificate https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;91yun&#x2F;shadowsocks_install&#x2F;master&#x2F;shadowsocksR.sh &amp;&amp; bash shadowsocksR.sh</span><br></pre></td></tr></table></figure>

<p>​    安装完成的时候会有一串成功的提示信息, 可以复制记下你的ip/端口/密码/加密方式等信息</p>
<ol start="3">
<li>安装BBR</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate https:&#x2F;&#x2F;github.com&#x2F;teddysun&#x2F;across&#x2F;raw&#x2F;master&#x2F;bbr.sh</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x bbr.sh</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;bbr.sh</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>重置VM实例</p>
</li>
<li><p>sudo su</p>
</li>
<li><p>检查是否成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br></pre></td></tr></table></figure>

<p>看是不是出现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_available_congestion_control &#x3D; bbr cubic reno</span><br></pre></td></tr></table></figure>

<p>类似有 bbr 的字样,有就表示BBR也装好了</p>
</li>
</ol>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>/etc/init.d/shadowsocks restart    重启SSR</p>
<p>vi /etc/shadowsocks.json                 修改配置文件</p>
<h1 id="SSR客户端"><a href="#SSR客户端" class="headerlink" title="SSR客户端"></a>SSR客户端</h1><p>下载网址  <a href="https://github.com/shadowsocksrr/shadowsocks-rss" target="_blank" rel="noopener">github</a></p>
<p>或者<a href="http://ots7yt7am.bkt.clouddn.com/file/ShadowsocksR-4.7.0.7z" target="_blank" rel="noopener">这里直接下载</a> </p>
<p>配置和以前的SS也差不多, 有几点注意的是</p>
<ol>
<li>填写加密/协议/混淆, 默认的是chacha20/auth_sha1_v4/tls1.2_ticket_auth</li>
<li>在选项设置里将本地端口设置成你SwitchOmega配置的本地端口.比如我就用了10801而不是默认的1080</li>
</ol>
<h1 id="其它SSR"><a href="#其它SSR" class="headerlink" title="其它SSR"></a>其它SSR</h1><p>​    <a href="https://52world.top" target="_blank" rel="noopener">https://52world.top</a>    </p>
<p>​    不知道在哪看来的这个SSR网站,有免费SSR,也可以充钱升级专业版. 目前还是能用的 , 可以收藏着防止哪天其它翻墙方式失效吧.</p>
<p>​    毕竟翻墙第一定律就是:永远不要在一种翻墙方式上吊死!</p>
<hr>
<p>参考网站</p>
<ol>
<li><a href="https://suiyuanjian.com/124.html" target="_blank" rel="noopener">https://suiyuanjian.com/124.html</a></li>
<li><a href="http://www.jianshu.com/p/6bd66829a1ce" target="_blank" rel="noopener">http://www.jianshu.com/p/6bd66829a1ce</a></li>
<li><a href="http://suppore.cn/512.html" target="_blank" rel="noopener">http://suppore.cn/512.html</a></li>
</ol>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2017/10/29/end-to-end/">前后端分离实践小结</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-10-29
        </span><span class="post-category">
            <a href="/categories/%E5%B0%8F%E7%BB%93/">小结</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    公司项目转型,要开新的运营管理平台,我提议借此开新项目的机会,进行前后端分离,由我负责带领小组新技术学习/分享,探坑填坑.</p>
<h2 id="分离原因"><a href="#分离原因" class="headerlink" title="分离原因"></a>分离原因</h2><ol>
<li>最关键一点,受不了jsp/freemarker里一塌糊涂的代码,分离之后,代码按规范写,简洁,好管理</li>
<li>原本我们后端就一直在给Android/iOS提供接口,本次分离,可以方便以后H5端的项目重构,实现Android+iOS+H5的统一,一套接口可以供三端同时使用,大量节省工作量,也可以更好地保证公司产品质量的统一性.</li>
<li>方便后端专心处理数据,前端实现页面效果.而不是前端仅仅画页面写css,后端还需要复制粘贴过来,套数据,修改已有页面时,前端更是不方便插手.</li>
</ol>
<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>​    组员后端技术都是SSM,前端都只是略接触过AngularJS/Vue.</p>
<p>​    我之前接触了一下Spring Boot,感觉配置很清爽,搭框架轻松,业务写起来快,可以让组员无缝切过来,无需费时学习,因此后端框架选定Spring Boot.而登录控制与权限管理一直是公司以前几个项目的弱项,因此本次决定引入shiro,而组员无一对shiro熟悉的,研究shiro的任务自然由我承担.</p>
<p>​    前端框架是本次前后端分离的重点,由于我们组无人熟悉前端的新框架,所以这次势必每个人都需要学习许多新的前端知识.我拿公司的H5项目的几个页面进行过搭建vue框架重构练手,认为vue文档清晰,资料丰富,相关开源方案够多,我们这次可以放心学习,使用.(当然最主要的还是因为坑全都得由我来填,得挑个熟悉的)</p>
<h2 id="目前进展"><a href="#目前进展" class="headerlink" title="目前进展"></a>目前进展</h2><p>​    后端:Spring Boot框架搭建完成,shiro可以进行权限管理,自定义拦截器,常用工具类完成,对常用的增删改查,返回结果,异常处理都可以快速搞定.</p>
<p>​    前端:数据交互封装完毕,路由熟悉,前端权限管理初步熟悉,选用饿了么开源的Element框架,常用的增删改查的页面元素及工具方法都已让大家掌握.</p>
<p>​    本周一开始教组员使用Intellij IDEA,教前端快速铺页面的方法,介绍前后端我封装的各种小轮子.经过一周时间,全部都已熟悉这套新的前后端框架,每个人都可以独立快速地推出常用页面.</p>
<h2 id="接口端小技巧"><a href="#接口端小技巧" class="headerlink" title="接口端小技巧"></a>接口端小技巧</h2><p>​    因为后端全部返回统一json格式的接口,所以我设计了一些小的工具方法,方便快速推出新接口,节省重复代码.</p>
<ol>
<li><p>使用JSONObject而不是实体类</p>
<p>​    因为后端业务不算复杂,所以舍弃了实体类的语义性,转而使用阿里的fastjson的JSONObject接收MyBatis返回的结果.比如一个简单的查询只需要</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getSimple"</span> <span class="attr">resultType</span>=<span class="string">"com.alibaba.fastjson.JSONObject"</span>&gt;</span></span><br><span class="line">    SELECT</span><br><span class="line">        s.order_id                                      shopOrderId,</span><br><span class="line">        s.operation                                     operation,</span><br><span class="line">        date_format(s.create_time, '%Y.%m.%d %H:%i:%s') createTime</span><br><span class="line">    FROM shop_order_log s</span><br><span class="line">    WHERE s.user_delete_status = "1"</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>就可以将三个字段shopOrderId,operation,createTime放入json内,字段名称更加灵活,也免去了大量的建实体类,写resultMap的代码.</p>
<p>​    更好的一点是,不使用实体类,可以在返回结果中避免掉很多空的需不要的字段.</p>
<p>​    还有,因为所有的接口层都返回JSONObject,所以编写工具方法,快速返回成功/失败结果也很简单,我写了多个工具方法,包括入参转json,入参非空校验,返回成功/失败结果,分页,这里就不一一贴出代码了.</p>
</li>
<li><p>自定义Exception</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonJsonException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JSONObject resultJson;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 调用时可以在任何代码处直接throws这个Exception,</span></span><br><span class="line"><span class="comment">* 都会统一被拦截,并封装好json返回给前台</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> errorEnum 以错误的ErrorEnum做参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">CommonJsonException</span><span class="params">(ErrorEnum errorEnum)</span> </span>&#123;</span><br><span class="line">       JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">       CommonUtil.returnJson(jsonObject, errorEnum);</span><br><span class="line">       <span class="keyword">this</span>.resultJson = jsonObject;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">CommonJsonException</span><span class="params">(JSONObject resultJson)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.resultJson = resultJson;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> JSONObject <span class="title">getResultJson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> resultJson;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@ControllerAdvice</span></span><br><span class="line">   <span class="meta">@ResponseBody</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line">        <span class="meta">@ExceptionHandler</span>(CommonJsonException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">   <span class="title">public</span> <span class="title">JSONObject</span> <span class="title">CommonJsonExceptionHandler</span>(<span class="title">CommonJsonException</span> <span class="title">commonJsonException</span>) <span class="title">throws</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> commonJsonException.getResultJson();</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在需要返回给前端错误代码编号时,比如校验参数非空,校验手机号失败,可以直接抛出此异常,经错误拦截器拦截到此异常后,可以直接返回错误码给前端,节省大量的判断/返回的代码.这一点也是前阵子从Spring源码中学到的.</p>
</li>
</ol>
<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><ol>
<li>近期主要问题基本都是待我去研究深入的技术,比如shiro的动态权限与vue-router的异步路由的结合,vue组件的通信,vuex的状态管理</li>
<li>其次是组员需要对vue更加熟悉,我这次要求了大家抛弃jQuery,用数据绑定的思想去写前端.目前大家的前端水平也还只是可以快速复制粘贴出页面,对于复杂的页面和组件,甚至对我们前端项目的目录结构与各部分功能,都不算掌握.</li>
<li>目前我们所谓的前后端分离其实还只是初步的业务和代码上的分离,以后如果要重构H5项目,可能还需要开NodeJS项目来解决和Android/iOS一样的接口加密问题,统一session管理问题,以及更多的前后端分离可能给我们带来的问题.</li>
</ol>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2017/10/22/build-springboot-shiro-vue/">搭建springboot-shiro-vue框架时遇到的坑</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-10-22
        </span><span class="post-category">
            <a href="/categories/shiro/">shiro</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p>​    最近在做前后端分离的新框架,选用了后端springboot+shiro,前端vue+elementUI,第一次搭SSM之外的非demo项目,尤其shiro更是之前从未接触,折腾了很多天,遇到很多问题,大部分能百度出来,剩下的非常费时的问题且称之为坑吧.</p>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>​    一大部分问题就是跨域造成的,本身vue-cli搭建的项目可以用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. axios的baseURL设置为/api</span></span><br><span class="line"><span class="comment">// 2. 如下设置</span></span><br><span class="line">proxyTable: &#123;</span><br><span class="line">      <span class="string">'/api'</span>: &#123;</span><br><span class="line">        target: <span class="string">'http://127.0.0.1:8080/'</span>,</span><br><span class="line">        changeOrigin: <span class="literal">true</span>,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          <span class="string">'^/api'</span>: <span class="string">'/'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>来解决开发环境跨域的问题,生产环境反正可以打包静态文件到springboot项目中直接跑.</p>
<p>而我还是脑抽得选择了强行跨域,假装自己要把静态文件单独放个服务器跑…为此遇到很多问题,折腾好几天.</p>
<p><strong>因此强力推荐上面的方案,简单快捷地解决跨域!</strong></p>
<p>如果生产环境真的需要跨域的话,再按下面方法设置</p>
<p>大部分跨域的配置都能百度搜出来:</p>
<ol>
<li><p>axios要 <code>withCredentials: true</code> </p>
</li>
<li><p>用session而不用啥特殊的token之类的话,就不用 <code>config.headers[&#39;X-Token&#39;] = getToken()</code> ,这句是<a href="https://github.com/PanJiaChen/vueAdmin-template" target="_blank" rel="noopener"><strong>vueAdmin-template</strong></a> 中带的,需要删掉.</p>
</li>
<li><p>后端需要配置允许跨域</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> CorsConfiguration <span class="title">buildConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="string">"*"</span>); <span class="comment">// 1 设置访问源地址</span></span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">"*"</span>); <span class="comment">// 2 设置访问源请求头</span></span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">"*"</span>); <span class="comment">// 3 设置访问源请求方法</span></span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> corsConfiguration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">"/**"</span>, buildConfig()); <span class="comment">// 4 对接口配置跨域设置</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</li>
</ol>
<h3 id="shiro拦截ajax返回json"><a href="#shiro拦截ajax返回json" class="headerlink" title="shiro拦截ajax返回json"></a>shiro拦截ajax返回json</h3><p>​    shiro拦截到需要登录而用户尚未的请求时,会重定向至 /login/auth (未配置时是login.jsp),而ajax是不允许重定向的,ajax会收到302错误码,报错</p>
<blockquote>
<p>Failed to load <a href="http://localhost:8080/test" target="_blank" rel="noopener">http://localhost:8080/test</a>: Redirect from ‘<a href="http://localhost:8080/test&#39;" target="_blank" rel="noopener">http://localhost:8080/test&#39;</a> to ‘<a href="http://localhost:8080/login/auth&#39;" target="_blank" rel="noopener">http://localhost:8080/login/auth&#39;</a> has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘<a href="http://localhost:9528&#39;">http://localhost:9528&#39;</a> is therefore not allowed access.</p>
</blockquote>
<p>因此我们需要对拦截器进行改造,不要它默认的重定向了,我们直接去response里把json写好输出给前端.</p>
<p>自定义filter,(因为我的后端全部返回json,所以这里不判断是否ajax了)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AjaxPermissionsAuthorizationFilter</span> <span class="keyword">extends</span> <span class="title">FormAuthenticationFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAccessDenied</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        jsonObject.put(<span class="string">"returnMsg"</span>, <span class="string">"未登录或登录已失效"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isLoginRequest(request, response)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isLoginSubmission(request, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.executeLogin(request, response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            PrintWriter out = <span class="keyword">null</span>;</span><br><span class="line">            HttpServletResponse res = (HttpServletResponse) response;</span><br><span class="line">           	<span class="comment">//下面这几行也是后面要讲的坑, 这里的Access-Control-Allow-Origin 设置为*的话,前端还是会报错. </span></span><br><span class="line">            res.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"http://localhost:9528"</span>);</span><br><span class="line">            <span class="comment">//  response1.setHeader("Access-Control-Allow-Origin", "*");</span></span><br><span class="line">            res.setHeader(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="string">"true"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                res.setCharacterEncoding(<span class="string">"UTF-8"</span>);<span class="comment">//设置编码</span></span><br><span class="line">                res.setContentType(<span class="string">"application/json"</span>);<span class="comment">//设置返回类型</span></span><br><span class="line">                out = response.getWriter();</span><br><span class="line">                out.println(jsonObject);<span class="comment">//输出</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != out) &#123;</span><br><span class="line">                    out.flush();</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是最坑的地方了,拦截器的注入.</p>
<p><a href="http://m.blog.csdn.net/u014042146/article/details/72834582" target="_blank" rel="noopener">原本搜到的方法</a>是在ShiroConfiguration类中注入.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = <span class="string">"ajaxPermissionsAuthorizationFilter"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> AjaxPermissionsAuthorizationFilter <span class="title">ajaxPermissionsAuthorizationFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AjaxPermissionsAuthorizationFilter();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//然后shiroFilterFactoryBean设置过滤器</span></span><br><span class="line"> 		Map&lt;String, Filter&gt; filterMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">       filterMap.put(<span class="string">"authc"</span>, <span class="keyword">new</span> AjaxPermissionsAuthorizationFilter());</span><br><span class="line">       shiroFilterFactoryBean.setFilters(filterMap);</span><br></pre></td></tr></table></figure>

<p>结果自定义的拦截器把所有的请求都拦截了,直接无视了我设置的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">filterChainDefinitionMap.put(<span class="string">"/"</span>, <span class="string">"anon"</span>);</span><br><span class="line">filterChainDefinitionMap.put(<span class="string">"/static/**"</span>, <span class="string">"anon"</span>);</span><br><span class="line">filterChainDefinitionMap.put(<span class="string">"/login/**"</span>, <span class="string">"anon"</span>);</span><br><span class="line">filterChainDefinitionMap.put(<span class="string">"/error"</span>, <span class="string">"anon"</span>);</span><br><span class="line">filterChainDefinitionMap.put(<span class="string">"/**"</span>, <span class="string">"authc"</span>);</span><br></pre></td></tr></table></figure>

<p>各种百度,能搜到的相关的资料也就只有<a href="https://segmentfault.com/q/1010000010747919" target="_blank" rel="noopener">segmentfault的提问没解决,题主给我的回复也不能解决</a> , <a href="https://zhidao.baidu.com/question/436777330932025604.html" target="_blank" rel="noopener">百度知道提问的没解决</a> , <a href="http://www.jianshu.com/p/e30dc5e78641" target="_blank" rel="noopener">简书方案并不能解决</a> .</p>
<p>最终在某个百度结果的第三页找到<a href="http://www.hillfly.com/2017/179.html" target="_blank" rel="noopener">这篇博客</a> ,博主对问题一步一步的排查分析,debug源码,最终知道</p>
<p><strong>Springboot 先加载了我们自定义的 Filter，然后再加载了 ShiroFilter</strong></p>
<p>解决方法:<br>在自定义的filter里加上下面的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public FilterRegistrationBean registration(自定义Filter filter) &#123;</span><br><span class="line">    FilterRegistrationBean registration &#x3D; new FilterRegistrationBean(filter);</span><br><span class="line">    registration.setEnabled(false);</span><br><span class="line">    return registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在configration类里就不需要声明这个bean,只需要直接调用 <code>filterMap.put(&quot;authc&quot;, new 自定义Filter());</code></p>
<h3 id="Access-Control-Allow-Origin"><a href="#Access-Control-Allow-Origin" class="headerlink" title="Access-Control-Allow-Origin"></a>Access-Control-Allow-Origin</h3><p>在上面的自定义filter里,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"http://localhost:9528"</span>);</span><br></pre></td></tr></table></figure>

<p>如果设置为*的话,前端虽然可以收到json,但还是会报错</p>
<blockquote>
<p>Failed to load <a href="http://localhost:8080/test" target="_blank" rel="noopener">http://localhost:8080/test</a>: The value of the ‘Access-Control-Allow-Origin’ header in the response must not be the wildcard ‘*’ when the request’s credentials mode is ‘include’. Origin ‘<a href="http://localhost:9528&#39;">http://localhost:9528&#39;</a> is therefore not allowed access. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.</p>
</blockquote>
<p>不允许设置为通配符* .</p>
<p>虽然此处设置了”<a href="http://localhost:9528&quot;">http://localhost:9528&quot;</a> 但是这种做法终究不合适.</p>
<p>百度继续搜到<a href="http://blog.csdn.net/u011517841/article/details/68490586" target="_blank" rel="noopener">此博客</a></p>
<p>得到解决方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(&quot;Access-Control-Allow-Origin&quot;, ((HttpServletRequest) request).getHeader(&quot;Origin&quot;));</span><br></pre></td></tr></table></figure>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2017/09/29/getSingleton/">Spring源码笔记-2.4 获取单例</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-09-29
        </span><span class="post-category">
            <a href="/categories/Spring%E7%AC%94%E8%AE%B0/">Spring笔记</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h2 id="获取单例bean-getSingleton"><a href="#获取单例bean-getSingleton" class="headerlink" title="获取单例bean getSingleton"></a>获取单例bean <code>getSingleton</code></h2><blockquote>
<p>明明之前一篇已经讲过了获取单例,为什么这里又是获取单例bean呢?</p>
<p>两天不看书,果断又忘了.前面学的是<strong>从缓存中</strong>获取,这里是真正的获取.</p>
</blockquote>
<p><code>DefaultSingletonBeanRegistry</code>  中重载此方法,第二参数为ObjectFactory&lt;?&gt;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">      Assert.notNull(beanName, <span class="string">"'beanName' must not be null"</span>);</span><br><span class="line">  	<span class="comment">//这里再次看到了这个singletonObjects,上篇文章介绍过,是维护了单例对象</span></span><br><span class="line">  	<span class="comment">//书中说法是:用于保存BeanName和创建bean实例之间的关系</span></span><br><span class="line">      Map var3 = <span class="keyword">this</span>.singletonObjects;</span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">          Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        	<span class="comment">//首先获取一遍,如果不存在,才去创建</span></span><br><span class="line">          <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            	<span class="comment">//工厂如果正在销毁,这时候获取bean就会报错</span></span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName, <span class="string">"Singleton bean creation not allowed while the singletons of this factory are in destruction (Do not request a bean from a BeanFactory in a destroy method implementation!)"</span>);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                	<span class="comment">//打印日志,正在创建单例bean(beanName)的共享的实例</span></span><br><span class="line">                  <span class="keyword">this</span>.logger.debug(<span class="string">"Creating shared instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">              &#125;</span><br><span class="line">		<span class="comment">//标志这个beanName正在创建,如果同时重复创建,会报错</span></span><br><span class="line">              <span class="keyword">this</span>.beforeSingletonCreation(beanName);</span><br><span class="line">              <span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line">              <span class="keyword">boolean</span> recordSuppressedExceptions = <span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>;</span><br><span class="line">              <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                  <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                	<span class="comment">//=============这里应该是最关键的创建bean的步骤===============</span></span><br><span class="line">                  singletonObject = singletonFactory.getObject();</span><br><span class="line">                	<span class="comment">//标识新创建出来的单例</span></span><br><span class="line">                  newSingleton = <span class="keyword">true</span>;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (IllegalStateException var16) &#123;</span><br><span class="line">                	<span class="comment">//非法状态错误,应该是创建过程中发现存在其他线程已创建此单例</span></span><br><span class="line">                	<span class="comment">//所以此处catch里面再次调用了singletonObjects.get(beanName);</span></span><br><span class="line">                  singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                  <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      <span class="keyword">throw</span> var16;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (BeanCreationException var17) &#123;</span><br><span class="line">                	<span class="comment">//其它创建bean错误</span></span><br><span class="line">                  BeanCreationException ex = var17;</span><br><span class="line">                  <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                      Iterator var8 = <span class="keyword">this</span>.suppressedExceptions.iterator();</span><br><span class="line">                      <span class="keyword">while</span>(var8.hasNext()) &#123;</span><br><span class="line">                          Exception suppressedException = (Exception)var8.next();</span><br><span class="line">                        	<span class="comment">//把其它recordSuppressedExceptions塞入这个ex一并抛出</span></span><br><span class="line">                          ex.addRelatedCause(suppressedException);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">throw</span> ex;</span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                      <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                	<span class="comment">//确认这个beanName在几个set中的状态</span></span><br><span class="line">                  <span class="keyword">this</span>.afterSingletonCreation(beanName);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">               	<span class="comment">//如果是新创建的,则加入缓存,移除几个新创建的标识,名字加入registeredSingletons</span></span><br><span class="line">                  <span class="keyword">this</span>.addSingleton(beanName, singletonObject);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        	<span class="comment">//返回,如果是NULL_OBJECT也作为null返回.</span></span><br><span class="line">        	<span class="comment">//这个NULL_OBJECT应该是在前面的获取方法中有可能的特殊返回值</span></span><br><span class="line">          <span class="keyword">return</span> singletonObject != NULL_OBJECT ? singletonObject : <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>从上可以看出,获取单例还是通过 <code>synchronized(this.singletonObjects)</code>  加锁来实现，先从 <code>singletonObjects</code> 查一遍有没有已存在的，若没有则再进行创建。</p>
<p>而创建的步骤，则是在入参的 <code>ObjectFactory&lt;?&gt;</code> 中完成，调用其 getObject() 依然还是调用我们本身<code>AbstractBeanFactory</code> 的 <code>createBean</code> 方法。</p>
<hr>
<p>我们先不急着往下看，先理一理，首先第一点要知道的是单例加锁都是 <code>synchronized(this.singletonObjects)</code> 。其次获取单例 bean 的大致步骤，无非就是：</p>
<ol>
<li><p>上一文中介绍的，从缓存中拿，并且允许“早期引用” ，即从 <code>earlySingletonObjects</code> 中拿。</p>
</li>
<li><p>如果缓存中没有，则自己创建，</p>
<p>2.1 在各种 map 里记录它的 创建、销毁等信息</p>
<p>2.2 通过<code>createBean</code> 方法去具体创建这个实例。</p>
</li>
</ol>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2017/09/26/getSingleton/">Spring源码笔记-2.3 缓存中获取单例bean及获取对象</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-09-26
        </span><span class="post-category">
            <a href="/categories/Spring%E7%AC%94%E8%AE%B0/">Spring笔记</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h2 id="缓存中获取单例bean-getSingleton"><a href="#缓存中获取单例bean-getSingleton" class="headerlink" title="缓存中获取单例bean getSingleton"></a>缓存中获取单例bean <code>getSingleton</code></h2><p><code>DefaultSingletonBeanRegistry</code> 中实现此方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个map维护了单例对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap(<span class="number">256</span>);</span><br><span class="line"><span class="comment">//当前正在创建中的单例对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation = Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap(<span class="number">16</span>));</span><br><span class="line"><span class="comment">//早期单例对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap(<span class="number">16</span>);</span><br><span class="line"><span class="comment">//单例工厂?</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">  	<span class="comment">//如果根据这个beanName没取到对象,但发现这个对象还在创建中.....</span></span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        Map var4 = <span class="keyword">this</span>.singletonObjects;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">          	<span class="comment">//如果早期单例对象中没有此bean,并且允许早期依赖</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">              <span class="comment">//当某些方法需要提前初始化的时候则会调用 addSingletonFactory方法将对应的ObjectFactory初始化策略存储在singletonFactories</span></span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = (ObjectFactory)<span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">//调用预先设定的getObject方法</span></span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                  <span class="comment">//记录在缓存中,earlySingletonObjects 和 singletonFactories互斥</span></span><br><span class="line">                    <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject != NULL_OBJECT ? singletonObject : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="http://ots7yt7am.bkt.clouddn.com/blog/DefaultSingletonBeanRegistry.png" alt=""></p>
<p>这里还是看得迷迷糊糊的,毕竟一来就各种取值, 往后看看在哪塞值的吧!</p>
<h2 id="从bean的实例中获取对象-getObjectForBeanInstance"><a href="#从bean的实例中获取对象-getObjectForBeanInstance" class="headerlink" title="从bean的实例中获取对象 getObjectForBeanInstance"></a>从bean的实例中获取对象 <code>getObjectForBeanInstance</code></h2><p>​    我们得到bean的实例后要做的第一步都是调用这个方法来检测一下正确性,其实就是用于检测当前bean是否是<code>FactoryBean</code> 类型的bean,如果是,就要调用<code>getObject()</code> 方法作为返回值</p>
<p>​    <a href="http://heeexy.com/2017/09/26/FactoryBean/">FactoryBean</a> 在之前我们便已经接触过.</p>
<p>​    <code>getObjectForBeanInstance</code> 方法就不贴了, 主要就是各种验证, 取缓存等等, 里面需要注释的一段如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   	<span class="comment">//将存储XML配置文件的GernericBeanDefinition 转换为RootBeanDefinition,</span></span><br><span class="line">	<span class="comment">//如果指定BeanName是子bean的话,同时会合并父类的相关属性</span></span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">                    mbd = <span class="keyword">this</span>.getMergedLocalBeanDefinition(beanName);</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<p>​    方法中的关键是 <code>getObjectFromFactoryBean</code> , 实现类为 <code>FactoryBeanRegistrySupport</code> </p>
<p>​    而 <code>getObjectFromFactoryBean</code>  方法中也还不是最核心的, 其代码主要是保证单例bean的全局唯一. 如果是单例,那就不用重复创建,可以使用缓存来提高性能. 另外方法还根据需要对bean进行了后处理<code>postProcessObjectFromFactoryBean()</code> </p>
<p><strong>后处理</strong>即是遍历所有的bean后处理器,在bean初始化后调用它的处理方法,后面还会详细学习.</p>
<p>​    它的关键是 <code>doGetObjectFromFactoryBean</code>  ,方法名前面多加了个do…</p>
<pre><code>在这个方法里面,我们终于看到想要看到的 `object = factory.getObject();`  ,虽然早已知道必须要走到这,但是到这一步`getObject()` 还是绕了很多路,包括到这里居然还使用了`java.security.AccessController` 权限验证...</code></pre><p>​    </p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2017/09/26/FactoryBean/">Spring源码笔记-2.2 FactoryBean</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-09-26
        </span><span class="post-category">
            <a href="/categories/Spring%E7%AC%94%E8%AE%B0/">Spring笔记</a>
            </span>
        </div>
    </header>

    <div class="post-content"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  	<span class="comment">//返回由FactoryBean创建的bean实例,如果isSingleton()返回true,则该实例会放到Spring容器中单实例缓存池中</span></span><br><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">	<span class="comment">//返回FactoryBean创建的bean类型</span></span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line">	<span class="comment">//返回bean实例的作用域是singleton还是prototype</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    当配置文件<bean>的class属性配置的实现类是<code>FactoryBean</code> 时,通过<code>getBean()</code> 方法返回的不是<code>FactoryBean</code> 本身,而是<code>FactoryBean.getObject()</code> 方法所返回的对象.</p>
<p>​    相当于<code>FactoryBean.getObject()</code> 代理了<code>getBean()</code> 方法.</p>
<p>​    例如,如果使用传统方式配置Car的bean,Car的每个属性对应一个<property> 元素标签</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxSpeed;</span><br><span class="line">  <span class="keyword">private</span> String brand;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">  <span class="comment">//get/set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    如果使用FactoryBean的方式就会灵活一些,下面通过逗号分隔符的方式一次性地为Car的所有属性指定配置值:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Car</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String carInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Car car = <span class="keyword">new</span> Car();</span><br><span class="line">        String[] infos = carInfo.split(<span class="string">","</span>);</span><br><span class="line">        car.setBrand(infos[<span class="number">0</span>]);</span><br><span class="line">        car.setMaxSpeed(Integer.valueOf(infos[<span class="number">1</span>]));</span><br><span class="line">        car.setPrice(Double.valueOf(infos[<span class="number">2</span>]));</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Car<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCarInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> carInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCarInfo</span><span class="params">(String carInfo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.carInfo = carInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了这个CarFactoryBean之后,就可以在配置文件使用下面这种自定义的配置方式配置Car bean了</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"car"</span> <span class="attr">class</span>=<span class="string">"com.test.factoryBean.CarFactoryBean"</span> <span class="attr">carInfo</span>=<span class="string">"超级跑车,400,3000"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>调用 getBean(“car”) , Spring并不会返回<code>CarFactoryBean</code> 而是返回car</p>
<p>如果希望返回<code>CarFactoryBean</code> 那就 getBean(“&amp;car”)</p>
<hr>
<p>书本作者讲到<code>FactoryBean</code> 接口对于Spring框架很关键, Spring自身就提供了70多个实现.</p>
<p>它们隐藏了实例化一些复杂的bean的细节,给上层应用带来了便利.</p>
<blockquote>
<p>疑问: 具体哪些地方用<code>FactoryBean</code> 带来了真正的便利呢?</p>
<p>答: </p>
</blockquote>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2017/09/26/load_bean/">Spring源码笔记-2.1 bean的加载初探</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-09-26
        </span><span class="post-category">
            <a href="/categories/Spring%E7%AC%94%E8%AE%B0/">Spring笔记</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h3 id="本文要看啥"><a href="#本文要看啥" class="headerlink" title="本文要看啥?"></a>本文要看啥?</h3><p>​    前面已经了解了bean从配置文件到解析成BDHolder到注册的流程,我们已经将bean的信息封装好,塞入了map中,这个map可能在不同的实现里面,前面重点学的就是DefaultListableBeanFactory里的beanDefinitionMap.</p>
<p>​    我们现在要探索bean的加载,围绕最初的示例代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyTestBean bean =(MyTestBean)bf.getBean(<span class="string">"myTestBean"</span>);</span><br></pre></td></tr></table></figure>

<p>​    BeanFactory是个接口,其下实现关系很复杂, getBean方法的实现主要是在<code>AbstractBeanFactory</code> 这一层.</p>
<p>​    本文就是先来快速体验一下加载bean的大体流程</p>
<h3 id="进入代码吧"><a href="#进入代码吧" class="headerlink" title="进入代码吧"></a>进入代码吧</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(String name, Class&lt;T&gt; requiredType, <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="comment">//转换beanName</span></span><br><span class="line">    <span class="keyword">final</span> String beanName = <span class="keyword">this</span>.transformedBeanName(name);</span><br><span class="line">    <span class="comment">//根据beanName找其单例</span></span><br><span class="line">    Object sharedInstance = <span class="keyword">this</span>.getSingleton(beanName);</span><br><span class="line">    Object bean;</span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.debug(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName + <span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.debug(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//返回对应的实例</span></span><br><span class="line">        bean = <span class="keyword">this</span>.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)<span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">//原型模式下,如果这个bean已经正在创建中,说明是如下情况</span></span><br><span class="line">      	<span class="comment">//A中有B的属性,B中有A的属性,当依赖注入的时候,就回产生当A还未创建完的时候,</span></span><br><span class="line">      	<span class="comment">//因为对于B的创建,再次返回创建A,造成循环依赖</span></span><br><span class="line">      	<span class="comment">//所以就会报错</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//获取父工厂</span></span><br><span class="line">        BeanFactory parentBeanFactory = <span class="keyword">this</span>.getParentBeanFactory();</span><br><span class="line">      	<span class="comment">//如果本工厂没有这个bean,存在父工厂,就去父工厂找</span></span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            String nameToLookup = <span class="keyword">this</span>.originalBeanName(name);</span><br><span class="line">          	<span class="comment">//注意下面是递归地去父工厂找</span></span><br><span class="line">            <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//如果不是仅仅做类检查则是创建bean,这里要进行记录</span></span><br><span class="line">        <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">            <span class="keyword">this</span>.markBeanAsCreated(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> RootBeanDefinition mbd = <span class="keyword">this</span>.getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            <span class="keyword">this</span>.checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line">            String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">            String[] var11;</span><br><span class="line">          	<span class="comment">//如果存在依赖,就递归地先去实例化依赖的bean</span></span><br><span class="line">            <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                var11 = dependsOn;</span><br><span class="line">                <span class="keyword">int</span> var12 = dependsOn.length;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> var13 = <span class="number">0</span>; var13 &lt; var12; ++var13) &#123;</span><br><span class="line">                    String dep = var11[var13];</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.isDependent(beanName, dep)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">this</span>.registerDependentBean(dep, beanName);</span><br><span class="line">                    <span class="keyword">this</span>.getBean(dep);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">              	<span class="comment">//单例模式的创建</span></span><br><span class="line">                sharedInstance = <span class="keyword">this</span>.getSingleton(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> AbstractBeanFactory.<span class="keyword">this</span>.createBean(beanName, mbd, args);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (BeansException var2) &#123;</span><br><span class="line">                            AbstractBeanFactory.<span class="keyword">this</span>.destroySingleton(beanName);</span><br><span class="line">                            <span class="keyword">throw</span> var2;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                bean = <span class="keyword">this</span>.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">              	<span class="comment">//原型模式的创建</span></span><br><span class="line">                var11 = <span class="keyword">null</span>;</span><br><span class="line">                Object prototypeInstance;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  	<span class="comment">//创建原型之前,先把prototypesCurrentlyInCreation里塞值,表示当前正在创建哪些原型</span></span><br><span class="line">                    <span class="keyword">this</span>.beforePrototypeCreation(beanName);</span><br><span class="line">                  	<span class="comment">//注意到createBean这个方法留给了子类去实现</span></span><br><span class="line">                    prototypeInstance = <span class="keyword">this</span>.createBean(beanName, mbd, args);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  	<span class="comment">//移出prototypesCurrentlyInCreation,表示创建这个原型结束</span></span><br><span class="line">                    <span class="keyword">this</span>.afterPrototypeCreation(beanName);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                bean = <span class="keyword">this</span>.getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              	<span class="comment">//其它模式的创建(指定的scope上实例化bean</span></span><br><span class="line">                String scopeName = mbd.getScope();</span><br><span class="line">                Scope scope = (Scope)<span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">                <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object scopedInstance = scope.get(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                            AbstractBeanFactory.<span class="keyword">this</span>.beforePrototypeCreation(beanName);</span><br><span class="line"></span><br><span class="line">                            Object var1;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                var1 = AbstractBeanFactory.<span class="keyword">this</span>.createBean(beanName, mbd, args);</span><br><span class="line">                            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">AbstractBeanFactory.<span class="keyword">this</span>.afterPrototypeCreation(beanName);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">return</span> var1;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    bean = <span class="keyword">this</span>.getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalStateException var21) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>, var21);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException var23) &#123;</span><br><span class="line">            <span class="keyword">this</span>.cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">            <span class="keyword">throw</span> var23;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; bean != <span class="keyword">null</span> &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123;</span><br><span class="line">      	<span class="comment">//检查类型是否符合bean的实际类型</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TypeMismatchException var22) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.debug(<span class="string">"Failed to convert bean '"</span> + name + <span class="string">"' to required type '"</span> + ClassUtils.getQualifiedName(requiredType) + <span class="string">"'"</span>, var22);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="提炼大致步骤"><a href="#提炼大致步骤" class="headerlink" title="提炼大致步骤"></a>提炼大致步骤</h4><p>这120多行的代码,Spring都并没有再进行重构,可见其复杂程度,辛亏有书本解释,了解到大致步骤:</p>
<ol>
<li><p>转换对应的beanName,因为传入的参数可能是alias</p>
<p>从其具体方法中看,是之前见过的, 处理<code>&amp;</code> 和别名的递归寻找本名.</p>
<p>去前面笔记中寻找,在 <a href="http://heeexy.com/2017/09/15/spring_SimpleAliasRegistry/">SimpleAliasRegistry</a> 中已经研究过此方法</p>
</li>
<li><p>尝试从缓存中加载单例</p>
<p>此时可能从缓存中取出的是还没创建好的bean,主要是因为防止循环依赖</p>
</li>
<li><p>bean的实例化</p>
<p>如果从缓存中得到了bean的原始状态,则需要对bean进行实例化.</p>
</li>
<li><p>原型模式的依赖检查</p>
</li>
<li><p>检测parentBeanFactory</p>
</li>
<li><p>将存储XML配置文件的GernericBeanDefinition转换为RootBeanDefinition</p>
</li>
<li><p>寻找依赖</p>
<p>因为bean的初始化过程中很可能会用到某些属性,而某些属性很可能是动态配置的,并且配置成依赖于其他的bean,那么这个时候就有必要先加载依赖的bean.</p>
</li>
<li><p><strong>针对不同的scope进行bean的创建</strong></p>
</li>
<li><p>类型转换</p>
<p>有可能有这种情况,返回的bean,是个String,但是requiredType传入的是Integer类型,那么这时候本步骤就会起作用了. Spring中提供了各种各样的转换器,用户也可以自己扩展转换器来满足需求</p>
</li>
</ol>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2017/09/19/custom_element/">Spring源码笔记-1.6 自定义标签的解析</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-09-19
        </span><span class="post-category">
            <a href="/categories/Spring%E7%AC%94%E8%AE%B0/">Spring笔记</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h2 id="自定义标签的使用"><a href="#自定义标签的使用" class="headerlink" title="自定义标签的使用"></a>自定义标签的使用</h2><p>主要内容都在书上,p80</p>
<p>关键的部分为 </p>
<ul>
<li>创建XSD文件</li>
<li>创建类 继承AbstractSingleBeanDefinitionParser  , 其继承关系最主要是实现了<code>BeanDefinitionParser</code> 接口,顾名思义,可以用来解析bean.</li>
<li>创建Handler文件, 继承自 NamespaceHandlerSupport ,目的是将上面的组件注册到Spring容器内</li>
<li>编写Spring.handlers  和 Spring.schemas文件.</li>
</ul>
<p>这样,自定义的配置就结束了.</p>
<p>Spring加载自定义bean的流程主要就是遇到自定义标签后就去Spring.handlers和Spring.schemas中取找对应的handler 和 XSD .从而可以拿到parser</p>
<p>而代码里的主要步骤为</p>
<ol>
<li>拿到标签对应的命名空间</li>
<li>根据命名空间找到对应的handler</li>
<li>调用handler的parse方法</li>
</ol>
<h2 id="获取标签的命名空间"><a href="#获取标签的命名空间" class="headerlink" title="获取标签的命名空间"></a>获取标签的命名空间</h2><p>调用org.w3c.dom.Node中的getNamespaceURI()</p>
<h2 id="提取自定义标签处理器"><a href="#提取自定义标签处理器" class="headerlink" title="提取自定义标签处理器"></a>提取自定义标签处理器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NamespaceHandler handler = <span class="keyword">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br></pre></td></tr></table></figure>

<p>这个resolve方法是接口,由DefaultNamespaceHandlerResolver 默认命名空间解析器来实现,其实现里面的第一步便是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; handlerMappings = <span class="keyword">this</span>.getHandlerMappings();</span><br></pre></td></tr></table></figure>

<p>原来<code>handlerMappings</code> 是个map,想必是在注册时肯定把解析器添加到这个map里面来,用namespaceUri做key,这样找的时候就很好找了.</p>
<p>取出结果如果是NamespaceHandler 便可以返回,往下读我们发现,之所以这么爽取出来就是handler,是因为已经做过这个解析,把找出的handler塞入了map,相当于是缓存了.</p>
<p>否则就是类名 className, 我们需要把它转为handler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用反射,将类路径转化为类</span></span><br><span class="line">Class&lt;?&gt; handlerClass = ClassUtils.forName(className, <span class="keyword">this</span>.classLoader);</span><br><span class="line">            <span class="keyword">if</span> (!NamespaceHandler<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">handlerClass</span>)) </span>&#123;</span><br><span class="line">                throw new FatalBeanException("Class [" + className + "] for namespace [" + namespaceUri + "] does not implement the [" + NamespaceHandler.class.getName() + "] interface");</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//初始化类</span></span><br><span class="line">                NamespaceHandler namespaceHandler = (NamespaceHandler)BeanUtils.instantiateClass(handlerClass);</span><br><span class="line">              <span class="comment">//调用类自定义的init()方法,这是所有handler都必须实现的方法</span></span><br><span class="line">                namespaceHandler.init();</span><br><span class="line">              <span class="comment">//塞入缓存</span></span><br><span class="line">                handlerMappings.put(namespaceUri, namespaceHandler);</span><br><span class="line">                <span class="keyword">return</span> namespaceHandler;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<h3 id="设计模式–单例模式"><a href="#设计模式–单例模式" class="headerlink" title="设计模式–单例模式"></a>设计模式–单例模式</h3><p>this.getHandlerMappings(); 获取handlerMapping处使用了单例模式</p>
<p>声明为volatile</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; handlerMappings;</span><br></pre></td></tr></table></figure>

<p>获取单例时使用双重检查锁定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title">getHandlerMappings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">//读取"META-INF/spring.handlers" 转为map</span></span><br><span class="line">                    Properties mappings = PropertiesLoaderUtils.loadAllProperties(<span class="keyword">this</span>.handlerMappingsLocation, <span class="keyword">this</span>.classLoader);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.logger.debug(<span class="string">"Loaded NamespaceHandler mappings: "</span> + mappings);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Map&lt;String, Object&gt; handlerMappings = <span class="keyword">new</span> ConcurrentHashMap(mappings.size());</span><br><span class="line">                    CollectionUtils.mergePropertiesIntoMap(mappings, handlerMappings);</span><br><span class="line">                    <span class="keyword">this</span>.handlerMappings = handlerMappings;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var5) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unable to load NamespaceHandler mappings from location ["</span> + <span class="keyword">this</span>.handlerMappingsLocation + <span class="string">"]"</span>, var5);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.handlerMappings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的volatile非常关键,如果没有的话,在<strong>初始化对象</strong> 和 <strong>设置handlerMapping指向内存空间</strong> 中间可能发生<strong>重排序</strong>,导致另外的线程拿到了handlerMapping的空间地址,但是其实还没有初始化完成.</p>
<h2 id="标签解析"><a href="#标签解析" class="headerlink" title="标签解析"></a>标签解析</h2><p>拿到解析器之后,就调用解析的parse方法,返回BeanDefinition</p>
<p>我们的自定义handler里面无需实现parse方法,在父类<code>NamespaceHandlerSupport</code>  中自有实现,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.findParserForElement(element, parserContext).parse(element, parserContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <img src="http://ots7yt7am.bkt.clouddn.com/blog/findParserForElement.png" alt=""></p>
<p>而parse方法主要步骤就是调用自己实现类的<code>parseInternal</code> 方法,<code>parseInternal</code> 方法除了调用我们实现的doParse方法之外,首先会进行一系列的数据准备,包括对beanClass.scope.lazyInit等属性的准备</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2017/09/19/other_default_elements/">Spring源码笔记-1.5 其它标签解析</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-09-19
        </span><span class="post-category">
            <a href="/categories/Spring%E7%AC%94%E8%AE%B0/">Spring笔记</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h2 id="本文要看啥"><a href="#本文要看啥" class="headerlink" title="本文要看啥"></a>本文要看啥</h2><p>之前我们看解析默认标签,从最核心的bean开始看的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delegate.nodeNameEquals(ele, <span class="string">"import"</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.importBeanDefinitionResource(ele);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, <span class="string">"alias"</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.processAliasRegistration(ele);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, <span class="string">"bean"</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.processBeanDefinition(ele, delegate);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, <span class="string">"beans"</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doRegisterBeanDefinitions(ele);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在主要就剩下alias和import啦, beans其实就是迭代解析.</p>
<h2 id="alias标签的解析"><a href="#alias标签的解析" class="headerlink" title="alias标签的解析"></a>alias标签的解析</h2><p>为bean定义别名,除了之前我们接触过的</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"testBean"</span> <span class="attr">name</span>=<span class="string">"aliasTestBean"</span> <span class="attr">class</span>=<span class="string">"com.test"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>还可以直接用alias标签</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"testBean"</span> <span class="attr">alias</span>=<span class="string">"aliasTestBean"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>解析步骤即使不看源码也知道很简单,因为之前我们已经深入研究过了<a href="http://heeexy.com/2017/09/15/spring_SimpleAliasRegistry/">SimpleAliasRegistry</a></p>
<ol>
<li>校验 name  alias 两个属性不能为空</li>
<li><code>this.getReaderContext().getRegistry().registerAlias(name, alias);</code> </li>
</ol>
<p>这个getRegistry() 然后registerAlias() 果然就是我们之前学过的<code>SimpleAliasRegistry</code> 里面的注册别名的方法.</p>
<h2 id="impory标签的解析"><a href="#impory标签的解析" class="headerlink" title="impory标签的解析"></a>impory标签的解析</h2><p>import标签和bean标签一样是我们最常见的标签,对于分模块管理配置文件很关键.</p>
<h4 id="解析步骤"><a href="#解析步骤" class="headerlink" title="解析步骤"></a>解析步骤</h4><ol>
<li><p>取出并校验<code>resource</code> 属性作为地址location</p>
</li>
<li><p>将地址中的系统属性   如 “${user.dir}”</p>
</li>
<li><p>判断location是绝对路径还是相对路径</p>
<ol>
<li><p>如果是,则</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">importCount = <span class="keyword">this</span>.getReaderContext().getReader().loadBeanDefinitions(location, actualResources);</span><br></pre></td></tr></table></figure>
</li>
<li><p>否则 </p>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Resource relativeResource = <span class="keyword">this</span>.getReaderContext().getResource().createRelative(location);</span><br><span class="line"><span class="keyword">if</span> (relativeResource.exists()) &#123;</span><br><span class="line">    importCount = <span class="keyword">this</span>.getReaderContext().getReader().loadBeanDefinitions(relativeResource);</span><br><span class="line">    actualResources.add(relativeResource);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    String baseLocation = <span class="keyword">this</span>.getReaderContext().getResource().getURL().toString();</span><br><span class="line">    importCount = <span class="keyword">this</span>.getReaderContext().getReader().loadBeanDefinitions(StringUtils.applyRelativePath(baseLocation, location), actualResources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>还是预留给拓展监听事件的位置.</li>
</ol>
<h4 id="关键步骤"><a href="#关键步骤" class="headerlink" title="关键步骤"></a>关键步骤</h4><h5 id="判断是否绝对路径"><a href="#判断是否绝对路径" class="headerlink" title="判断是否绝对路径"></a>判断是否绝对路径</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();</span><br></pre></td></tr></table></figure>

<p>isUrl : 以 classpath*:  开头    或者   classpath:  开头  或者  可以new URL(resourceLocation); 而不报错</p>
<p>ResourceUtils.toURI(location):    替换路径中空格为%20 后 new URI ,然后拿absolute属性</p>
<h5 id="加载bean"><a href="#加载bean" class="headerlink" title="加载bean"></a>加载bean</h5><p>其实最后都是调用在第一篇博文中我们就看过的 <code>loadBeanDefinitions</code> 方法</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2017/09/18/test_volatile_object/">test_volatile_object</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-09-18
        </span><span class="post-category">
            <a href="/categories/%E5%B9%B6%E5%8F%91/">并发</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h3 id="本文要看啥"><a href="#本文要看啥" class="headerlink" title="本文要看啥"></a>本文要看啥</h3><hr>
<p>先不细谈volatile的基本原理,在读(写)这篇文章时,都是假设我们已经粗略了解了一点volatile的原理和作用的,主要就是 “<u>读写都走主内存,保证任意线程对这个变量的可见性</u>“</p>
<p>在查看spring源码的时候,注意到spring在处理并发的操作List<String>时, 虽然对list使用了volatile, 然而向list里面添加元素时,用的还是新建一个list,复制全部旧值,增加新元素,然后将旧的list地址指向新的list.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">  updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">  updatedDefinitions.add(beanName);</span><br><span class="line">  <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br></pre></td></tr></table></figure>

<p>这么麻烦的操作,第一反应就是,volatile修饰的list, 直接添加元素<strong>依然不安全</strong>么?</p>
<p>去网上搜了一下相关问题, <a href="http://blog.csdn.net/u014108122/article/details/38173201" target="_blank" rel="noopener">参考博文地址</a> ,发现不止list, 对象也是一样的.</p>
<p>本文就是要来用代码直观地看看volatile 到底有什么效果,怎么用才有效果.</p>
<h3 id="开始代码吧"><a href="#开始代码吧" class="headerlink" title="开始代码吧"></a>开始代码吧</h3><hr>
<h4 id="线程共享对象里的boolean"><a href="#线程共享对象里的boolean" class="headerlink" title="线程共享对象里的boolean"></a>线程共享对象里的boolean</h4><p>注意代码要以<strong>-server模式</strong>运行，强制虚拟机开启优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileObjectTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加上volatile 就可以正常结束While循环了</span></span><br><span class="line">    <span class="keyword">private</span> ObjectA a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VolatileObjectTest</span><span class="params">(ObjectA a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a.setFlag(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (a.isFlag()) &#123;</span><br><span class="line">            i++;</span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">         	 注意这里的sysout,如果有调用的话,即使没有volatile,子线程也经常能拿到a.flag,</span></span><br><span class="line"><span class="comment">         	 结合后面的测试,发现sysout 或者 sysout(a.isFlag())之前有"---"之类字符串</span></span><br><span class="line"><span class="comment">         	 都可能让a去从主内存去获取值,影响我们测试的结果</span></span><br><span class="line"><span class="comment">         	 所以测试的时候不要乱打sysout了,感兴趣的话可以自己去各种测试一遍</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">            <span class="comment">// System.out.println();  </span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"子线程正常结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 注意代码要以-server模式运行，强制虚拟机开启优化</span></span><br><span class="line">        <span class="comment">// 如果启动的时候加上-server 参数则会 输出 Java HotSpot(TM) Server VM</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"java.vm.name"</span>));</span><br><span class="line">        VolatileObjectTest2 test = <span class="keyword">new</span> VolatileObjectTest2(<span class="keyword">new</span> ObjectA());</span><br><span class="line">        <span class="keyword">new</span> Thread(test).start();</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        test.stop();</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        System.out.println(<span class="string">"主线程结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectA</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.flag = flag;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码还是很简单, </p>
<p>主线程将a的flag改为false,</p>
<p>子线程能正常结束的话, 说明子线程里 a 的 flag值获取到了false,</p>
<p>不能正常结束的话, 说明子线程a一直都是用其本地内存里的flag值,一直都是true.</p>
<p>测试结果就是 </p>
<ol>
<li>有volatile 修饰的情况下, 子线程能拿到false值</li>
<li>没有volatile ,子线程无法正常结束</li>
</ol>
<p>在初步了解volatile 的可见性的情况下, 我会觉得这个结果很正常, 觉得自己掌握了volatile , 但是我们继续往下看…</p>
<h4 id="线程共享对象里的对象"><a href="#线程共享对象里的对象" class="headerlink" title="线程共享对象里的对象"></a>线程共享对象里的对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileObjectTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加上volatile 就可以正常结束While循环了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ObjectA a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VolatileObjectTest</span><span class="params">(ObjectA a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a.getObjectB().setFlag(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">        ObjectB b = a.getObjectB();</span><br><span class="line">        <span class="keyword">while</span> (b.isFlag()) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(b.isFlag());</span><br><span class="line">        System.out.println(a.getObjectB().isFlag());</span><br><span class="line">        System.out.println(<span class="string">"子线程正常结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 如果启动的时候加上-server 参数则会 输出 Java HotSpot(TM) Server VM</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"java.vm.name"</span>));</span><br><span class="line">        VolatileObjectTest test = <span class="keyword">new</span> VolatileObjectTest(<span class="keyword">new</span> ObjectA());</span><br><span class="line">        <span class="keyword">new</span> Thread(test).start();</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        test.stop();</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        System.out.println(<span class="string">"主线程结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectA</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">private</span> ObjectB objectB = <span class="keyword">new</span> ObjectB();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.flag = flag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ObjectB <span class="title">getObjectB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> objectB;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectB</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.flag = flag;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次在ObjectA内添加了一个成员变量ObjectB,我们在子线程中跳出循环需要ObjectB中的flag变为false;</p>
<p>实际测试时发现: </p>
<ol>
<li>无论ObjectA前有没有 volatile, 调用stop()方法都并不能正确终止子线程</li>
<li>成员变量ObjectB前添加volatile,同样不能正确终止子线程</li>
<li>ObjectB的flag前加volatile,可以终止子线程 (这是当然的啦…)</li>
<li>如果循环里用的是     <code>while (a.getObjectB().isFlag())</code>  , ObjectA前又有volatile的话, 这样还是可以终止子线程.</li>
</ol>
<p>测到这里,感觉这个博主给的例子是不是有问题啊,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObjectB b = a.getObjectB();</span><br><span class="line">       <span class="keyword">while</span> (b.isFlag()) &#123;</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>问题是出在这里提前从a里面取出了b么,b已经指向不同的内存地址了么?不应该吧…</p>
<p>稍加思考,第三种结果里,b.flag用volatile修饰后,就可以正常退出,说明b还是指向的a里面的b的地址啊,没毛病啊.</p>
<p>突然感觉更晕了,把原博的评论翻到底,发现还真有人评论到这个,从评论里又学到了很多东西.</p>
<h4 id="原博评论区的解疑"><a href="#原博评论区的解疑" class="headerlink" title="原博评论区的解疑"></a>原博评论区的解疑</h4><p>Q: 为什么sysout影响结果?</p>
<p>A: 如果在循环体内加一些语句,比如sysout或者new对象之类的稍微复杂而耗时的操作,就会发现就算没有volatile,线程同样可能被正常中断.因为<strong>经过高耗时操作之后,CPU会”怀疑人生”</strong>,单心自己对b.flag的缓存不是最新的,而去从主存获取.在这种情况下，线程会结束，只不过不及时而已。</p>
<p>Q: 为什么 while (b.isFlag()) 和while(a.getObjectB.isFlag()) 结果有区别,后者就可以拿到最新的flag值?</p>
<p>A: 一个volatile引用的域或者元素并不具备volatile特性，因为对于该域的写入并不会触发StoreLoad屏障，就<strong>不会强迫该域值立刻回写主存</strong>。不过其读特性并没有问题，<strong>对volatile的读操作一定是去主存当中读取的</strong>。</p>
<p>所以a.getObjectB 在这里a就已经去从主存中读取了.</p>
<p>这一点因此也就解释了第一个例子中,我们修改a.flag,可以正常地读到flag值.</p>
<p>Q: 但是问题又来了,写入不能保证刷新到主存的话,岂不是即使<code>while(a.getObjectB.isFlag())</code> 也是仍然很有可能失败的?经过刚才例子的反复测试,依然很难碰到终止线程失败的情况.</p>
<p>A: 这个例子还是无法测出这种刷新主存不及时的情况,毕竟即使是不及时刷新,最终刷新了还是可以让子线程结束的.</p>
<p><a href="http://ifeve.com/volatile-array-visiblity/" target="_blank" rel="noopener">另外一篇博客</a> 从汇编语句的角度分析了<strong>volatile的数组只针对数组的引用具有volatile的语义，而不是它的元素</strong> , 暂时只能记录下来,待以后再深入原理去理解.</p>
<h4 id="留下更多的疑惑"><a href="#留下更多的疑惑" class="headerlink" title="留下更多的疑惑"></a>留下更多的疑惑</h4><ol>
<li><p>如上面所说,一个volatile引用的域或者元素并不具备volatile特性，因为对于该域的写入并不会触发StoreLoad屏障，就<strong>不会强迫该域值立刻回写主存</strong>。 如何证明?</p>
</li>
<li><p>spring里用置换的方式真的不会出问题么? 多个线程同时读取了一个list,然后各自加一个元素进去,刷新,这样不就出了问题?</p>
</li>
<li><p>如果说这样并不安全,那么concurrent包里是怎么实现安全的list的呢?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock 貌似是安全了, 但是为什么这里也用了置换数组啊???</p>
<p>​</p>
</li>
</ol>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2017/09/15/spring_SimpleAliasRegistry/">SimpleAliasRegistry</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-09-15
        </span><span class="post-category">
            <a href="/categories/Spring%E7%AC%94%E8%AE%B0/">Spring笔记</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p>功能:注册/存放别名</p>
<p>唯一成员变量为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; aliasMap = <span class="keyword">new</span> ConcurrentHashMap(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>这Map&lt;String,String&gt; 其实key是alias,value是name. 刚开始没注意可能搞反了呢</p>
<h2 id="注册别名registerAlias"><a href="#注册别名registerAlias" class="headerlink" title="注册别名registerAlias()"></a>注册别名<code>registerAlias()</code></h2><hr>
<p>举例来说 我们要注册的beanName为<strong>myTestBean</strong> , 别名为<strong>mtb</strong></p>
<ol>
<li><p>校验name和alias都不为空</p>
</li>
<li><p>如果name和alias一样,那map里删了这条name,结束</p>
</li>
<li><p>依据alias 即 <strong>mtb</strong>去map里面取已注册的name,如果真的有已注册过的话:</p>
<ol>
<li><code>registeredName</code> 和<code>name</code>相等的话,那就不用管,结束.</li>
<li>如果他俩不相等,这个工厂又不允许重写alias,那就抛异常! (<code>allowAliasOverriding()</code> 这个方法在SimpleAliasRegistry的子类里面有的会被重写.</li>
</ol>
</li>
<li><p>如果前面都通过了,<code>this.checkForAliasCircle(name, alias);</code> 再次循环检查一遍,判断是否<code>hasAlias()</code>,如果是true的话,就报错,不是的话,走第5步. 具体<code>hasAlias()</code>流程如下:</p>
<ol>
<li>循环找出<code>registeredName</code> 为<strong>myTestBean</strong>的那组键值对 (这里和上面的遍历不一样哦,这里是根据直接找重复的beanName的,上面是找重复的alias的</li>
<li>如果这个键值对的key即alias也是等于<strong>mtb</strong>的话,报错 (但是实际我们这第三步也查过这种情况)</li>
<li>如果这个myTestBean找出来的alias是”myTB”,那就还要走一遍<code>hasAlias(&quot;myTB&quot;,&quot;mtb&quot;)</code> ,换句话说,就是要看一看是不是有哪个bean名字叫myTB,别名叫mtb的,如果真的有,就返回true</li>
</ol>
<p>第四步的<code>hasAlias()</code> 这种判断是啥意思呢?</p>
<p>想注册 mtb–myTestBean  (别名–本名)</p>
<p>如果已存在 mtb–myTestBean ,那么返回true</p>
<p>如果已存在         myTB–myTestBean, </p>
<p>​    且存在 mtb–myTB ,</p>
<p>那就构成了 <strong>mtb–myTB–myTestBean</strong> 也返回true</p>
<p>如果已存在                       myTB–myTestBean, </p>
<p>​    且存在                mta–myTB </p>
<p>​    且存在         mtb–mta ,</p>
<p>那就构成了 <strong>mtb–mta–myTB–myTestBean</strong> 还是返回true</p>
<p>.</p>
<p>这下看明白了吧,</p>
<p>说明hasAlias()方法不止判断mtb是否已经做了myTestBean的别名,</p>
<p>还判断了mtb是不是myTestBean的别名 的别名 的别名 的别名 的别名….最终能通过一条线导向myTestBean</p>
</li>
<li><p>如果前面各种校验全部通过 ,<code>this.aliasMap.put(alias, name);</code> 很简单,map里面塞值吧!</p>
</li>
</ol>
<p>前面校验看着很啰嗦,其实总结起来都很简单</p>
<ol>
<li>键值都不能为空</li>
<li>别键值相等,我会删了这个别名的(虽然你应该本来就添加不进来)</li>
<li>别名已用过,如果还是原name,那不用操作</li>
<li>别名已用过,这次换了新name,那就看你注册器允不允许我搞覆盖咯</li>
<li>别告诉我这个alias居然还是那个name的别名的别名…</li>
</ol>
<p>第5种的情况让我突然想到,这种连环关系应该连申请都申请不了吧,即使真的想搞出连环关系,也应该是下面这种情况吧??</p>
<p><strong>myTB–myTestBean已注册好了,新来个bean想注册beanName叫myTB</strong> </p>
<p>应该在申请注册beanName叫myTB的时候就<strong>校验过了吧</strong>!!!</p>
<p>好,翻回去找找注册beanName的时候,是不是已经校验过不能和已注册的alias重名!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">    String id = ele.getAttribute(<span class="string">"id"</span>);</span><br><span class="line">    String nameAttr = ele.getAttribute(<span class="string">"name"</span>);</span><br><span class="line">  <span class="comment">//都忘掉了bean原本没有alias属性了......</span></span><br><span class="line">  <span class="comment">//aliases数组是原本的name里面的多个值</span></span><br><span class="line">  <span class="comment">//除非之前没id,有name, 那么从aliases里remove(0)出去做beanName,剩下的继续做alias</span></span><br><span class="line">    List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">        String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, <span class="string">",; "</span>);</span><br><span class="line">        aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String beanName = id;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(id) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">        beanName = (String)aliases.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.debug(<span class="string">"No XML 'id' specified - using '"</span> + beanName + <span class="string">"' as bean name and "</span> + aliases + <span class="string">" as aliases"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">         <span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//在这里校验一波beanName和alias的唯一性</span></span><br><span class="line">            <span class="keyword">this</span>.checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">        &#125;</span><br><span class="line">    ....</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//校验重名的方法</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkNameUniqueness</span><span class="params">(String beanName, List&lt;String&gt; aliases, Element beanElement)</span> </span>&#123;</span><br><span class="line">        String foundName = <span class="keyword">null</span>;</span><br><span class="line">     <span class="comment">//看已用名里是否包括了beanName</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(beanName) &amp;&amp; <span class="keyword">this</span>.usedNames.contains(beanName)) &#123;</span><br><span class="line">            foundName = beanName;</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="comment">//看已用名里是否用过了这些alias</span></span><br><span class="line">        <span class="keyword">if</span> (foundName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            foundName = (String)CollectionUtils.findFirstMatch(<span class="keyword">this</span>.usedNames, aliases);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (foundName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.error(<span class="string">"Bean name '"</span> + foundName + <span class="string">"' is already used in this &lt;beans&gt; element"</span>, beanElement);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//注意这个地方, beanName和aliases都是全部加入usedNames的</span></span><br><span class="line">     <span class="comment">//那就说明,在前面校验的时候,已用名就是包括已用beanName和已用alias的</span></span><br><span class="line">     <span class="comment">//所以如果myTB--myTestBean已注册好了,myTB和myTestBean都被usedName收录了</span></span><br><span class="line">     <span class="comment">//再想拿myTB做beanName肯定不行了</span></span><br><span class="line">        <span class="keyword">this</span>.usedNames.add(beanName);</span><br><span class="line">        <span class="keyword">this</span>.usedNames.addAll(aliases);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>所以其实是校验过的啊,感觉上面考虑的第5种情况有点多此一举呢…</p>
<p>还是来看看类里面的其它方法吧</p>
<h2 id="取消注册别名removeAlias"><a href="#取消注册别名removeAlias" class="headerlink" title="取消注册别名removeAlias()"></a>取消注册别名<code>removeAlias()</code></h2><hr>
<p>很简单,map直接remove这个别名,如果remove结果是null,那抛个异常</p>
<h2 id="判断是否为别名-isAlias"><a href="#判断是否为别名-isAlias" class="headerlink" title="判断是否为别名 isAlias()"></a>判断是否为别名 <code>isAlias()</code></h2><hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.aliasMap.containsKey(name);</span><br></pre></td></tr></table></figure>

<h2 id="获取某个name的所有别名-getAliases-String-name"><a href="#获取某个name的所有别名-getAliases-String-name" class="headerlink" title="获取某个name的所有别名 getAliases(String name)"></a>获取某个name的所有别名 <code>getAliases(String name)</code></h2><hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加了个同步,</span></span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>.aliasMap) &#123;</span><br><span class="line">    <span class="keyword">this</span>.retrieveAliases(name, result);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">retrieveAliases</span><span class="params">(String name, List&lt;String&gt; result)</span> </span>&#123;</span><br><span class="line">        Iterator var3 = <span class="keyword">this</span>.aliasMap.entrySet().iterator();</span><br><span class="line">		<span class="comment">//遍历map,找出value等于这个name的key</span></span><br><span class="line">        <span class="keyword">while</span>(var3.hasNext()) &#123;</span><br><span class="line">            Entry&lt;String, String&gt; entry = (Entry)var3.next();</span><br><span class="line">            String registeredName = (String)entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (registeredName.equals(name)) &#123;</span><br><span class="line">                String alias = (String)entry.getKey();</span><br><span class="line">                result.add(alias);</span><br><span class="line">              <span class="comment">//注意这里,厉害了,居然还真的递归地去找它的别名的别名(的别名的别名...)</span></span><br><span class="line">              <span class="comment">//到底什么地方能制造出链式的别名啊啊啊啊????</span></span><br><span class="line">                <span class="keyword">this</span>.retrieveAliases(alias, result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p> 另外注意到,getAliases()方法在AbstractBeanFactory其实是有重写的啊,稍后去看看!</p>
<h2 id="找本名canonicalName"><a href="#找本名canonicalName" class="headerlink" title="找本名canonicalName()"></a>找本名<code>canonicalName()</code></h2><hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">canonicalName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    String canonicalName = name;</span><br><span class="line">    String resolvedName;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        resolvedName = (String)<span class="keyword">this</span>.aliasMap.get(canonicalName);</span><br><span class="line">        <span class="keyword">if</span> (resolvedName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            canonicalName = resolvedName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(resolvedName != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> canonicalName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法很简单,就是一层一层地去找这个名字的本名.</p>
<h2 id="AbstractBeanFactory-对getAliases-的重写"><a href="#AbstractBeanFactory-对getAliases-的重写" class="headerlink" title="AbstractBeanFactory 对getAliases() 的重写"></a><code>AbstractBeanFactory</code> 对<code>getAliases()</code> 的重写</h2><hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] getAliases(String name) &#123;</span><br><span class="line">  <span class="comment">//找到这个name的真正的beanName, </span></span><br><span class="line">  <span class="comment">//transformedBeanName里面的操作主要是去除头部所有&amp;符号,以及调用上面的canonicalName()来找本名</span></span><br><span class="line">    String beanName = <span class="keyword">this</span>.transformedBeanName(name);</span><br><span class="line">    List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> factoryPrefix = name.startsWith(<span class="string">"&amp;"</span>);</span><br><span class="line">    String fullBeanName = beanName;</span><br><span class="line">    <span class="keyword">if</span> (factoryPrefix) &#123;</span><br><span class="line">  	  <span class="comment">//如果原name以&amp;开头(可能多个&amp;),表示工厂前缀</span></span><br><span class="line">      <span class="comment">//bean全名就加上一个&amp;</span></span><br><span class="line">        fullBeanName = <span class="string">"&amp;"</span> + beanName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fullBeanName.equals(name)) &#123;</span><br><span class="line">      <span class="comment">//如果bean全名还不等于原名, 说明原名可能是 &amp;&amp;&amp;myTestBean</span></span><br><span class="line">      <span class="comment">//那么把&amp;myTestBean也作为它的一个别名</span></span><br><span class="line">        aliases.add(fullBeanName);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//调用上面我们SimpleAliasRegistry的方法</span></span><br><span class="line">    String[] retrievedAliases = <span class="keyword">super</span>.getAliases(beanName);</span><br><span class="line">    String[] var7 = retrievedAliases;</span><br><span class="line">    <span class="keyword">int</span> var8 = retrievedAliases.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> var9 = <span class="number">0</span>; var9 &lt; var8; ++var9) &#123;</span><br><span class="line">        String retrievedAlias = var7[var9];</span><br><span class="line">      <span class="comment">//如果是工厂bean,配上工厂前缀&amp;</span></span><br><span class="line">        String alias = (factoryPrefix ? <span class="string">"&amp;"</span> : <span class="string">""</span>) + retrievedAlias;</span><br><span class="line">        <span class="keyword">if</span> (!alias.equals(name)) &#123;</span><br><span class="line">          <span class="comment">//只要不等于我们的name,通通可以做为别名 </span></span><br><span class="line">          aliases.add(alias);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果这个beanName对应的bean不是单例,并且这个beanName还没注册bean</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.containsSingleton(beanName) &amp;&amp; !<span class="keyword">this</span>.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">        BeanFactory parentBeanFactory = <span class="keyword">this</span>.getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//并且它还有父工厂,那就从它的父工厂里面找&amp;myTestBean的别名 ,都算进来是它的别名</span></span><br><span class="line">            aliases.addAll(Arrays.asList(parentBeanFactory.getAliases(fullBeanName)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> StringUtils.toStringArray(aliases);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这个方法看得还不是很明白,但大概知道,这里的重写主要是牵扯到了这个bean的工厂相关属性,待后面了解了工厂应该就能清楚这里的别名与工厂的关系了.</p>
<h2 id="解析别名resolveAliases-StringValueResolver-valueResolver"><a href="#解析别名resolveAliases-StringValueResolver-valueResolver" class="headerlink" title="解析别名resolveAliases(StringValueResolver valueResolver)"></a>解析别名<code>resolveAliases(StringValueResolver valueResolver)</code></h2><hr>
<p>这里的入参需要传个值解析器,</p>
<p>加锁,复制出map,遍历map,拿到alias,registeredName, 以及,用解析器解析后的resolvedAlias,resolvedName</p>
<p>如果解析后的别名,本名有一者为空,或者二者相等,那么就要从map里移除这个alias,说明这个alias多余了,没作用.</p>
<p>否则 </p>
<ol>
<li><p>如果解析后别名和解析前别名一致,那么把解析前别名 alias指向解析后的本名,resolvedName (这里就直接覆盖掉原alias的映射了</p>
</li>
<li><p>如果解析后别名和解析前不一致</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先找找解析后别名是不是在map里有映射</span></span><br><span class="line">String existingName = (String)<span class="keyword">this</span>.aliasMap.get(resolvedAlias);</span><br><span class="line">                        <span class="keyword">if</span> (existingName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                          <span class="comment">//如果有的话,并且还指向了其它值,那就要抛异常了</span></span><br><span class="line">                            <span class="keyword">if</span> (!existingName.equals(resolvedName)) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot register resolved alias '"</span> + resolvedAlias + <span class="string">"' (original: '"</span> + alias + <span class="string">"') for name '"</span> + resolvedName + <span class="string">"': It is already registered for name '"</span> + registeredName + <span class="string">"'."</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">						<span class="comment">//否则直接从map里移除原来的alias别名就够了</span></span><br><span class="line">                            <span class="keyword">this</span>.aliasMap.remove(alias);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">					<span class="comment">//注册解析后的别名--解析后的本名</span></span><br><span class="line">                        <span class="keyword">this</span>.checkForAliasCircle(resolvedName, resolvedAlias);</span><br><span class="line">					<span class="comment">//注意到这里和普通注册唯一的区别就是这里还要移除原alias</span></span><br><span class="line">                        <span class="keyword">this</span>.aliasMap.remove(alias);</span><br><span class="line">                        <span class="keyword">this</span>.aliasMap.put(resolvedAlias, resolvedName);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>所以总结一下这个处理解析Aliases的目的</p>
<p>遍历map,每个键值对都解析一遍,</p>
<p>如果这对能解析出新的一对合法别名–本名键值对,那么就把之前的那对删掉,注册新的这个解析后的一对,</p>
<p>此外检验下解析后的别名是不是被占用,如果占用了还指向错了值,就抛异常,</p>
<p>如果占用了也是指向解析后名字,那就说明解析后的这对已经注册好了,只需删掉旧的那对</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2017/09/15/registerBeanDefinition/">Spring源码笔记-1.4 获取bean流程之注册BeanDefinition</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-09-15
        </span><span class="post-category">
            <a href="/categories/Spring%E7%AC%94%E8%AE%B0/">Spring笔记</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h3 id="本文要看啥"><a href="#本文要看啥" class="headerlink" title="本文要看啥"></a>本文要看啥</h3><hr>
<p>这个bean总算是解析完了,也装饰完了,等于是说信息我们都提取好了,现在该做的就是去注册啦.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, <span class="keyword">this</span>.getReaderContext().getRegistry());</span><br></pre></td></tr></table></figure>

<p>就是这个方法了</p>
<h3 id="开始进入方法吧"><a href="#开始进入方法吧" class="headerlink" title="开始进入方法吧"></a>开始进入方法吧</h3><hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    String beanName = definitionHolder.getBeanName();</span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line">    String[] aliases = definitionHolder.getAliases();</span><br><span class="line">    <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String[] var4 = aliases;</span><br><span class="line">        <span class="keyword">int</span> var5 = aliases.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var6 = <span class="number">0</span>; var6 &lt; var5; ++var6) &#123;</span><br><span class="line">            String alias = var4[var6];</span><br><span class="line">            registry.registerAlias(beanName, alias);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>拿到beanName</p>
</li>
<li><p>用beanName和bd去registry里注册.</p>
<blockquote>
<p>registry是个接口,具体的实现在4.3.7版本中看到两种,一种是SimpleBeanDefinitionRegistry里,和它名字一样非常简单,就是塞进map, 另外一种就复杂了,稍后我们再来看</p>
</blockquote>
</li>
<li><p>用beanName和alias去registry里注册</p>
<blockquote>
<p>注册aliases也是接口 ,BeanDefinitionRegistry还是继承自AliasRegistry的, 4.3.7只看到SimpleAliasRegistry一种实现</p>
</blockquote>
<p>注册alias就简单多了, SimpleAliasRegistry里有</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; aliasMap = <span class="keyword">new</span> ConcurrentHashMap(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>稍后我再另开一文把SimpleAliasRegistry来读一遍</p>
</li>
</ol>
<h3 id="注册BeanDefinitionHolder"><a href="#注册BeanDefinitionHolder" class="headerlink" title="注册BeanDefinitionHolder"></a>注册BeanDefinitionHolder</h3><hr>
<p>除了之前的<code>SimpleBeanDefinitionRegistry</code> 直接往map里面塞值的注册方式之外,我们还有DefaultListableBeanFactory 这个类来实现注册功能,我们主要来了解一下这种注册方式</p>
<ol>
<li><p>校验空参数</p>
</li>
<li><p>如果bdh是<code>AbstractBeanDefinition</code> ,那就要执行它的<code>validate()</code> 校验</p>
<ol>
<li>bdh的methodOverride和它的工厂<strong>不能同时存在</strong></li>
<li>如果它beanClass有值,那就要为方法覆盖做准备 <code>prepareMethodOverrides()</code>  ,遍历它的overrides,找这个Bean的Class里面有几个叫这个名字的方法, <strong>如果0个,就抛错</strong>,如果1个,就设置重载属性为false表示没重载.</li>
</ol>
</li>
<li><p>从这个工厂里面<code>beanDefinitionMap</code> 拿原来的叫这个beanName的bd出来,如果不为空,进行下列校验及操作</p>
<blockquote>
<p>书中源码spring 3.2 采用sychronized , 而4.3版本的beanDefinitionMap已经用上了ConcurrentHashMap,并且map的value用了BD,而不是3.2里面的Object</p>
</blockquote>
<ol>
<li>如果工厂不允许bean覆盖,那么抛错</li>
<li>如果旧bean的role值小于新的,或者新旧bd完全相等,或者不相等,各打印一下日志</li>
<li>把新的bd放入<code>beanDefinitionMap</code> </li>
</ol>
</li>
<li><p>第一次注册这个bean, 如果本工厂的<code>alreadyCreated</code> 也是空的话,那就不用加锁,直接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//map里塞入bd				</span></span><br><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line"> <span class="comment">//已注册名字里加入beanName              </span></span><br><span class="line"><span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line"> <span class="comment">//唯一名册里移出beanName(啥时候加入了???)              </span></span><br><span class="line"><span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br></pre></td></tr></table></figure>

<p>如果本工程已经有创建过bean了,那么接下来一段代码就要加synchronized了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Map var4 = <span class="keyword">this</span>.beanDefinitionMap;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">   <span class="comment">//map里塞入bd		</span></span><br><span class="line">    <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">  <span class="comment">//注意到后面这段操作其实是新建个数组,加上这次注册beanName,然后替换之前的数组....</span></span><br><span class="line">  <span class="comment">//为什么这么复杂呢???</span></span><br><span class="line">    List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">    updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">    updatedDefinitions.add(beanName);</span><br><span class="line">    <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">  <span class="comment">//如果唯一名册里包含beanName</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">      <span class="comment">//就移出去,但是这里也和上面一样,搞替换....</span></span><br><span class="line">        Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">        updatedSingletons.remove(beanName);</span><br><span class="line">        <span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>疑问: 这里都用了替换,明明<code>beanDefinitionNames</code> 和<code>manualSingletonNames</code> 都是volatile声明的,每次读都从主内存取,每次写都都将值写到主内存, 这里为什么还要这么麻烦得去开新的list和set,替换旧的呢?</p>
<p>答:从网上搜到,volatile修饰的变量如果是对象或数组之类的，其含义是对象或数组的<strong>地址具有可见性</strong>，但是数组或对象<strong>内部的成员改变不具备可见性</strong>,那等于就是说非得整个地址替换才行咯.</p>
<p>很爽,从这本书要跳到我正在读的并发编程相关的内容了,这几天再去研究一波volatile,可以再开一文. <a href="http://blog.csdn.net/u014108122/article/details/38173201" target="_blank" rel="noopener">准备参考地址</a></p>
</blockquote>
</li>
</ol>
<p>然后<code>this.frozenBeanDefinitionNames = null;</code>  这个冻结/取消冻结bdNames的功能暂时也不知道干啥的,在注册和删除bd的地方看到了这样的置为null, </p>
<p>​    只在<code>freezeConfiguration()</code> 方法内看到把它置为bdNames转的String[] .</p>
<p>​    另外在<code>getBeanDefinitionNames()</code> 方法里有判断这个</p>
<p>然后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果有老bd或者 这个bean是单例对象?</span></span><br><span class="line"><span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span> || <span class="keyword">this</span>.containsSingleton(beanName)) &#123;</span><br><span class="line">  <span class="comment">//重置bean</span></span><br><span class="line">            <span class="keyword">this</span>.resetBeanDefinition(beanName);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>重置的主要内容有</p>
<ul>
<li>清除mergedBD </li>
<li>销毁单例</li>
<li>遍历之前的bean,看新注册的这个bean是谁的爹(parent),那些儿子也都要调用这个方法进行重置</li>
</ul>
<blockquote>
<p>不得不说这个<code>DefaultListableBeanFactory</code> 的成员变量实在太多了,搞不清楚一个个都是要干啥的,后面再次遇到的时候再慢慢看吧</p>
</blockquote>
<h3 id="注册Alias"><a href="#注册Alias" class="headerlink" title="注册Alias"></a>注册Alias</h3><hr>
<p>4.3.7版本的实现在<code>SimpleAliasRegistry</code> 里, 详情见 <a href="/2017/09/15/spring_SimpleAliasRegistry/">这一篇博文</a></p>
<h3 id="注册完成"><a href="#注册完成" class="headerlink" title="注册完成"></a>注册完成</h3><hr>
<p>其实没有操作了, 但是作者留了个位置在这</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br></pre></td></tr></table></figure>

<p>如果程序开发人员需要对注册BeanDefinition时间进行监听时,可以通过注册监听器的方式来做.Spring并没有再此做任何逻辑处理</p>
<h3 id="告一段落"><a href="#告一段落" class="headerlink" title="告一段落"></a>告一段落</h3><hr>
<p>至此,我们的解析注册Bean标签可算是告一段落啦,虽然里面还留下了很多疑问待后续阅读中弄清.</p>
<p>先想想之前是在哪分叉出去的吧.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (delegate.nodeNameEquals(ele, <span class="string">"import"</span>)) &#123;</span><br><span class="line">           <span class="keyword">this</span>.importBeanDefinitionResource(ele);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, <span class="string">"alias"</span>)) &#123;</span><br><span class="line">           <span class="keyword">this</span>.processAliasRegistration(ele);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, <span class="string">"bean"</span>)) &#123;</span><br><span class="line">         <span class="comment">//就是这里啦,我们先去阅读最复杂的bean的</span></span><br><span class="line">           <span class="keyword">this</span>.processBeanDefinition(ele, delegate);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, <span class="string">"beans"</span>)) &#123;</span><br><span class="line">         <span class="comment">//这个地方我还记得,beans标签是绕回去解析的,不用看了</span></span><br><span class="line">           <span class="keyword">this</span>.doRegisterBeanDefinitions(ele);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>再之前呢,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        NodeList nl = root.getChildNodes();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); ++i) &#123;</span><br><span class="line">            Node node = nl.item(i);</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                Element ele = (Element)node;</span><br><span class="line">                <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                  <span class="comment">//就是这个地方,差不多想起来了,beans标签里面的子元素, 如果是默认命名空间,就按默认方式去解析</span></span><br><span class="line">                    <span class="keyword">this</span>.parseDefaultElement(ele, delegate);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//这里是个分叉,解析自定义元素,以后再看</span></span><br><span class="line">                    delegate.parseCustomElement(ele);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//这和上面一样的分叉,解析自定义元素</span></span><br><span class="line">        delegate.parseCustomElement(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再之前呢</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">    BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">    <span class="keyword">this</span>.delegate = <span class="keyword">this</span>.createDelegate(<span class="keyword">this</span>.getReaderContext(), root, parent);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        String profileSpec = root.getAttribute(<span class="string">"profile"</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(profileSpec, <span class="string">",; "</span>);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.logger.info(<span class="string">"Skipped XML bean definition file due to specified profiles ["</span> + profileSpec + <span class="string">"] not matching: "</span> + <span class="keyword">this</span>.getReaderContext().getResource());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.preProcessXml(root);</span><br><span class="line">    <span class="comment">//从这里走出去的</span></span><br><span class="line">    <span class="keyword">this</span>.parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">    <span class="keyword">this</span>.postProcessXml(root);</span><br><span class="line">    <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 到这还要温习一遍的话,可以去看Spring的<a href="/2017/09/11/spring_note_1/">第一篇笔记</a>了</p>
<p>哈哈,这么点东西,读了一个礼拜,读了后面的忘了前面的,还是在读读记记的情况下,</p>
<p>要是没有这个笔记,这时候估计已经迷路得要放弃了,不容易啊</p>
<p>不说了 <a href="/2017/09/15/spring_SimpleAliasRegistry/">SimpleAliasRegistry</a> 和<code>volatile</code> 两篇文章的坑还留着呢,继续…</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2017/09/15/spring_note_3/">Spring源码笔记-1.3 获取bean流程之解析bean标签中的自定义标签元素</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-09-15
        </span><span class="post-category">
            <a href="/categories/Spring%E7%AC%94%E8%AE%B0/">Spring笔记</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h3 id="本文要看啥"><a href="#本文要看啥" class="headerlink" title="本文要看啥"></a>本文要看啥</h3><hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, <span class="keyword">this</span>.getReaderContext().getRegistry());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeanDefinitionStoreException var5) &#123;</span><br><span class="line">            <span class="keyword">this</span>.getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> + bdHolder.getBeanName() + <span class="string">"'"</span>, ele, var5);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面的笔记中,我们已经走完了这个方法中的第一步,感觉第一步就走了很远,眼瞅要迷路了,但无论如何,总归是拿到了我们的bdHolder, 里面已经存放了Bean标签里面的默认的元素.</p>
<p>如果bdHolder不为空的话,我们可以继续往下走啦.</p>
<p>今天来研究下这段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br></pre></td></tr></table></figure>

<p>看方法名字就大概知道,这里要做的事情就是 如果有需要的话,装饰我们刚拿到的bdHolder.</p>
<p>那么何为需要呢?下面这样的场景便是了</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">class</span>=<span class="string">"test.myClass"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mybean:user</span> <span class="attr">username</span>=<span class="string">"aaa"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的自定义标签和</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/img/**"</span> <span class="attr">location</span>=<span class="string">"img/"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"transactionAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>并不同,这里的是在bean内的, 而mvc那种标签是在beans里面,与bean同级的</p>
<h3 id="开始进入方法吧"><a href="#开始进入方法吧" class="headerlink" title="开始进入方法吧"></a>开始进入方法吧</h3><hr>
<p>这次要看的主要方法就是 <strong>decorateBeanDefinitionIfRequired</strong></p>
<p>这个方法主要是拆开我们之前的bean,将其各属性和各子节点全部变为node,</p>
<p>然后带着每个node和之前的bd去  <strong>decorateIfRequired</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">decorateIfRequired</span><span class="params">(Node node, BeanDefinitionHolder originalDef, BeanDefinition containingBd)</span> </span>&#123;</span><br><span class="line">      String namespaceUri = <span class="keyword">this</span>.getNamespaceURI(node);</span><br><span class="line">    <span class="comment">//看看是不是默认命名空间, 如果是的话那就不用管了, 在这方法里,我们只需处理自定义的标签</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.isDefaultNamespace(namespaceUri)) &#123;</span><br><span class="line">        <span class="comment">//拿到这个命名空间的解析器 handler</span></span><br><span class="line">          NamespaceHandler handler = <span class="keyword">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">        <span class="comment">//如果能找到解析器,我们就可以进入装饰方法啦</span></span><br><span class="line">          <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> handler.decorate(node, originalDef, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br><span class="line">          &#125;</span><br><span class="line"><span class="comment">//以下都是没找到解析器的</span></span><br><span class="line">        <span class="comment">//命名空间不为null,而且还以spring家的网址开头,那就报错表示找不到spring解析器</span></span><br><span class="line">          <span class="keyword">if</span> (namespaceUri != <span class="keyword">null</span> &amp;&amp; namespaceUri.startsWith(<span class="string">"http://www.springframework.org/"</span>)) &#123;</span><br><span class="line">              <span class="keyword">this</span>.error(<span class="string">"Unable to locate Spring NamespaceHandler for XML schema namespace ["</span> + namespaceUri + <span class="string">"]"</span>, node);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">         <span class="comment">//如果能打日志的话,打个日志完事   </span></span><br><span class="line">              <span class="keyword">this</span>.logger.debug(<span class="string">"No Spring NamespaceHandler found for XML schema namespace ["</span> + namespaceUri + <span class="string">"]"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> originalDef;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>具体的用handler解析node会在后面详细学习,这个就先到这吧!</p>
<blockquote>
<p>前面几篇文章都长得没法看了…吸取教训 篇幅尽量不要太长了.</p>
</blockquote>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2017/09/14/spring_note_3_ConstructorArgumentValues/">ConstructorArgumentValues 构造器参数值保存器</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-09-14
        </span><span class="post-category">
            <a href="/categories/Spring%E7%AC%94%E8%AE%B0/">Spring笔记</a>
            </span>
        </div>
    </header>

    <div class="post-content"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, ConstructorArgumentValues.ValueHolder&gt; indexedArgumentValues = <span class="keyword">new</span> LinkedHashMap(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;ConstructorArgumentValues.ValueHolder&gt; genericArgumentValues = <span class="keyword">new</span> LinkedList();</span><br></pre></td></tr></table></figure>

<p>这个保存器的核心就在他的LinkedHashMap和LinkedList</p>
<blockquote>
<p><strong>疑问: 这里为什么选用linked来储存呢?</strong></p>
<p>答:</p>
</blockquote>
<p>添加有index的关键代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addOrMergeIndexedArgumentValue</span><span class="params">(Integer key, ConstructorArgumentValues.ValueHolder newValue)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//拿当前这个位置的值</span></span><br><span class="line">      ConstructorArgumentValues.ValueHolder currentValue = (ConstructorArgumentValues.ValueHolder)<span class="keyword">this</span>.indexedArgumentValues.get(key);</span><br><span class="line">    <span class="comment">//如果当前位置有值,并且新值是接受合并的话,那合并一波之后作为新值</span></span><br><span class="line">    <span class="comment">//如果不接受合并的话,那扔了之前的value不管了,只用新来的value</span></span><br><span class="line">      <span class="keyword">if</span> (currentValue != <span class="keyword">null</span> &amp;&amp; newValue.getValue() <span class="keyword">instanceof</span> Mergeable) &#123;</span><br><span class="line">          Mergeable mergeable = (Mergeable)newValue.getValue();</span><br><span class="line">          <span class="keyword">if</span> (mergeable.isMergeEnabled()) &#123;</span><br><span class="line">              newValue.setValue(mergeable.merge(currentValue.getValue()));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//将新值放入LinkedHashMap</span></span><br><span class="line">      <span class="keyword">this</span>.indexedArgumentValues.put(key, newValue);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>疑问:在获取vh之前我们不就验证过index不能重复么?为什么这里还有可能搞一波合并?是有其它地方也调用这个方法,那里可以合并?</strong></p>
<p>答: 注意到这个类里有个方法,addArgumentValues(ConstructorArgumentValues other),貌似就是专门和其它CAV搞合并的,用CAV做构造参数的那个构造器调用了此方法,这里会有可能需要合并</p>
</blockquote>
<p>添加没有index的参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addGenericArgumentValue</span><span class="params">(ConstructorArgumentValues.ValueHolder newValue)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//校验不为空</span></span><br><span class="line">    Assert.notNull(newValue, <span class="string">"ValueHolder must not be null"</span>);</span><br><span class="line">  <span class="comment">//如果list内已经含有此value则跳过</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.genericArgumentValues.contains(newValue)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.addOrMergeGenericArgumentValue(newValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加或合并VH</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addOrMergeGenericArgumentValue</span><span class="params">(ConstructorArgumentValues.ValueHolder newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (newValue.getName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Iterator it = <span class="keyword">this</span>.genericArgumentValues.iterator();</span><br><span class="line">		<span class="comment">//如果新VH有name,那么就要遍历之前的list,找出同名的老VH</span></span><br><span class="line">        <span class="comment">//看新VH接不接受合并,接收就合并下再删,不接受就直接删掉.</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">            ConstructorArgumentValues.ValueHolder currentValue = (ConstructorArgumentValues.ValueHolder)it.next();</span><br><span class="line">            <span class="keyword">if</span> (newValue.getName().equals(currentValue.getName())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (newValue.getValue() <span class="keyword">instanceof</span> Mergeable) &#123;</span><br><span class="line">                    Mergeable mergeable = (Mergeable)newValue.getValue();</span><br><span class="line">                    <span class="keyword">if</span> (mergeable.isMergeEnabled()) &#123;</span><br><span class="line">                        newValue.setValue(mergeable.merge(currentValue.getValue()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//将新VH塞入list里面</span></span><br><span class="line">    <span class="keyword">this</span>.genericArgumentValues.add(newValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>发现addGenericArgumentValue(Object value) 和addGenericArgumentValue(Object value, String type)就没这么麻烦,因为他们拿Object构造的肯定没name,也不会为null,直接懒得考虑合并,也不去验证list是否已存在这个VH, 直接塞…有相同的覆盖掉就是了…</p>
<p>只是暂时还没看到在哪这么直接地调用这种塞Object的方法</p>
</blockquote>
<p>既然都看完了CAV的赋值,干脆来看看它的取值和其它方法吧!</p>
<ol>
<li><p>获取它的list,map都是 <strong>Collections.unmodifiableMap</strong>(this.indexedArgumentValues);</p>
<p><strong>Collections.unmodifiableList</strong>(this.genericArgumentValues);这样都是返回只读的集合出去,调用set/add/remove的话会报错</p>
</li>
<li><pre><code class="java">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getArgumentCount</span><span class="params">()</span> </span>{
                <span class="keyword">return</span> <span class="keyword">this</span>.indexedArgumentValues.size() + <span class="keyword">this</span>.genericArgumentValues.size();
            }

            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{
                <span class="keyword">return</span> <span class="keyword">this</span>.indexedArgumentValues.isEmpty() &amp;&amp; <span class="keyword">this</span>.genericArgumentValues.isEmpty();
            }

            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>{
                <span class="keyword">this</span>.indexedArgumentValues.clear();
                <span class="keyword">this</span>.genericArgumentValues.clear();
            }
&lt;!--￼<span class="number">3</span>--&gt;
</code></pre>
</li>
</ol>
<p>从map里面取Indexed的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">       <span class="keyword">public</span> ConstructorArgumentValues.<span class="function">ValueHolder <span class="title">getIndexedArgumentValue</span><span class="params">(<span class="keyword">int</span> index, Class&lt;?&gt; requiredType, String requiredName)</span> </span>&#123;</span><br><span class="line">           Assert.isTrue(index &gt;= <span class="number">0</span>, <span class="string">"Index must not be negative"</span>);</span><br><span class="line">           ConstructorArgumentValues.ValueHolder valueHolder = (ConstructorArgumentValues.ValueHolder)<span class="keyword">this</span>.indexedArgumentValues.get(index);</span><br><span class="line">         <span class="comment">//这里一波||&amp;&amp;!简直了...总结一下有哪些情况返回null吧</span></span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">		 *  1. 根据这个index取出来的VH就是null</span></span><br><span class="line"><span class="comment">  		 *  2. VH的type不为null,可是( requiredType为null 或者 两者type不匹配)</span></span><br><span class="line"><span class="comment">  		 *  3. VH的name不为null,requiredName不为"" 可是( requiredName为null 或者 两者name不匹配)  </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"> <span class="keyword">return</span> valueHolder == <span class="keyword">null</span> || valueHolder.getType() != <span class="keyword">null</span> &amp;&amp; (requiredType == <span class="keyword">null</span> || !ClassUtils.matchesTypeName(requiredType, valueHolder.getType())) || valueHolder.getName() != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(requiredName) &amp;&amp; (requiredName == <span class="keyword">null</span> || !requiredName.equals(valueHolder.getName())) ? <span class="keyword">null</span> : valueHolder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意到一个细节,在判断name的时候, requiredName如果给了”” 这个值,就不会拿去判断name是否匹配…不知这是何用意…</p>
</blockquote>
<p>   从list里面取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ConstructorArgumentValues.<span class="function">ValueHolder <span class="title">getGenericArgumentValue</span><span class="params">(Class&lt;?&gt; requiredType, String requiredName, Set&lt;ConstructorArgumentValues.ValueHolder&gt; usedValueHolders)</span> </span>&#123;</span><br><span class="line">    Iterator var4 = <span class="keyword">this</span>.genericArgumentValues.iterator();</span><br><span class="line"></span><br><span class="line">    ConstructorArgumentValues.ValueHolder valueHolder;</span><br><span class="line">  <span class="comment">//这里的4层嵌套循环和疯狂的||&amp;&amp;!更是简直了........从里向外一层层看吧</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">do</span> &#123;<span class="comment">//最后看这个最外层,如果同时满足下列条件,说明这个VH还不是我们要的</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      *	1.requiredType不是null</span></span><br><span class="line"><span class="comment">      *	2.VH的Type却是null</span></span><br><span class="line"><span class="comment">      *	3.VH的name也是null</span></span><br><span class="line"><span class="comment">      *	4.type校验通不过   </span></span><br><span class="line"><span class="comment">      *	(第4步校验要通过需要满足以下情况之一 </span></span><br><span class="line"><span class="comment">      *  a. value==null 且 requiredType不是基本数据类型</span></span><br><span class="line"><span class="comment">      *	b. value不等于null 且 (valueClass继承或实现requiredType </span></span><br><span class="line"><span class="comment">      *						 或valueClass包装或解包装后能等于requiredType..)</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;<span class="comment">//再次 看这层,如果匹配到类型相同的,就说明有可能找到我们需要的参数啦,跳出来到最外层再接受一次校验.</span></span><br><span class="line">          <span class="comment">//如果不匹配的话,继续执行里面的循环找下一个VH吧.</span></span><br><span class="line">          </span><br><span class="line">            <span class="keyword">do</span> &#123;<span class="comment">//其次看这层循环,如果VH有name,requiredName不为"",但rqName为null或者两者不相等,跳过此VH,这说明VH有name的话就很关键,必须相同啊,除非rqName==""</span></span><br><span class="line">              </span><br><span class="line">                <span class="keyword">do</span> &#123;<span class="comment">//首先看这里的循环, 取下一个VH,如果取完了,就返回null</span></span><br><span class="line">                    <span class="keyword">if</span> (!var4.hasNext()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    valueHolder = (ConstructorArgumentValues.ValueHolder)var4.next();</span><br><span class="line">                <span class="comment">//如果set不为空,并且set里已经包含这个VH了就跳过此VH</span></span><br><span class="line">                &#125; <span class="keyword">while</span>(usedValueHolders != <span class="keyword">null</span> &amp;&amp; usedValueHolders.contains(valueHolder));</span><br><span class="line">            &#125; <span class="keyword">while</span>(valueHolder.getName() != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(requiredName) &amp;&amp; (requiredName == <span class="keyword">null</span> || !valueHolder.getName().equals(requiredName)));</span><br><span class="line">              </span><br><span class="line">            <span class="keyword">if</span> (valueHolder.getType() == <span class="keyword">null</span> || requiredType != <span class="keyword">null</span> &amp;&amp; ClassUtils.matchesTypeName(requiredType, valueHolder.getType())) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(requiredType != <span class="keyword">null</span> &amp;&amp; valueHolder.getType() == <span class="keyword">null</span> &amp;&amp; valueHolder.getName() == <span class="keyword">null</span> &amp;&amp; !ClassUtils.isAssignableValue(requiredType, valueHolder.getValue()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> valueHolder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   总而言之,从list里面找到我们需要的那个参数真是非常麻烦,需要这个VH满足下列条件:</p>
<ol>
<li>不在usedVH的那个set里</li>
<li>有name且rqName不是”” 就必须name匹配</li>
<li>有rqType的话,说明必须来满足这个type的匹配,那么type怎么确认是匹配的呢?<ol>
<li>type不是null,那就直接去匹配</li>
<li>type是null,如果name也是null,(说明之前用不写name方式绕过了上面的第2步name验证,如果上面第二步用的是””方式就不用管了,直接算通过), 那就必须要value.getClass能去真正的和rqType进行匹配 (继承,实现,包装,解包各种方式能匹配上就OK)</li>
</ol>
</li>
</ol>
<p>这里是真的麻烦,再换个角度再梳理一遍!</p>
<ol>
<li>如果rqName写了比如”age”,VH里name也写了的话,那就必须name也是”age”才通过</li>
<li>如果rqName写个””,那就表示name属性完全不管了,都算通过</li>
<li>如果rqName是null,那有name的VH都不行, 没name的VH可以通过</li>
<li>如果rqType没写,那就表示type不管了,都算通过(估计实际调用不会name和type全部不管吧…….)</li>
<li>如果rqType写了,那就表示要验证type啦,从上面放行过来的VH需要校验了<ol>
<li>如果VHtype为null,但是有name,说明通过1.2放过来的,都算ok (那个””就很坑了,VH随便填个name,不填type就可能全部通过了)</li>
<li>如果VHtype为null,name也是null,那就去ClassUtils.isAssignableValue校验VHvalue的本质class能否对得上.</li>
<li>如果VHtype不是null,那就必须type也完全一致</li>
</ol>
</li>
</ol>
<p><strong>我预测正常调用情况应该是rqName和rqType都有明确要求吧,那么正常流程就应该是</strong></p>
<ol>
<li>VH有name最好,匹配上直接通过!</li>
<li>VH如果没name,有type,那就去匹配type!</li>
<li>VH如果啥都没有,那就拿VHvalue的class去跟rqType匹配,这总跑不了了吧!</li>
</ol>
<blockquote>
<p>这个地方盯着看了几个小时,不知道作者写这么复杂是何居心,调用的时候也准备做这么复杂么?拿构造器参数的时候就不能把requiredName和requiredType都带过来??? 还搞些双引号””这种怪事情???</p>
</blockquote>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2017/09/12/spring_note_2/">Spring源码笔记-1.2 获取bean流程之bean标签的解析及注册</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-09-12
        </span><span class="post-category">
            <a href="/categories/Spring%E7%AC%94%E8%AE%B0/">Spring笔记</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p><img src="http://ots7yt7am.bkt.clouddn.com/blog/spring_parseDefaultElement2.png" alt=""></p>
<h2 id="1-解析BeanDefinition"><a href="#1-解析BeanDefinition" class="headerlink" title="1.解析BeanDefinition"></a>1.解析BeanDefinition</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br></pre></td></tr></table></figure>

<p>作用就是将element封装进bdHolder里面.</p>
<p>其源码很长,不贴了,但功能流程还很清晰</p>
<ol>
<li><p>处理id,name,aliases.  关键是需要<strong>beanName</strong> ,</p>
<p>name分隔开做aliases的list.</p>
<p>beanName<strong>优先用id</strong>,没id的话就从aliases里<strong>remove(0</strong>)出来一个,</p>
<p>如果有beanName了,校验beanName和aliases唯一性</p>
</li>
</ol>
<p>​       如果还是没beanName,等会再给它用方法生成个</p>
<ol start="2">
<li>将element解析,放入GenericBeanDefinition里面</li>
<li>把上一步拿到的bd连带着aliases转String[], beanName一起封装一下成为BeanDefinitionHolder返回;如果上一步返回null,就直接返回null</li>
</ol>
<p>这里的关键步骤显然是第二步,element转beanDefinition</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbstractBeanDefinition beanDefinition = <span class="keyword">this</span>.parseBeanDefinitionElement(ele, beanName, containingBean);</span><br></pre></td></tr></table></figure>

<p>这个方法也很长,大概步骤是</p>
<ol>
<li>this.parseState.push(new BeanEntry(beanName)) 开头push,结尾pop,不明白是做什么???</li>
<li>获取下className和parent</li>
<li>拿着className和parent去创建个GenericBeanDefinition   bd</li>
<li><strong>拿着bd和element进行一系列的解析步骤,把各种值塞入bd</strong></li>
<li>返回bd</li>
<li>this.parseState.pop();</li>
</ol>
<h4 id="解析各种属性"><a href="#解析各种属性" class="headerlink" title="解析各种属性"></a>解析各种属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个方法的代码丧心病狂地达到了70行,相比于目前读到的其它源码,确实是最长的一个.</p>
<p>但是里面的内容其实并不复杂,就是一个个地从element拿属性,塞属性进bd,   各种 get &amp; set .感觉确实不太好重构.</p>
</blockquote>
<p>解析了很多属性,包括scope,abstract,lazy-init,autowire…</p>
<h4 id="解析子元素meta"><a href="#解析子元素meta" class="headerlink" title="解析子元素meta"></a>解析子元素meta</h4><p><img src="http://ots7yt7am.bkt.clouddn.com/blog/spring_parseMeta.png" alt=""></p>
<h4 id="解析子元素lookup-method"><a href="#解析子元素lookup-method" class="headerlink" title="解析子元素lookup-method"></a>解析子元素lookup-method</h4><p>解析方法和meta差别很小,这里主要是去了解下lookup-method的功能</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"beanClass"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">"method"</span> <span class="attr">bean</span>=<span class="string">"non-singleton-bean"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>method是beanClass中的一个方法，beanClass和method是不是抽象都无所谓，不会影响CGLIB的动态代理，根据项目实际需求去定义。non-singleton-bean指的是lookup-method中bean属性指向的必须是一个<strong>非单例模式</strong>的bean，当然如果不是也不会报错，只是每次得到的都是相同引用的bean（同一个实例），这样用lookup-method就没有意义了。</p>
<p>参考: <a href="http://www.cnblogs.com/ViviChan/p/4981619.html" target="_blank" rel="noopener">Spring - lookup-method方式实现依赖注入</a></p>
<h4 id="解析子元素replaced-method"><a href="#解析子元素replaced-method" class="headerlink" title="解析子元素replaced-method"></a>解析子元素replaced-method</h4><p>这个不仅可以动态地替换返回实体bean,而且还能动态地更改原有方法的逻辑!!!</p>
<h4 id="解析子元素constructor-arg"><a href="#解析子元素constructor-arg" class="headerlink" title="解析子元素constructor-arg"></a>解析子元素constructor-arg</h4><p>这里提取构造参数的一些属性值就相比之前复杂多了.</p>
<ol>
<li>提取index,type,name,判断是否有index属性值</li>
<li>如果有index:<ol>
<li>构造Entry压入parseState栈</li>
<li>解析constructor-arg的子元素</li>
<li>使用ConstructorArgumentValues.ValueHolder类型来封装解析出来的元素</li>
<li>将index,type,name属性一并封装在ValueHolder中,</li>
<li>验证index是否用过了,用过则抛错,跳过此条参数</li>
<li>ValueHolder添加至当前BeanDefinition的construArgumentValues的<strong>indexedArgurmentValues</strong>属性中.</li>
<li>弹出栈</li>
</ol>
</li>
<li>如果没有index:<ol>
<li>同上压入栈</li>
<li>解析constructor-arg的子元素</li>
<li>使用ConstructorArgumentValues.ValueHolder类型来封装解析出来的元素</li>
<li>将index,type,name属性一并封装在ValueHolder中,并且添加至当前BeanDefinition的construArgumentValues的<strong>genericArgurmentValues</strong>属性中.</li>
<li>弹出栈</li>
</ol>
</li>
</ol>
<p>可以看出,有没有index其实流程没区别,主要在于在bd中保存的位置不同,另外有index的需要验证下index的唯一</p>
<h5 id="parsePropertyValue"><a href="#parsePropertyValue" class="headerlink" title="parsePropertyValue"></a>parsePropertyValue</h5><p>解析constructor-arg的子元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object value = <span class="keyword">this</span>.parsePropertyValue(ele, bd, (String)<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>这个方法也很长,里面的关键在于此处解析constructor-arg下面的子元素时,下面三种情况<strong>必须</strong>且<strong>只能</strong>占一种</p>
<ul>
<li>有ref属性</li>
<li>有value属性</li>
<li>有子元素(description和meta除外,这两种不用处理),子元素只能列一个</li>
</ul>
<p>上面三种情况对应不同的处理方法:</p>
<ol>
<li><p>ref: </p>
<p>校验下ref的值不能为空,然后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RuntimeBeanReference ref = <span class="keyword">new</span> RuntimeBeanReference(refName);</span><br><span class="line">          ref.setSource(<span class="keyword">this</span>.extractSource(ele));</span><br><span class="line">          <span class="keyword">return</span> ref;</span><br></pre></td></tr></table></figure>

<p>用RuntimeBeanReference封装下这个要引用的bean的beanName,塞下resource,返回</p>
<blockquote>
<p>查看BeanReference源码时注意到有RuntimeBeanReference和RuntimeBeanNameReference两种实现,貌似区别不大,RuntimeBeanReference多个toParent的boolean属性,此处给的也是false值.</p>
</blockquote>
</li>
<li><p>value:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TypedStringValue valueHolder = <span class="keyword">new</span> TypedStringValue(ele.getAttribute(<span class="string">"value"</span>));</span><br><span class="line">valueHolder.setSource(<span class="keyword">this</span>.extractSource(ele));</span><br><span class="line"><span class="keyword">return</span> valueHolder;</span><br></pre></td></tr></table></figure>

<p>用TypedStringValue封装下value的值  返回</p>
<blockquote>
<p>TypedStringValue和BeanReference都是实现BeanMetadataElement的,实现了Object getSource();方法</p>
</blockquote>
</li>
<li><p>子元素<strong>parsePropertySubElement</strong>: 这个又复杂了,判断10+种情况</p>
<ul>
<li><p>如果不是默认命名空间,则按其自定义的方式去解析</p>
</li>
<li><p>bean元素,按照本文的方式解析,拿到一个BeanDefinitionHolder bdHolder,bdHolder不为空的话,可能还要装饰一下(在这个元素的属性或子元素节点命名空间不为默认情况下, 用自定义方式解析后去装饰),返回最终解析+装饰的结果 bdHolder</p>
</li>
<li><p>ref: 主要还是拿要引用的beanName, 取值顺序为其属性  bean–local–parent,和之前的ref一样,用RuntimeBeanReference封装下这个要引用的bean的beanName,塞下resource,返回</p>
</li>
<li><p>idref:和ref差不多,取值顺序为bean–local</p>
</li>
<li><p>value: 拿文本值,拿type值,没type就用传来的默认typeName,此处为null,然后根据value,typeName和BeanClassLoader来构造一个TypedStringValue,返回</p>
</li>
<li><p>null:用null来new一个TypedStringValue,返回</p>
</li>
<li><p>array: </p>
<ol>
<li><p>拿value-type和子节点list</p>
</li>
<li><p>用type和子节点size构建个ManagedArray </p>
<blockquote>
<p>ManagedArray继承ManagedList<Object> 继承ArrayList<E> ,</p>
<p>ManagedList实现Mergeable和BeanMetadataElement ,可以有merge和getSource</p>
</blockquote>
<p>然后设置source和merge属性 (此处还多余重复了一遍setElementTypeName(elementType);),</p>
</li>
<li><p>然后  this.parseCollectionElements(nl, target, bd, defaultElementType);  对其子节点进行一个个的再解析子元素,还是调用<strong>parsePropertySubElement</strong>方法,只是带了个默认类型defaultElementType</p>
<blockquote>
<p>看到这已经有点晕了, 最初的那个bd都跑了多少路了?? 子元素里的属性也往bd里直接塞,不就丢失父子结构了么???</p>
</blockquote>
</li>
</ol>
</li>
<li><p>list: 和array没什么差别,仅有的区别在于用ManagedList ,(ManagedArray还是继承自他的)</p>
</li>
<li><p>set:同上,仅有的区别在于用ManagedSet,继承自LinkedHashSet</p>
</li>
<li><p>map:这个方法100行,非常长</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"score"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"math"</span> <span class="attr">value</span>=<span class="string">"90"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"english"</span> <span class="attr">value</span>=<span class="string">"85"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>拿key-tpye和value-type,子节点entry的list</p>
</li>
<li><p>构建ManagedMap,设source,KeyTypeName,ValueTypeName,MergeEnable</p>
</li>
<li><p>遍历entry节点</p>
</li>
<li><p>拿entry再下一层的子节点,遍历,如果是key节点,则设这个entry的keyEle为此,key只能最多出现一遍, 然后剩下的节点除了description之外最多只能有一个,作为valueEle.所以此处表明这里貌似可以这么写???</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"score"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">entry</span> &gt;</span></span><br><span class="line">      	<span class="tag">&lt;<span class="name">key</span>&gt;</span>哈哈<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">vvvaaluue</span>&gt;</span>这样写value??<span class="tag">&lt;/<span class="name">vvvaaluue</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">description</span>&gt;</span>描述随便写,相当于注释<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">description</span>&gt;</span>描述随便写,相当于注释<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后又和解析constructor-arg的子元素类似的情况,三种情况<strong>必须</strong>且<strong>只能</strong>出现一种:1.”key”属性;2.”key-ref”属性;3.”key”子元素, 三种对应不同的解析</p>
<p>key:TypedStringValue来封装</p>
<p>key-ref:RuntimeBeanReference来封装</p>
<p>key子元素: 里面必须且只能有一个节点,进行parsePropertySubElement,这和在array那看到的一样了</p>
<p>三种解析后返回的Objext赋值给key</p>
<p>然后解析value,和上面解析key类似,以下三种<strong>必须</strong>且<strong>只能</strong>出现一种:</p>
<p>(有点区别在于value-ref属性和value-type属性不能并存, </p>
<p>有value-type时就必须要有value属性或者value子节点)</p>
<p>value属性:拿value-type,没有就用默认的value-type(map节点下的,当然也可能没有),构建TypedStringValue</p>
<p>value-ref属性:构建RuntimeBeanReference</p>
<p>value子节点:老样子,还是parsePropertySubElement这样来继续解析子节点</p>
<p>key,value都拿到之后,会塞入ManagedMap,最终返回ManagedMap</p>
</li>
</ol>
</li>
<li><p><strong>props</strong>: </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span>   </span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"firstName"</span>&gt;</span>   </span><br><span class="line">                Rob   </span><br><span class="line">            <span class="tag">&lt;/<span class="name">prop</span>&gt;</span>   </span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"secondName"</span>&gt;</span>   </span><br><span class="line">                Harrop   </span><br><span class="line">            <span class="tag">&lt;/<span class="name">prop</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ol>
<pre><code>这个就简单了,无非就是遍历props下面的prop元素,拿key属性,拿文本值的trim(),塞入Properties对象,返回这个properties</code></pre><p>   至此,解析constructor-arg的子元素算是完成了,   都快忘掉这只是解析constructor-arg里的第一步了…</p>
<p>   总之这一步解析完子元素,返回Object对象回来,作为value</p>
<h5 id="ValueHolder"><a href="#ValueHolder" class="headerlink" title="ValueHolder"></a>ValueHolder</h5><p>用上一步返回回来的value,构造个ValueHolder</p>
<blockquote>
<p>ValueHolder类在ConstructorArgumentValues类里,实现了BeanMetadataElement,属性不多,就value,type,name,source,c<strong>onverted</strong>,<strong>convertedValue</strong></p>
</blockquote>
<p>然后constructor-arg有type属性就给vh塞type,有name塞name, 塞source</p>
<p>校验完index唯一之后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bd.getConstructorArgumentValues().addIndexedArgumentValue(index, valueHolder);</span><br></pre></td></tr></table></figure>

<p>构造器参数塞入bd的constructorArgumentValues,后面无index的处理方式和这里有index的主要区别就是在往这个constructorArgumentValues里面塞的位置不同.</p>
<p>BeanDefinition里定义了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ConstructorArgumentValues <span class="title">getConstructorArgumentValues</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个接口,在AbstractBeanDefinition里有</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ConstructorArgumentValues constructorArgumentValues;</span><br></pre></td></tr></table></figure>

<p>目测专门存放构造器的参数值的</p>
<p>下面我们来熟悉一下ConstructorArgumentValues这个类吧..</p>
<p>(这个类实在太麻烦了,写着写着2000多字,重开一文了,<a href="http://heeexy.com/2017/09/14/spring_note_3_ConstructorArgumentValues/">即下一篇笔记</a>)</p>
<h4 id="解析子元素property"><a href="#解析子元素property" class="headerlink" title="解析子元素property"></a>解析子元素property</h4><ol>
<li>拿name属性并且校验</li>
<li>parseState.push()</li>
<li>校验name在bd.getPropertyValues()里面唯一</li>
<li>parsePropertyValue  提取出property里面的子元素或者ref或者value,这个步骤和之前的<strong>解析子元素constructor-arg</strong>里面的parsePropertyValue是同一个方法! 只是这里调用带上了propertyName,这里的name是不可能为空的 ,因为第一步校验了</li>
<li>拿第4步的结果val和propertyName封装一个PropertyValue ,这个也是继承BeanMetadataAttributeAccessor的,</li>
<li>然后和之前的解析子元素meta一模一样来解析这里面的meta子元素</li>
<li>setSource</li>
<li>propertyValue塞入bd</li>
<li>parseState.pop()</li>
</ol>
<h4 id="解析子元素Qualifier"><a href="#解析子元素Qualifier" class="headerlink" title="解析子元素Qualifier"></a>解析子元素Qualifier</h4><p>Qualifier通常都是以注解形式使用的,用于在注入bean时明确指明Bean的名称</p>
<ol>
<li><p>拿type属性并校验</p>
</li>
<li><p>parseState.push()</p>
</li>
<li><p>```java<br>AutowireCandidateQualifier qualifier = new AutowireCandidateQualifier(typeName);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. setSource</span><br><span class="line"></span><br><span class="line">5. 拿value属性,如果有的话就塞入qualifier</span><br><span class="line"></span><br><span class="line">6. 遍历子节点,取其name和value(两者都必须存在),new BeanMetadataAttribute ,塞入qualifier</span><br><span class="line"></span><br><span class="line">7. qualifier塞入bd</span><br><span class="line"></span><br><span class="line">8. parseState.pop()</span><br><span class="line"></span><br><span class="line">#### bd设好resource和source,作为结果成功返回.</span><br><span class="line"></span><br><span class="line">## 2.生成beanName</span><br><span class="line"></span><br><span class="line">如果这个bean之前没有id或name,那就为它生成个beanName</span><br><span class="line"></span><br><span class="line">其规则也略烦,不过感觉不重要,简单带过一下,有一种生成规则如下</span><br><span class="line"></span><br><span class="line">命名主要根据的属性有</span><br><span class="line"></span><br><span class="line">getBeanClassName</span><br><span class="line"></span><br><span class="line">父bean名+$child</span><br><span class="line"></span><br><span class="line">工厂名+$created</span><br><span class="line"></span><br><span class="line">&gt;  &#39;class&#39; nor &#39;parent&#39; nor &#39;factory-bean&#39;</span><br><span class="line"></span><br><span class="line">后缀再加上#</span><br><span class="line"></span><br><span class="line">如果是内部bean再就加bd生成的hexString</span><br><span class="line"></span><br><span class="line">如果不是,就再加registry里这种bean的序号  从0开始</span><br><span class="line"></span><br><span class="line">## 3.返回BeanDefinitionHolder</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">String[] aliasesArray &#x3D; StringUtils.toStringArray(aliases);</span><br><span class="line">return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br></pre></td></tr></table></figure></li>
</ol>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2017/09/11/spring_note_1/">Spring源码笔记-1.1 获取bean流程之容器的基本实现</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-09-11
        </span><span class="post-category">
            <a href="/categories/Spring%E7%AC%94%E8%AE%B0/">Spring笔记</a>
            </span>
        </div>
    </header>

    <div class="post-content"><blockquote>
<p>以通过BeanFactory获取bean为例学习,实际项目中更多是使用ApplicationContext</p>
<p><img src="http://ots7yt7am.bkt.clouddn.com/blog/springGetBean.png" alt="img"></p>
<p>1.读取配置文件   beanFactoryTest.xml</p>
<p>2.通过文件资源获取工厂</p>
<p>3.从工厂中拿bean</p>
</blockquote>
<h2 id="读配置"><a href="#读配置" class="headerlink" title="读配置"></a>读配置</h2><h4 id="配置文件封装"><a href="#配置文件封装" class="headerlink" title="配置文件封装"></a>配置文件封装</h4><p>ClassPathResource类     继承–AbstractFileResolvingResource</p>
<p>​                      继承–AbstractResource</p>
<p>​                      实现–Resource</p>
<p>​                      继承–InputStreamSource接口 唯一方法:  <strong>getInputStream()</strong></p>
<p><strong>Resource接口提供了一系列方法来封装底层资源</strong>,比如  exists()  isReadable()  getURL()  getFile() getDescription() 等等</p>
<h2 id="XmlBeanFactory的实例化"><a href="#XmlBeanFactory的实例化" class="headerlink" title="XmlBeanFactory的实例化"></a>XmlBeanFactory的实例化</h2><h3 id="大概步骤"><a href="#大概步骤" class="headerlink" title="大概步骤"></a>大概步骤</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource, BeanFactory parentBeanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(parentBeanFactory);<span class="comment">//1.设置父工厂(null)...本例未使用到此</span></span><br><span class="line">       <span class="keyword">this</span>.reader = <span class="keyword">new</span> XmlBeanDefinitionReader(<span class="keyword">this</span>);<span class="comment">//2.实例化XmlBeanDefinitionReader, 注册到此工厂</span></span><br><span class="line">       <span class="keyword">this</span>.reader.loadBeanDefinitions(resource);<span class="comment">//3.重要部分,通过resource来加载beanDefinations,bean的一些定义</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>   loadBeanDefinitions(resource)方法就是下面的主要要看的</p>
<p>它做了几件事:</p>
<ol>
<li>将resource用EncodedResource包装一下,编码要用, 本例没特定的charset和encoding因此都是null</li>
<li>获取当前正在加载的资源集 Set<EncodedResource> currentResources  ,如果currentResources  是null 就初始化个 new HashSet(4),  然后将我们要读的encodedResource加到这个set里面去</li>
</ol>
<blockquote>
<p>如果返回false说明正在加载这个xml了,报个错,不继续往下读了</p>
<p>当读完这个资源后,在finally里面会从set里移出这个encodedResource,如果set空了,还会remove这个currentResources, </p>
<p>这个set是放ThreadLocal里面的,</p>
<p>private final ThreadLocal&lt;Set<EncodedResource>&gt; resourcesCurrentlyBeingLoaded;</p>
<p>是线程安全的,功能是防止同时<strong>循环加载</strong>同一个xml文件</p>
</blockquote>
<ol>
<li>从encodedResouce里取出文件的inputStream 拿去初始化个InputSource(有enconding的话,给inputSource也设个编码,本例为null)然后 inputSource和encodedResouce里面的resouce一起拿去执行doLoadBeanDefinitions(..)方法,稍后重点讲</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var5 = <span class="keyword">this</span>.doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br></pre></td></tr></table></figure>

<ol>
<li>关闭资源, 释放currentResources  等</li>
</ol>
<h3 id="关键-doLoadBeanDefinitions"><a href="#关键-doLoadBeanDefinitions" class="headerlink" title="关键:doLoadBeanDefinitions"></a><strong>关键:doLoadBeanDefinitions</strong></h3><h4 id="将资源转为Document"><a href="#将资源转为Document" class="headerlink" title="将资源转为Document"></a>将资源转为Document</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Document doc = <span class="keyword">this</span>.doLoadDocument(inputSource, resource);</span><br></pre></td></tr></table></figure>

<ol>
<li>获取xml的验证模式 , 里面的核心是自动检测,自动检测的核心是拿着inputStream读,判断是否含有”DOCTYPE”,包含就是DTD,没有就是XSD</li>
<li>拿到EntityResolver , 这个主要是用来给xml验证时找DTD文件获取路径找得快的, 不用全去spring网站拿dtd,略</li>
<li>解析document,  创建DocumentBuilderFactory,通过此工厂创建DocumentBuilder,进而解析inputSource来返回document对象. 此为通过SAX(Simple API for XML)来解析的常见方法,略过</li>
</ol>
<blockquote>
<p>注意到本方法的参数中又用到resource, 明明inputSource就是从resource里拿inputStream生成出来的啊, 相当于inputSource就是儿子, doLoadDocument方法请了儿子又去请爹,烦不烦?</p>
<p>其实主要是之前设计的时候, 获取XML验证模式的自动检测方法,用的是Resource接口,isOpen()方法因此不得不用</p>
<p>isOpen()方法是Resource接口的方法,其实现返回false(比如AbstractResource),有的返回的是true(InputStreamResource). </p>
</blockquote>
<h4 id="注册bean"><a href="#注册bean" class="headerlink" title="注册bean"></a>注册bean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registerBeanDefinitions(doc, resource);</span><br></pre></td></tr></table></figure>

<p> 先走流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">       BeanDefinitionDocumentReader documentReader = <span class="keyword">this</span>.createBeanDefinitionDocumentReader();</span><br><span class="line">       <span class="keyword">int</span> countBefore = <span class="keyword">this</span>.getRegistry().getBeanDefinitionCount();</span><br><span class="line">       documentReader.registerBeanDefinitions(doc, <span class="keyword">this</span>.createReaderContext(resource));</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>创建阅读器documentReader</li>
<li>记录加载BeanDefinition的个数,</li>
<li>documentReader来加载注册doc和封装resource而生成的Context</li>
</ol>
<p>继续走流程, 在reader内设置context,拿到root元素,重点在最后解析root</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">       <span class="keyword">this</span>.logger.debug(<span class="string">"Loading bean definitions"</span>);</span><br><span class="line">       Element root = doc.getDocumentElement();</span><br><span class="line">       <span class="keyword">this</span>.doRegisterBeanDefinitions(root);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<h5 id="开始核心部分-doRegisterBeanDefinitions"><a href="#开始核心部分-doRegisterBeanDefinitions" class="headerlink" title="开始核心部分 doRegisterBeanDefinitions"></a>开始核心部分 doRegisterBeanDefinitions</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    	基于原本的detegate,</span></span><br><span class="line"><span class="comment">    	加上这里的context和root(XML内容)修饰一遍,作为此处要用的解析代理ParserDelegate</span></span><br><span class="line"><span class="comment">      方法结束时,会把原来的解析器置换回来</span></span><br><span class="line"><span class="comment">    	 */</span></span><br><span class="line">      BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">      <span class="keyword">this</span>.delegate = <span class="keyword">this</span>.createDelegate(<span class="keyword">this</span>.getReaderContext(), root, parent);</span><br><span class="line">    <span class="comment">//如果命名空间为空或者等于"http://www.springframework.org/schema/beans" 就校验里面的一些属性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">      <span class="comment">//如果有profile属性,就要去环境变量中去寻找</span></span><br><span class="line">          String profileSpec = root.getAttribute(<span class="string">"profile"</span>);</span><br><span class="line">          <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">              String[] specifiedProfiles = StringUtils.tokenizeToStringArray(profileSpec, <span class="string">",; "</span>);</span><br><span class="line">            <span class="comment">//如果不是当前环境变量的属性值,就跳过这个xml文件</span></span><br><span class="line">              <span class="keyword">if</span> (!<span class="keyword">this</span>.getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">                      <span class="keyword">this</span>.logger.info(<span class="string">"Skipped XML bean definition file due to specified profiles ["</span> + profileSpec + <span class="string">"] not matching: "</span> + <span class="keyword">this</span>.getReaderContext().getResource());</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//解析前的预处理 默认实现方法是空的..预留给子类进行改造的位置~~~</span></span><br><span class="line">      <span class="keyword">this</span>.preProcessXml(root);</span><br><span class="line">    	<span class="comment">//核心解析      </span></span><br><span class="line">      <span class="keyword">this</span>.parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">    	<span class="comment">//解析后的处理 默认实现方法是空的..预留给子类进行改造的位置~~~</span></span><br><span class="line">      <span class="keyword">this</span>.postProcessXml(root);</span><br><span class="line">    	<span class="comment">//将delegate换回去</span></span><br><span class="line">      <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>this.preProcessXml(root); this.postProcessXml(root);此处的预留    <strong>设计模式—模板方法模式</strong></p>
</blockquote>
<p><strong>profile</strong><br><img src="http://ots7yt7am.bkt.clouddn.com/blog/spring_profile.png" alt=""></p>
<p>关于profile属性书中讲用途讲的很清楚,从源码中我了解到</p>
<ol>
<li><p>profile可以同时指定多个属性,比如 <beans profile="dev test"> 只需当前环境变量里值满足其中一种就OK</p>
</li>
<li><p>多个属性可以支持多种分隔符    逗号 分号 空格    源码是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] specifiedProfiles = StringUtils.tokenizeToStringArray(profileSpec, <span class="string">",; "</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以用一个感叹号修饰属性 比如 <beans profile="!prod">  表示”非” , 不可多个感叹号</p>
</li>
<li><p>读取并设置spring.profiles.active属性时还加了sychronized</p>
</li>
<li><p>spring.profiles.active属性值可以多个 ,用逗号隔开</p>
</li>
<li><p>判断过程其实是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> currentActiveProfiles.contains(profile) || currentActiveProfiles.isEmpty() &amp;&amp; <span class="keyword">this</span>.doGetDefaultProfiles().contains(profile);</span><br></pre></td></tr></table></figure>

<p>spring.profiles.active里包含这个属性,  或者spring.profiles.active为空,但是spring.profiles.default里包含这个属性</p>
</li>
</ol>
<blockquote>
<p>ps.这个属性看明白很有成就感,书上没解释源码, 看到这段之前先是自己埋着头进去钻源码,莫名其妙卡了很久,并不知道整段的功能是啥,继续看书看到此处,了解了这个profile 的功能,再回头结合源码,就恍然大悟:)</p>
</blockquote>
<p><strong>判断是不是默认命名空间</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDefaultNamespace</span><span class="params">(String namespaceUri)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !StringUtils.hasLength(namespaceUri) || <span class="string">"http://www.springframework.org/schema/beans"</span>.equals(namespaceUri);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDefaultNamespace</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.isDefaultNamespace(<span class="keyword">this</span>.getNamespaceURI(node));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>node获取命名空间方法 getNamespaceURI()主要在 rt.jar里有很多种不同的实现,返回字符串,就不再去深究了</p>
<h5 id="再深一层-parseBeanDefinitions"><a href="#再深一层-parseBeanDefinitions" class="headerlink" title="再深一层 parseBeanDefinitions"></a>再深一层 parseBeanDefinitions</h5><p>不贴源码了,这个方法主要是先判断这个节点是不是默认命名空间 ,不是就按自定义的方式解析,</p>
<p>是的话就遍历节点,解析每个节点.</p>
<p>每个节点解析之前都还会去判断一遍是否默认命名空间,</p>
<p>如果不是就按自定义方式解析,如果是就才按默认方式解析</p>
<p>默认标签如</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">class</span>=<span class="string">"test.testBean"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>自定义标签如</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<p>好,书的第二章到此为止,第三章将继续深入默认标签的解析</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2017/08/03/lantern/">Lantern配置</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-08-03
        </span><span class="post-category">
            <a href="/categories/%E9%A3%9E%E8%B7%83%E9%95%BF%E5%9F%8E/">飞跃长城</a>
            </span>
        </div>
    </header>

    <div class="post-content"><blockquote>
<p>第一步:飞跃长城  </p>
</blockquote>
<h2 id="预备工作"><a href="#预备工作" class="headerlink" title="预备工作"></a>预备工作</h2><ol>
<li><p>下载安装 chrome</p>
</li>
<li><p>下载安装 <a href="https://github.com/getlantern/forum/issues/833" target="_blank" rel="noopener">lantern</a></p>
</li>
<li><p>下载安装 <a href="https://switchyomega.com/download.html" target="_blank" rel="noopener">switchyOmega</a></p>
</li>
</ol>
<h2 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h2><ol>
<li><p>启动lantern.exe, 如果已启动过,也可以从右下角托盘中找到lantern图标,右击,显示蓝灯,此时浏览器会显示蓝灯的页面</p>
<p><img src="http://ots7yt7am.bkt.clouddn.com/blog/20170803142554.png" alt="lantern图标"></p>
</li>
<li><p><strong>找到本机蓝灯的端口</strong>,按下图步骤找到标注出的127.0.0.1:56939</p>
<p>  <img src="http://ots7yt7am.bkt.clouddn.com/blog/20170803143107.png" alt=""></p>
<p>  ​</p>
<p>  ​</p>
</li>
<li><p>右击chrome右上方安装好的switchyOmega的插件图标,点击<strong>选项</strong></p>
<p>  <img src="http://ots7yt7am.bkt.clouddn.com/blog/20170803141511.png" alt=""></p>
<p>  进入配置页面.在左侧菜单栏找到 新建情景模式,情景模式名称随意填写,比如就叫<strong>蓝灯</strong>,创建.</p>
</li>
<li><p>编辑刚才创建的情景模式,如下图配置</p>
<p>代理协议http  </p>
<p>代理服务器127.0.0.1 </p>
<p>代理端口 (填写你自己在第2步找到的端口号,本例是56939)</p>
<p><img src="http://ots7yt7am.bkt.clouddn.com/blog/20170803144056.png" alt=""></p>
</li>
<li><p>屏幕左下角<strong>应用选项</strong> ,配置完成</p>
</li>
</ol>
<h2 id="成功翻墙"><a href="#成功翻墙" class="headerlink" title="成功翻墙"></a>成功翻墙</h2><p>打开<a href="https://www.google.com" target="_blank" rel="noopener">Google</a> 页面, 左击<img src="http://ots7yt7am.bkt.clouddn.com/blog/20170803141511.png" alt=""> 选中情景模式为<strong>蓝灯</strong> ,此时应该已经可以成功翻墙了!</p>
<p>蓝灯模式适用翻墙,浏览国内网站时可以改为直接连接.</p>
<blockquote>
<p>当然有方便的自动切换代理的功能啦!</p>
<p>但是你已经身在墙外了,自己搜搜吧!</p>
</blockquote>

        </div></article>
      <nav class="pagination"><a class="prev" href="/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">上一页</span>
      </a>
    </nav></section></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:heeexy@gmail.com" class="iconfont icon-email" title="email"></a>
        <a href="https://github.com/Heeexy" target="_blank" rel="noopener" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">Even</a>
  </span>

  <span class="copyright-year">&copy;2017 - 2022<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">heeexy</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
