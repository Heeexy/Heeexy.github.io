<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Redisson分布式锁报错问题排查 | 网站标题</title>
<meta name=keywords content="Redisson,分布式锁"><meta name=description content="故障 业务线测试同学反馈压测时，有以下报错日志：
java.lang.IllegalMonitorStateException: attempt to unlock lock, not locked by current thread by node id: def1bd2c-1f49-4802-b635-5ea78543c033 thread-id: 109 at org.redisson.RedissonLock.unlock(RedissonLock.java:366) 先抛结论 建议遇到类似问题的人先检查项目中是否确保了 redissonClient 的单例。（单线程当然也是必须的，不过排查起来很简单，估计看到文章的人首先已经排查过单线程的问题了）
本次报错是因为:
redissonClient 虽然是单例的静态成员变量，但初始化时未加锁，而是简单使用
private static RedissonClient redisson = null; public static RedissonClient getRedisson(){ if(redisson == null){ RedissonManager.init(); //初始化 } return redisson; } 加锁解锁没有同一个 lock，而是每次都使用getRedisson().getLock(key) 。导致解锁时从另一个 redissonClient 并没有获取到锁。 换言之，报错里的not locked by current thread by node id: def1bd2c-1f49-4802-b635-5ea78543c033 thread-id: 109 其实关键问题在于by node id ，而不是线程id。
定位问题依据 不需要改代码、加日志甚至debug，只需要搜索日志里是否有两行
13:58:07.972 [main] INFO org."><meta name=author content><link rel=canonical href=https://heeexy.com/posts/redisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://heeexy.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://heeexy.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://heeexy.com/favicon-32x32.png><link rel=apple-touch-icon href=https://heeexy.com/apple-touch-icon.png><link rel=mask-icon href=https://heeexy.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://heeexy.com/posts/redisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Redisson分布式锁报错问题排查"><meta property="og:description" content="故障 业务线测试同学反馈压测时，有以下报错日志：
java.lang.IllegalMonitorStateException: attempt to unlock lock, not locked by current thread by node id: def1bd2c-1f49-4802-b635-5ea78543c033 thread-id: 109 at org.redisson.RedissonLock.unlock(RedissonLock.java:366) 先抛结论 建议遇到类似问题的人先检查项目中是否确保了 redissonClient 的单例。（单线程当然也是必须的，不过排查起来很简单，估计看到文章的人首先已经排查过单线程的问题了）
本次报错是因为:
redissonClient 虽然是单例的静态成员变量，但初始化时未加锁，而是简单使用
private static RedissonClient redisson = null; public static RedissonClient getRedisson(){ if(redisson == null){ RedissonManager.init(); //初始化 } return redisson; } 加锁解锁没有同一个 lock，而是每次都使用getRedisson().getLock(key) 。导致解锁时从另一个 redissonClient 并没有获取到锁。 换言之，报错里的not locked by current thread by node id: def1bd2c-1f49-4802-b635-5ea78543c033 thread-id: 109 其实关键问题在于by node id ，而不是线程id。
定位问题依据 不需要改代码、加日志甚至debug，只需要搜索日志里是否有两行
13:58:07.972 [main] INFO org."><meta property="og:type" content="article"><meta property="og:url" content="https://heeexy.com/posts/redisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-07-16T23:47:00+00:00"><meta property="article:modified_time" content="2020-07-16T23:47:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Redisson分布式锁报错问题排查"><meta name=twitter:description content="故障 业务线测试同学反馈压测时，有以下报错日志：
java.lang.IllegalMonitorStateException: attempt to unlock lock, not locked by current thread by node id: def1bd2c-1f49-4802-b635-5ea78543c033 thread-id: 109 at org.redisson.RedissonLock.unlock(RedissonLock.java:366) 先抛结论 建议遇到类似问题的人先检查项目中是否确保了 redissonClient 的单例。（单线程当然也是必须的，不过排查起来很简单，估计看到文章的人首先已经排查过单线程的问题了）
本次报错是因为:
redissonClient 虽然是单例的静态成员变量，但初始化时未加锁，而是简单使用
private static RedissonClient redisson = null; public static RedissonClient getRedisson(){ if(redisson == null){ RedissonManager.init(); //初始化 } return redisson; } 加锁解锁没有同一个 lock，而是每次都使用getRedisson().getLock(key) 。导致解锁时从另一个 redissonClient 并没有获取到锁。 换言之，报错里的not locked by current thread by node id: def1bd2c-1f49-4802-b635-5ea78543c033 thread-id: 109 其实关键问题在于by node id ，而不是线程id。
定位问题依据 不需要改代码、加日志甚至debug，只需要搜索日志里是否有两行
13:58:07.972 [main] INFO org."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://heeexy.com/posts/"},{"@type":"ListItem","position":2,"name":"Redisson分布式锁报错问题排查","item":"https://heeexy.com/posts/redisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Redisson分布式锁报错问题排查","name":"Redisson分布式锁报错问题排查","description":"故障 业务线测试同学反馈压测时，有以下报错日志：\njava.lang.IllegalMonitorStateException: attempt to unlock lock, not locked by current thread by node id: def1bd2c-1f49-4802-b635-5ea78543c033 thread-id: 109 at org.redisson.RedissonLock.unlock(RedissonLock.java:366) 先抛结论 建议遇到类似问题的人先检查项目中是否确保了 redissonClient 的单例。（单线程当然也是必须的，不过排查起来很简单，估计看到文章的人首先已经排查过单线程的问题了）\n本次报错是因为:\nredissonClient 虽然是单例的静态成员变量，但初始化时未加锁，而是简单使用\nprivate static RedissonClient redisson = null; public static RedissonClient getRedisson(){ if(redisson == null){ RedissonManager.init(); //初始化 } return redisson; } 加锁解锁没有同一个 lock，而是每次都使用getRedisson().getLock(key) 。导致解锁时从另一个 redissonClient 并没有获取到锁。 换言之，报错里的not locked by current thread by node id: def1bd2c-1f49-4802-b635-5ea78543c033 thread-id: 109 其实关键问题在于by node id ，而不是线程id。\n定位问题依据 不需要改代码、加日志甚至debug，只需要搜索日志里是否有两行\n13:58:07.972 [main] INFO org.","keywords":["Redisson","分布式锁"],"articleBody":"故障 业务线测试同学反馈压测时，有以下报错日志：\njava.lang.IllegalMonitorStateException: attempt to unlock lock, not locked by current thread by node id: def1bd2c-1f49-4802-b635-5ea78543c033 thread-id: 109 at org.redisson.RedissonLock.unlock(RedissonLock.java:366) 先抛结论 建议遇到类似问题的人先检查项目中是否确保了 redissonClient 的单例。（单线程当然也是必须的，不过排查起来很简单，估计看到文章的人首先已经排查过单线程的问题了）\n本次报错是因为:\nredissonClient 虽然是单例的静态成员变量，但初始化时未加锁，而是简单使用\nprivate static RedissonClient redisson = null; public static RedissonClient getRedisson(){ if(redisson == null){ RedissonManager.init(); //初始化 } return redisson; } 加锁解锁没有同一个 lock，而是每次都使用getRedisson().getLock(key) 。导致解锁时从另一个 redissonClient 并没有获取到锁。 换言之，报错里的not locked by current thread by node id: def1bd2c-1f49-4802-b635-5ea78543c033 thread-id: 109 其实关键问题在于by node id ，而不是线程id。\n定位问题依据 不需要改代码、加日志甚至debug，只需要搜索日志里是否有两行\n13:58:07.972 [main] INFO org.redisson.Version - Redisson 2.8.2\n打印两次版本信息说明肯定初始化了两次 Redisson。\n是的，定位和结论就这么简单，如果能早点知道，我就能省下这十几个小时和一大把头发了。\n排查过程 一、搜索解决方案 把报错信息复制出去很容易就搜到了一些文章遇到类似的报错，解决方式就是解锁前判断是否自己持有的这个锁。\nif(lock.isHeldByCurrentThread()){ lock.unlock(); } 并且从“源码”级别解释了lock方法catch了InterruptedException等概念。\n二、质疑解决方案 很显然加上这一行代码，不会再报错了，但是这给我带来的问题更多了。\n自己手写demo里将线程interrupt复现这个问题可以理解，但是我们实际项目中线程被谁interrupt了？\n加了if(lock.isHeldByCurrentThread())的确不报错了，但这个线程本质上就没拿到这个分布式锁，在else中还是应该手动抛个异常出去的。轻度压测都出现这种情况，那项目岂不是毫无并发度可言？\nRedisson 应该也是个成熟的框架了，为什么特地暴露个 lock 接口出来，实际功能只是隐藏掉InterruptedException? 如果我们实际项目中线程被 interrupt 是常态，那暴露这种接口岂不是挖坑？\npublic void lock(long leaseTime, TimeUnit unit) { try { lockInterruptibly(leaseTime, unit); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } 看来问题并非一行代码就能掩盖过去的，事情开始变得有意思了。\n三、排查线程问题 既然网上文章都说源码里catch 了 InterruptedException，那就研究下源码看是不是有地方会interrupt。\n@Override public void lockInterruptibly(long leaseTime, TimeUnit unit) throws InterruptedException { long threadId = Thread.currentThread().getId(); //先获取一次锁试试看 Long ttl = tryAcquire(leaseTime, unit, threadId); // lock acquired if (ttl == null) { return; } //拿不到锁就订阅channel RFuture\u003cRedissonLockEntry\u003e future = subscribe(threadId); commandExecutor.syncSubscription(future); try { //循环获取锁 while (true) { ttl = tryAcquire(leaseTime, unit, threadId); // lock acquired if (ttl == null) { break; } // waiting for message if (ttl \u003e= 0) { //事实上通常等锁都会走到这，内部是semaphore在等资源。而发生InterruptedException也是在这里面。 getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS); } else { getEntry(threadId).getLatch().acquire(); } } } finally { unsubscribe(future, threadId); } } 而这边用到的Semaphore其实是0个permmit的，作用就是用来阻塞线程。\nthis.latch = new Semaphore(0); 再继续深入无非就只有Semaphore和AQS的基础知识了。有处理interrupted的地方，但是没有手动interrupt()的地方。\nunlock() 方法则更为简单，就是用脚本去redis查这个锁，解锁。失败的话会报我们遇到的错误。\n源码再加上一些手动实验，都无法知道何时被interrupt，此时线程中断的排查似乎走到了死胡同。\n四、排查client问题 经过一番沟通和折腾，终于测试同学可以压测我的电脑上部署的项目。\n前后压了5、6遍，几十万次请求，流量近10倍于压测环境。\n然而只有第一次和第三次压复现了异常，而第一次压时发现原项目日志用的还是System.out.println，打印的信息也不完善，无法帮助排查。第三次压刚启动进了异常断点，以为是项目启动有问题，放掉断点跑了十几万次请求都OK。\n全部压测结束，最后几次也无法复现问题，到了收工时间，无法再压测。\n再回过头看唯一一次有记录的异常日志信息，发现日志里显示的是 “interrupted:false,hold:true”。表明线程没被中断过，但是并不是这个锁的持有者。\n只能继续带着更多的问题去做推测\u0026验证。\nQ1:会不会是加锁和解锁用到的两个方法各自去获取的lock对象不一致导致的问题？\nA1:自己试验了很多遍，两个对象不一致并不影响结果。\nQ2:会不会是项目启动的初始化redissonClient没加锁导致了异常？\nA2:翻了下日志，项目打印日志多，请求量又特别大，几十万行的日志中找到报错位置和项目启动位置似乎时间间隔有点长，应该不是这个原因。（就是这里第一次错过了正确的答案。。。）\nQ3:会不会是因为加锁解锁间隔过短，两个lock对象分别连接了master和slave，主从延迟导致的？(半夜刷牙想到这个，似乎非常有可能，高兴坏了)\nA3:第二天来公司用demo验证，用了半天时间，各自改代码，几百上千个线程跑了很多遍都没复现这个问题，redis都打得有节点连接不上了，跑得我都要怀疑人生了。\nQ4:试验中发现解锁用到的lock2对象如果是通过redissonClient2获取的，能稳定复现这个问题，是否与我们的项目遇到的异常有关联呢？\nA4:再去看了下项目代码，除了初始化redissonClient没加锁之外，运行过程中用的都是静态变量指向的redissonClient，应该是同一个，与这个试验场景不一样。（第二次错过正确答案。。。）\n没有了思路，只能逐行debug，走一行看一眼Redisson打的长串日志。\n观察发现调用 lock.isHeldByCurrentThread() 等方法其实都是在请求redis，并非像普通的java对象一样读取成员变量。\n仔细看每个lock的每次查询是否用了相同的connection，搜索每个connection的id发现，每次并不相同，且应该都是从初始化连接池中拿的。\n排除了各种情况的答案后，我发现了请求redis的脚本中元素的key其实有规律，是id+key，而id就是这个client初始化时生成的uuid，稍加验证，很轻松解释了之前的Q4中能稳定复现这个异常的原因。就是多个client就相当于分布式的多个jvm，即使同一个线程，使用的锁id肯定也是不一样的。\n因此我又把目光转回了多个client的这个问题，光看代码的确是有这个可能性，现在还需要在错误日志里找到相应的依据去证实自己的猜测。\n回到Q2位忽略掉的日志，在vscode中打开庞大的日志文件，CTRL+F搜索异常的时间点等信息，发现了自己之前的一个误解，其实 项目启动!=client初始化， client是等到请求打过来才初始化的。\n再稍加搜索，虽然日志中没有打印client的id，但是两个不同的线程打印了两次Redission的版本信息便足以佐证我的猜测了。\n反思 十几个小时的排查过程虽然学到了很多，但是自己的几个失误其实大大拉长了这痛苦的时间。\n没有第一时间去加日志，压测，复现问题。\n如果在原项目中加上日志看下锁的 isInterrupted() 和 isHeldByCurrentThread()状态，其实很快就能发现线程根本没有被 interrupt，不用往那个方向排查。\nlog.info(\"lock:\" + lock.toString() + \",interrupted:\" + Thread.currentThread().isInterrupted() + \",hold:\" + lock.isHeldByCurrentThread() + \",threadId:\" + Thread.currentThread().getId()); 多次错过了正确答案。\n其实也主要是因为不是自己的项目，在改代码、发布、压测、日志、监控这些方面都缺乏掌控，因此难免走了一些弯路。\n","wordCount":"264","inLanguage":"en","datePublished":"2020-07-16T23:47:00Z","dateModified":"2020-07-16T23:47:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://heeexy.com/posts/redisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"},"publisher":{"@type":"Organization","name":"网站标题","logo":{"@type":"ImageObject","url":"https://heeexy.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://heeexy.com/ accesskey=h title="网站标题 (Alt + H)">网站标题</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Redisson分布式锁报错问题排查</h1><div class=post-meta><span title='2020-07-16 23:47:00 +0000 UTC'>July 16, 2020</span></div></header><div class=post-content><h2 id=故障>故障<a hidden class=anchor aria-hidden=true href=#故障>#</a></h2><p>业务线测试同学反馈压测时，有以下报错日志：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>java.<span style=color:#a6e22e>lang</span>.<span style=color:#a6e22e>IllegalMonitorStateException</span>: attempt to unlock lock, 
</span></span><span style=display:flex><span>not locked by current thread by node id: def1bd2c<span style=color:#f92672>-</span>1f49<span style=color:#f92672>-</span>4802<span style=color:#f92672>-</span>b635<span style=color:#f92672>-</span>5ea78543c033 thread<span style=color:#f92672>-</span>id: 109
</span></span><span style=display:flex><span>	at org.<span style=color:#a6e22e>redisson</span>.<span style=color:#a6e22e>RedissonLock</span>.<span style=color:#a6e22e>unlock</span>(RedissonLock.<span style=color:#a6e22e>java</span>:366)
</span></span></code></pre></div><h2 id=先抛结论>先抛结论<a hidden class=anchor aria-hidden=true href=#先抛结论>#</a></h2><p>建议遇到类似问题的人先检查项目中是否确保了 <strong>redissonClient 的单例</strong>。（单线程当然也是必须的，不过排查起来很简单，估计看到文章的人首先已经排查过单线程的问题了）</p><p>本次报错是因为:</p><ol><li><p>redissonClient 虽然是单例的静态成员变量，但初始化时未加锁，而是简单使用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>      <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> RedissonClient redisson <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> RedissonClient <span style=color:#a6e22e>getRedisson</span>(){
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(redisson <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>){
</span></span><span style=display:flex><span>            RedissonManager.<span style=color:#a6e22e>init</span>(); <span style=color:#75715e>//初始化</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> redisson;
</span></span><span style=display:flex><span>      }
</span></span></code></pre></div></li><li><p>加锁解锁没有同一个 lock，而是每次都使用<code>getRedisson().getLock(key)</code> 。导致解锁时从另一个 redissonClient 并没有获取到锁。
换言之，报错里的<code>not locked by current thread by node id: def1bd2c-1f49-4802-b635-5ea78543c033 thread-id: 109</code> 其实关键问题在于<code>by node id</code> ，而不是线程id。</p></li></ol><h2 id=定位问题依据>定位问题依据<a hidden class=anchor aria-hidden=true href=#定位问题依据>#</a></h2><p>不需要改代码、加日志甚至debug，只需要搜索日志里是否有两行</p><p><code>13:58:07.972 [main] INFO org.redisson.Version - Redisson 2.8.2</code></p><p>打印两次版本信息说明肯定初始化了两次 Redisson。</p><p>是的，定位和结论就这么简单，如果能早点知道，我就能省下这十几个小时和一大把头发了。</p><h2 id=排查过程>排查过程<a hidden class=anchor aria-hidden=true href=#排查过程>#</a></h2><h3 id=一搜索解决方案>一、搜索解决方案<a hidden class=anchor aria-hidden=true href=#一搜索解决方案>#</a></h3><p>把报错信息复制出去很容易就搜到了一些文章遇到类似的报错，解决方式就是解锁前判断是否自己持有的这个锁。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(lock.<span style=color:#a6e22e>isHeldByCurrentThread</span>()){
</span></span><span style=display:flex><span>                lock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>            }
</span></span></code></pre></div><p>并且从“源码”级别解释了lock方法catch了InterruptedException等概念。</p><h3 id=二质疑解决方案>二、质疑解决方案<a hidden class=anchor aria-hidden=true href=#二质疑解决方案>#</a></h3><p>很显然加上这一行代码，不会再报错了，但是这给我带来的问题更多了。</p><ol><li><p>自己手写demo里将线程interrupt复现这个问题可以理解，但是我们实际项目中线程被谁interrupt了？</p></li><li><p>加了<code>if(lock.isHeldByCurrentThread())</code>的确不报错了，但这个线程本质上就没拿到这个分布式锁，在else中还是应该手动抛个异常出去的。轻度压测都出现这种情况，那项目岂不是毫无并发度可言？</p></li><li><p>Redisson 应该也是个成熟的框架了，为什么特地暴露个 lock 接口出来，实际功能只是隐藏掉<code>InterruptedException</code>? 如果我们实际项目中线程被 interrupt 是常态，那暴露这种接口岂不是挖坑？</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>lock</span>(<span style=color:#66d9ef>long</span> leaseTime, TimeUnit unit) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            lockInterruptibly(leaseTime, unit);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>            Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>interrupt</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div></li></ol><p>看来问题并非一行代码就能掩盖过去的，事情开始变得有意思了。</p><h3 id=三排查线程问题>三、排查线程问题<a hidden class=anchor aria-hidden=true href=#三排查线程问题>#</a></h3><p>既然网上文章都说源码里catch 了 InterruptedException，那就研究下源码看是不是有地方会interrupt。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>lockInterruptibly</span>(<span style=color:#66d9ef>long</span> leaseTime, TimeUnit unit) <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> threadId <span style=color:#f92672>=</span> Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getId</span>();
</span></span><span style=display:flex><span>      <span style=color:#75715e>//先获取一次锁试试看</span>
</span></span><span style=display:flex><span>        Long ttl <span style=color:#f92672>=</span> tryAcquire(leaseTime, unit, threadId);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// lock acquired</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (ttl <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>			<span style=color:#75715e>//拿不到锁就订阅channel</span>
</span></span><span style=display:flex><span>        RFuture<span style=color:#f92672>&lt;</span>RedissonLockEntry<span style=color:#f92672>&gt;</span> future <span style=color:#f92672>=</span> subscribe(threadId);
</span></span><span style=display:flex><span>        commandExecutor.<span style=color:#a6e22e>syncSubscription</span>(future);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>          <span style=color:#75715e>//循环获取锁</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>                ttl <span style=color:#f92672>=</span> tryAcquire(leaseTime, unit, threadId);
</span></span><span style=display:flex><span>                <span style=color:#75715e>// lock acquired</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (ttl <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// waiting for message</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (ttl <span style=color:#f92672>&gt;=</span> 0) {
</span></span><span style=display:flex><span>                  <span style=color:#75715e>//事实上通常等锁都会走到这，内部是semaphore在等资源。而发生InterruptedException也是在这里面。</span>
</span></span><span style=display:flex><span>                    getEntry(threadId).<span style=color:#a6e22e>getLatch</span>().<span style=color:#a6e22e>tryAcquire</span>(ttl, TimeUnit.<span style=color:#a6e22e>MILLISECONDS</span>);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    getEntry(threadId).<span style=color:#a6e22e>getLatch</span>().<span style=color:#a6e22e>acquire</span>();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>            unsubscribe(future, threadId);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>而这边用到的Semaphore其实是0个permmit的，作用就是用来阻塞线程。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>latch</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Semaphore(0);
</span></span></code></pre></div><p>再继续深入无非就只有Semaphore和AQS的基础知识了。有处理interrupted的地方，但是没有手动interrupt()的地方。</p><p><code>unlock()</code> 方法则更为简单，就是用脚本去redis查这个锁，解锁。失败的话会报我们遇到的错误。</p><p>源码再加上一些手动实验，都无法知道何时被interrupt，此时线程中断的排查似乎走到了死胡同。</p><h3 id=四排查client问题>四、排查client问题<a hidden class=anchor aria-hidden=true href=#四排查client问题>#</a></h3><p>经过一番沟通和折腾，终于测试同学可以压测我的电脑上部署的项目。</p><p>前后压了5、6遍，几十万次请求，流量近10倍于压测环境。</p><p>然而只有第一次和第三次压复现了异常，而第一次压时发现原项目日志用的还是<code>System.out.println</code>，打印的信息也不完善，无法帮助排查。第三次压刚启动进了异常断点，以为是项目启动有问题，放掉断点跑了十几万次请求都OK。</p><p>全部压测结束，最后几次也无法复现问题，到了收工时间，无法再压测。</p><p>再回过头看唯一一次有记录的异常日志信息，发现日志里显示的是 &ldquo;interrupted:false,hold:true&rdquo;。表明线程没被中断过，但是并不是这个锁的持有者。</p><p>只能继续带着更多的问题去做推测&验证。</p><p>Q1:会不会是加锁和解锁用到的两个方法各自去获取的lock对象不一致导致的问题？</p><p>A1:自己试验了很多遍，两个对象不一致并不影响结果。</p><p>Q2:会不会是项目启动的初始化redissonClient没加锁导致了异常？</p><p>A2:翻了下日志，项目打印日志多，请求量又特别大，几十万行的日志中找到报错位置和项目启动位置似乎时间间隔有点长，应该不是这个原因。（就是这里第一次错过了正确的答案。。。）</p><p>Q3:会不会是因为加锁解锁间隔过短，两个lock对象分别连接了master和slave，主从延迟导致的？(半夜刷牙想到这个，似乎非常有可能，高兴坏了)</p><p>A3:第二天来公司用demo验证，用了半天时间，各自改代码，几百上千个线程跑了很多遍都没复现这个问题，redis都打得有节点连接不上了，跑得我都要怀疑人生了。</p><p>Q4:试验中发现解锁用到的lock2对象如果是通过redissonClient2获取的，能稳定复现这个问题，是否与我们的项目遇到的异常有关联呢？</p><p>A4:再去看了下项目代码，除了初始化redissonClient没加锁之外，运行过程中用的都是静态变量指向的redissonClient，应该是同一个，与这个试验场景不一样。（第二次错过正确答案。。。）</p><p>没有了思路，只能逐行debug，走一行看一眼Redisson打的长串日志。</p><p>观察发现调用 <code>lock.isHeldByCurrentThread()</code> 等方法其实都是在请求redis，并非像普通的java对象一样读取成员变量。</p><p>仔细看每个lock的每次查询是否用了相同的connection，搜索每个connection的id发现，每次并不相同，且应该都是从初始化连接池中拿的。</p><p>排除了各种情况的答案后，我发现了请求redis的脚本中元素的key其实有规律，是id+key，而id就是这个client初始化时生成的uuid，稍加验证，很轻松解释了之前的Q4中能稳定复现这个异常的原因。就是多个client就相当于分布式的多个jvm，即使同一个线程，使用的锁id肯定也是不一样的。</p><p>因此我又把目光转回了多个client的这个问题，光看代码的确是有这个可能性，现在还需要在错误日志里找到相应的依据去证实自己的猜测。</p><p>回到Q2位忽略掉的日志，在vscode中打开庞大的日志文件，CTRL+F搜索异常的时间点等信息，发现了自己之前的一个误解，其实 项目启动!=client初始化， client是等到请求打过来才初始化的。</p><p>再稍加搜索，虽然日志中没有打印client的id，但是两个不同的线程打印了两次Redission的版本信息便足以佐证我的猜测了。</p><h2 id=反思>反思<a hidden class=anchor aria-hidden=true href=#反思>#</a></h2><p>十几个小时的排查过程虽然学到了很多，但是自己的几个失误其实大大拉长了这痛苦的时间。</p><ol><li><p>没有第一时间去加日志，压测，复现问题。</p><p>如果在原项目中加上日志看下锁的 <code>isInterrupted()</code> 和 <code>isHeldByCurrentThread()</code>状态，其实很快就能发现线程根本没有被 interrupt，不用往那个方向排查。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span> log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;lock:&#34;</span> <span style=color:#f92672>+</span> lock.<span style=color:#a6e22e>toString</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;,interrupted:&#34;</span> <span style=color:#f92672>+</span> Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>isInterrupted</span>() 
</span></span><span style=display:flex><span>          <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;,hold:&#34;</span> <span style=color:#f92672>+</span> lock.<span style=color:#a6e22e>isHeldByCurrentThread</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;,threadId:&#34;</span> <span style=color:#f92672>+</span> Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getId</span>());
</span></span></code></pre></div></li><li><p>多次错过了正确答案。</p></li></ol><p>其实也主要是因为不是自己的项目，在改代码、发布、压测、日志、监控这些方面都缺乏掌控，因此难免走了一些弯路。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://heeexy.com/tags/redisson/>Redisson</a></li><li><a href=https://heeexy.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/>分布式锁</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://heeexy.com/>网站标题</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>