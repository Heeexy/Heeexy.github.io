<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>搭建springboot-shiro-vue框架时遇到的坑 | 网站标题</title>
<meta name=keywords content="java,springboot,shiro"><meta name=description content="​	最近在做前后端分离的新框架,选用了后端springboot+shiro,前端vue+elementUI,第一次搭SSM之外的非demo项目,尤其shiro更是之前从未接触,折腾了很多天,遇到很多问题,大部分能百度出来,剩下的非常费时的问题且称之为坑吧.
跨域 ​	一大部分问题就是跨域造成的,本身vue-cli搭建的项目可以用
// 1. axios的baseURL设置为/api // 2. 如下设置 proxyTable: { '/api': { target: 'http://127.0.0.1:8080/', changeOrigin: true, pathRewrite: { '^/api': '/' } } }, 来解决开发环境跨域的问题,生产环境反正可以打包静态文件到springboot项目中直接跑.
而我还是脑抽得选择了强行跨域,假装自己要把静态文件单独放个服务器跑&mldr;为此遇到很多问题,折腾好几天.
因此强力推荐上面的方案,简单快捷地解决跨域!
如果生产环境真的需要跨域的话,再按下面方法设置
大部分跨域的配置都能百度搜出来:
axios要 withCredentials: true
用session而不用啥特殊的token之类的话,就不用 config.headers['X-Token'] = getToken() ,这句是vueAdmin-template 中带的,需要删掉.
后端需要配置允许跨域
@Configuration public class CorsConfig { private CorsConfiguration buildConfig() { CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOrigin(&#34;*&#34;); // 1 设置访问源地址 corsConfiguration.addAllowedHeader(&#34;*&#34;); // 2 设置访问源请求头 corsConfiguration.addAllowedMethod(&#34;*&#34;); // 3 设置访问源请求方法 corsConfiguration.setAllowCredentials(true); return corsConfiguration; } @Bean public CorsFilter corsFilter() { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source."><meta name=author content><link rel=canonical href=https://heeexy.com/posts/build-springboot-shiro/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://heeexy.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://heeexy.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://heeexy.com/favicon-32x32.png><link rel=apple-touch-icon href=https://heeexy.com/apple-touch-icon.png><link rel=mask-icon href=https://heeexy.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://heeexy.com/posts/build-springboot-shiro/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="搭建springboot-shiro-vue框架时遇到的坑"><meta property="og:description" content="​	最近在做前后端分离的新框架,选用了后端springboot+shiro,前端vue+elementUI,第一次搭SSM之外的非demo项目,尤其shiro更是之前从未接触,折腾了很多天,遇到很多问题,大部分能百度出来,剩下的非常费时的问题且称之为坑吧.
跨域 ​	一大部分问题就是跨域造成的,本身vue-cli搭建的项目可以用
// 1. axios的baseURL设置为/api // 2. 如下设置 proxyTable: { '/api': { target: 'http://127.0.0.1:8080/', changeOrigin: true, pathRewrite: { '^/api': '/' } } }, 来解决开发环境跨域的问题,生产环境反正可以打包静态文件到springboot项目中直接跑.
而我还是脑抽得选择了强行跨域,假装自己要把静态文件单独放个服务器跑&mldr;为此遇到很多问题,折腾好几天.
因此强力推荐上面的方案,简单快捷地解决跨域!
如果生产环境真的需要跨域的话,再按下面方法设置
大部分跨域的配置都能百度搜出来:
axios要 withCredentials: true
用session而不用啥特殊的token之类的话,就不用 config.headers['X-Token'] = getToken() ,这句是vueAdmin-template 中带的,需要删掉.
后端需要配置允许跨域
@Configuration public class CorsConfig { private CorsConfiguration buildConfig() { CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOrigin(&#34;*&#34;); // 1 设置访问源地址 corsConfiguration.addAllowedHeader(&#34;*&#34;); // 2 设置访问源请求头 corsConfiguration.addAllowedMethod(&#34;*&#34;); // 3 设置访问源请求方法 corsConfiguration.setAllowCredentials(true); return corsConfiguration; } @Bean public CorsFilter corsFilter() { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source."><meta property="og:type" content="article"><meta property="og:url" content="https://heeexy.com/posts/build-springboot-shiro/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-10-22T11:19:33+00:00"><meta property="article:modified_time" content="2017-10-22T11:19:33+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="搭建springboot-shiro-vue框架时遇到的坑"><meta name=twitter:description content="​	最近在做前后端分离的新框架,选用了后端springboot+shiro,前端vue+elementUI,第一次搭SSM之外的非demo项目,尤其shiro更是之前从未接触,折腾了很多天,遇到很多问题,大部分能百度出来,剩下的非常费时的问题且称之为坑吧.
跨域 ​	一大部分问题就是跨域造成的,本身vue-cli搭建的项目可以用
// 1. axios的baseURL设置为/api // 2. 如下设置 proxyTable: { '/api': { target: 'http://127.0.0.1:8080/', changeOrigin: true, pathRewrite: { '^/api': '/' } } }, 来解决开发环境跨域的问题,生产环境反正可以打包静态文件到springboot项目中直接跑.
而我还是脑抽得选择了强行跨域,假装自己要把静态文件单独放个服务器跑&mldr;为此遇到很多问题,折腾好几天.
因此强力推荐上面的方案,简单快捷地解决跨域!
如果生产环境真的需要跨域的话,再按下面方法设置
大部分跨域的配置都能百度搜出来:
axios要 withCredentials: true
用session而不用啥特殊的token之类的话,就不用 config.headers['X-Token'] = getToken() ,这句是vueAdmin-template 中带的,需要删掉.
后端需要配置允许跨域
@Configuration public class CorsConfig { private CorsConfiguration buildConfig() { CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOrigin(&#34;*&#34;); // 1 设置访问源地址 corsConfiguration.addAllowedHeader(&#34;*&#34;); // 2 设置访问源请求头 corsConfiguration.addAllowedMethod(&#34;*&#34;); // 3 设置访问源请求方法 corsConfiguration.setAllowCredentials(true); return corsConfiguration; } @Bean public CorsFilter corsFilter() { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://heeexy.com/posts/"},{"@type":"ListItem","position":2,"name":"搭建springboot-shiro-vue框架时遇到的坑","item":"https://heeexy.com/posts/build-springboot-shiro/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"搭建springboot-shiro-vue框架时遇到的坑","name":"搭建springboot-shiro-vue框架时遇到的坑","description":"​\t最近在做前后端分离的新框架,选用了后端springboot+shiro,前端vue+elementUI,第一次搭SSM之外的非demo项目,尤其shiro更是之前从未接触,折腾了很多天,遇到很多问题,大部分能百度出来,剩下的非常费时的问题且称之为坑吧.\n跨域 ​\t一大部分问题就是跨域造成的,本身vue-cli搭建的项目可以用\n// 1. axios的baseURL设置为/api // 2. 如下设置 proxyTable: { \u0026#39;/api\u0026#39;: { target: \u0026#39;http://127.0.0.1:8080/\u0026#39;, changeOrigin: true, pathRewrite: { \u0026#39;^/api\u0026#39;: \u0026#39;/\u0026#39; } } }, 来解决开发环境跨域的问题,生产环境反正可以打包静态文件到springboot项目中直接跑.\n而我还是脑抽得选择了强行跨域,假装自己要把静态文件单独放个服务器跑\u0026hellip;为此遇到很多问题,折腾好几天.\n因此强力推荐上面的方案,简单快捷地解决跨域!\n如果生产环境真的需要跨域的话,再按下面方法设置\n大部分跨域的配置都能百度搜出来:\naxios要 withCredentials: true\n用session而不用啥特殊的token之类的话,就不用 config.headers['X-Token'] = getToken() ,这句是vueAdmin-template 中带的,需要删掉.\n后端需要配置允许跨域\n@Configuration public class CorsConfig { private CorsConfiguration buildConfig() { CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOrigin(\u0026#34;*\u0026#34;); // 1 设置访问源地址 corsConfiguration.addAllowedHeader(\u0026#34;*\u0026#34;); // 2 设置访问源请求头 corsConfiguration.addAllowedMethod(\u0026#34;*\u0026#34;); // 3 设置访问源请求方法 corsConfiguration.setAllowCredentials(true); return corsConfiguration; } @Bean public CorsFilter corsFilter() { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.","keywords":["java","springboot","shiro"],"articleBody":"​\t最近在做前后端分离的新框架,选用了后端springboot+shiro,前端vue+elementUI,第一次搭SSM之外的非demo项目,尤其shiro更是之前从未接触,折腾了很多天,遇到很多问题,大部分能百度出来,剩下的非常费时的问题且称之为坑吧.\n跨域 ​\t一大部分问题就是跨域造成的,本身vue-cli搭建的项目可以用\n// 1. axios的baseURL设置为/api // 2. 如下设置 proxyTable: { '/api': { target: 'http://127.0.0.1:8080/', changeOrigin: true, pathRewrite: { '^/api': '/' } } }, 来解决开发环境跨域的问题,生产环境反正可以打包静态文件到springboot项目中直接跑.\n而我还是脑抽得选择了强行跨域,假装自己要把静态文件单独放个服务器跑…为此遇到很多问题,折腾好几天.\n因此强力推荐上面的方案,简单快捷地解决跨域!\n如果生产环境真的需要跨域的话,再按下面方法设置\n大部分跨域的配置都能百度搜出来:\naxios要 withCredentials: true\n用session而不用啥特殊的token之类的话,就不用 config.headers['X-Token'] = getToken() ,这句是vueAdmin-template 中带的,需要删掉.\n后端需要配置允许跨域\n@Configuration public class CorsConfig { private CorsConfiguration buildConfig() { CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOrigin(\"*\"); // 1 设置访问源地址 corsConfiguration.addAllowedHeader(\"*\"); // 2 设置访问源请求头 corsConfiguration.addAllowedMethod(\"*\"); // 3 设置访问源请求方法 corsConfiguration.setAllowCredentials(true); return corsConfiguration; } @Bean public CorsFilter corsFilter() { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(\"/**\", buildConfig()); // 4 对接口配置跨域设置 return new CorsFilter(source); } } shiro拦截ajax返回json ​\tshiro拦截到需要登录而用户尚未的请求时,会重定向至 /login/auth (未配置时是login.jsp),而ajax是不允许重定向的,ajax会收到302错误码,报错\nFailed to load http://localhost:8080/test: Redirect from ‘http://localhost:8080/test’ to ‘http://localhost:8080/login/auth’ has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘http://localhost:9528’ is therefore not allowed access.\n因此我们需要对拦截器进行改造,不要它默认的重定向了,我们直接去response里把json写好输出给前端.\n自定义filter,(因为我的后端全部返回json,所以这里不判断是否ajax了)\npublic class AjaxPermissionsAuthorizationFilter extends FormAuthenticationFilter { @Override protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception { JSONObject jsonObject = new JSONObject(); jsonObject.put(\"returnMsg\", \"未登录或登录已失效\"); if (this.isLoginRequest(request, response)) { if (this.isLoginSubmission(request, response)) { return this.executeLogin(request, response); } else { return true; } } else { PrintWriter out = null; HttpServletResponse res = (HttpServletResponse) response; //下面这几行也是后面要讲的坑, 这里的Access-Control-Allow-Origin 设置为*的话,前端还是会报错. res.setHeader(\"Access-Control-Allow-Origin\", \"http://localhost:9528\"); // response1.setHeader(\"Access-Control-Allow-Origin\", \"*\"); res.setHeader(\"Access-Control-Allow-Credentials\", \"true\"); try { res.setCharacterEncoding(\"UTF-8\");//设置编码 res.setContentType(\"application/json\");//设置返回类型 out = response.getWriter(); out.println(jsonObject);//输出 } catch (Exception e) { } finally { if (null != out) { out.flush(); out.close(); } } return false; } } } 接下来就是最坑的地方了,拦截器的注入.\n原本搜到的方法是在ShiroConfiguration类中注入.\n@Bean(name = \"ajaxPermissionsAuthorizationFilter\") public AjaxPermissionsAuthorizationFilter ajaxPermissionsAuthorizationFilter(){ return new AjaxPermissionsAuthorizationFilter(); } //然后shiroFilterFactoryBean设置过滤器 Map\u003cString, Filter\u003e filterMap = new LinkedHashMap\u003c\u003e(); filterMap.put(\"authc\", new AjaxPermissionsAuthorizationFilter()); shiroFilterFactoryBean.setFilters(filterMap); 结果自定义的拦截器把所有的请求都拦截了,直接无视了我设置的\nfilterChainDefinitionMap.put(\"/\", \"anon\"); filterChainDefinitionMap.put(\"/static/**\", \"anon\"); filterChainDefinitionMap.put(\"/login/**\", \"anon\"); filterChainDefinitionMap.put(\"/error\", \"anon\"); filterChainDefinitionMap.put(\"/**\", \"authc\"); 各种百度,能搜到的相关的资料也就只有segmentfault的提问没解决,题主给我的回复也不能解决 , 百度知道提问的没解决 , 简书方案并不能解决 .\n最终在某个百度结果的第三页找到这篇博客 ,博主对问题一步一步的排查分析,debug源码,最终知道\nSpringboot 先加载了我们自定义的 Filter，然后再加载了 ShiroFilter\n解决方法: 在自定义的filter里加上下面的代码\n@Bean public FilterRegistrationBean registration(自定义Filter filter) { FilterRegistrationBean registration = new FilterRegistrationBean(filter); registration.setEnabled(false); return registration; } 在configration类里就不需要声明这个bean,只需要直接调用 filterMap.put(\"authc\", new 自定义Filter());\nAccess-Control-Allow-Origin 在上面的自定义filter里,\nres.setHeader(\"Access-Control-Allow-Origin\", \"http://localhost:9528\"); 如果设置为*的话,前端虽然可以收到json,但还是会报错\nFailed to load http://localhost:8080/test: The value of the ‘Access-Control-Allow-Origin’ header in the response must not be the wildcard ‘*’ when the request’s credentials mode is ‘include’. Origin ‘http://localhost:9528’ is therefore not allowed access. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.\n不允许设置为通配符* .\n虽然此处设置了\"http://localhost:9528\" 但是这种做法终究不合适.\n百度继续搜到此博客\n得到解决方法\nres.setHeader(\"Access-Control-Allow-Origin\", ((HttpServletRequest) request).getHeader(\"Origin\")); ","wordCount":"350","inLanguage":"en","datePublished":"2017-10-22T11:19:33Z","dateModified":"2017-10-22T11:19:33Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://heeexy.com/posts/build-springboot-shiro/"},"publisher":{"@type":"Organization","name":"网站标题","logo":{"@type":"ImageObject","url":"https://heeexy.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://heeexy.com/ accesskey=h title="网站标题 (Alt + H)">网站标题</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">搭建springboot-shiro-vue框架时遇到的坑</h1><div class=post-meta><span title='2017-10-22 11:19:33 +0000 UTC'>October 22, 2017</span></div></header><div class=post-content><p>​ 最近在做前后端分离的新框架,选用了后端springboot+shiro,前端vue+elementUI,第一次搭SSM之外的非demo项目,尤其shiro更是之前从未接触,折腾了很多天,遇到很多问题,大部分能百度出来,剩下的非常费时的问题且称之为坑吧.</p><h3 id=跨域>跨域<a hidden class=anchor aria-hidden=true href=#跨域>#</a></h3><p>​ 一大部分问题就是跨域造成的,本身vue-cli搭建的项目可以用</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 1. axios的baseURL设置为/api
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 2. 如下设置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>proxyTable</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#39;/api&#39;</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>target</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;http://127.0.0.1:8080/&#39;</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>changeOrigin</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>pathRewrite</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>          <span style=color:#e6db74>&#39;^/api&#39;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;/&#39;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    },
</span></span></code></pre></div><p>来解决开发环境跨域的问题,生产环境反正可以打包静态文件到springboot项目中直接跑.</p><p>而我还是脑抽得选择了强行跨域,假装自己要把静态文件单独放个服务器跑&mldr;为此遇到很多问题,折腾好几天.</p><p><strong>因此强力推荐上面的方案,简单快捷地解决跨域!</strong></p><p>如果生产环境真的需要跨域的话,再按下面方法设置</p><p>大部分跨域的配置都能百度搜出来:</p><ol><li><p>axios要 <code>withCredentials: true</code></p></li><li><p>用session而不用啥特殊的token之类的话,就不用 <code>config.headers['X-Token'] = getToken() </code>,这句是<a href=https://github.com/PanJiaChen/vueAdmin-template><strong>vueAdmin-template</strong></a> 中带的,需要删掉.</p></li><li><p>后端需要配置允许跨域</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Configuration</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CorsConfig</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> CorsConfiguration <span style=color:#a6e22e>buildConfig</span>() {
</span></span><span style=display:flex><span>        CorsConfiguration corsConfiguration <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CorsConfiguration();
</span></span><span style=display:flex><span>        corsConfiguration.<span style=color:#a6e22e>addAllowedOrigin</span>(<span style=color:#e6db74>&#34;*&#34;</span>); <span style=color:#75715e>// 1 设置访问源地址</span>
</span></span><span style=display:flex><span>        corsConfiguration.<span style=color:#a6e22e>addAllowedHeader</span>(<span style=color:#e6db74>&#34;*&#34;</span>); <span style=color:#75715e>// 2 设置访问源请求头</span>
</span></span><span style=display:flex><span>        corsConfiguration.<span style=color:#a6e22e>addAllowedMethod</span>(<span style=color:#e6db74>&#34;*&#34;</span>); <span style=color:#75715e>// 3 设置访问源请求方法</span>
</span></span><span style=display:flex><span>        corsConfiguration.<span style=color:#a6e22e>setAllowCredentials</span>(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> corsConfiguration;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> CorsFilter <span style=color:#a6e22e>corsFilter</span>() {
</span></span><span style=display:flex><span>        UrlBasedCorsConfigurationSource source <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> UrlBasedCorsConfigurationSource();
</span></span><span style=display:flex><span>        source.<span style=color:#a6e22e>registerCorsConfiguration</span>(<span style=color:#e6db74>&#34;/**&#34;</span>, buildConfig()); <span style=color:#75715e>// 4 对接口配置跨域设置</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> CorsFilter(source);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ol><h3 id=shiro拦截ajax返回json>shiro拦截ajax返回json<a hidden class=anchor aria-hidden=true href=#shiro拦截ajax返回json>#</a></h3><p>​ shiro拦截到需要登录而用户尚未的请求时,会重定向至 /login/auth (未配置时是login.jsp),而ajax是不允许重定向的,ajax会收到302错误码,报错</p><blockquote><p>Failed to load http://localhost:8080/test: Redirect from &lsquo;http://localhost:8080/test&rsquo; to &lsquo;http://localhost:8080/login/auth&rsquo; has been blocked by CORS policy: No &lsquo;Access-Control-Allow-Origin&rsquo; header is present on the requested resource. Origin &lsquo;http://localhost:9528&rsquo; is therefore not allowed access.</p></blockquote><p>因此我们需要对拦截器进行改造,不要它默认的重定向了,我们直接去response里把json写好输出给前端.</p><p>自定义filter,(因为我的后端全部返回json,所以这里不判断是否ajax了)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AjaxPermissionsAuthorizationFilter</span> <span style=color:#66d9ef>extends</span> FormAuthenticationFilter {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>onAccessDenied</span>(ServletRequest request, ServletResponse response) <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        JSONObject jsonObject <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> JSONObject();
</span></span><span style=display:flex><span>        jsonObject.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;returnMsg&#34;</span>, <span style=color:#e6db74>&#34;未登录或登录已失效&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>isLoginRequest</span>(request, response)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>isLoginSubmission</span>(request, response)) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>executeLogin</span>(request, response);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            PrintWriter out <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            HttpServletResponse res <span style=color:#f92672>=</span> (HttpServletResponse) response;
</span></span><span style=display:flex><span>           	<span style=color:#75715e>//下面这几行也是后面要讲的坑, 这里的Access-Control-Allow-Origin 设置为*的话,前端还是会报错. </span>
</span></span><span style=display:flex><span>            res.<span style=color:#a6e22e>setHeader</span>(<span style=color:#e6db74>&#34;Access-Control-Allow-Origin&#34;</span>, <span style=color:#e6db74>&#34;http://localhost:9528&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#75715e>//  response1.setHeader(&#34;Access-Control-Allow-Origin&#34;, &#34;*&#34;);</span>
</span></span><span style=display:flex><span>            res.<span style=color:#a6e22e>setHeader</span>(<span style=color:#e6db74>&#34;Access-Control-Allow-Credentials&#34;</span>, <span style=color:#e6db74>&#34;true&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                res.<span style=color:#a6e22e>setCharacterEncoding</span>(<span style=color:#e6db74>&#34;UTF-8&#34;</span>);<span style=color:#75715e>//设置编码</span>
</span></span><span style=display:flex><span>                res.<span style=color:#a6e22e>setContentType</span>(<span style=color:#e6db74>&#34;application/json&#34;</span>);<span style=color:#75715e>//设置返回类型</span>
</span></span><span style=display:flex><span>                out <span style=color:#f92672>=</span> response.<span style=color:#a6e22e>getWriter</span>();
</span></span><span style=display:flex><span>                out.<span style=color:#a6e22e>println</span>(jsonObject);<span style=color:#75715e>//输出</span>
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>null</span> <span style=color:#f92672>!=</span> out) {
</span></span><span style=display:flex><span>                    out.<span style=color:#a6e22e>flush</span>();
</span></span><span style=display:flex><span>                    out.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>接下来就是最坑的地方了,拦截器的注入.</p><p><a href=http://m.blog.csdn.net/u014042146/article/details/72834582>原本搜到的方法</a>是在ShiroConfiguration类中注入.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>	<span style=color:#a6e22e>@Bean</span>(name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;ajaxPermissionsAuthorizationFilter&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> AjaxPermissionsAuthorizationFilter <span style=color:#a6e22e>ajaxPermissionsAuthorizationFilter</span>(){
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> AjaxPermissionsAuthorizationFilter();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>//然后shiroFilterFactoryBean设置过滤器</span>
</span></span><span style=display:flex><span>  		Map<span style=color:#f92672>&lt;</span>String, Filter<span style=color:#f92672>&gt;</span> filterMap <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LinkedHashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        filterMap.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;authc&#34;</span>, <span style=color:#66d9ef>new</span> AjaxPermissionsAuthorizationFilter());
</span></span><span style=display:flex><span>        shiroFilterFactoryBean.<span style=color:#a6e22e>setFilters</span>(filterMap);
</span></span></code></pre></div><p>结果自定义的拦截器把所有的请求都拦截了,直接无视了我设置的</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>filterChainDefinitionMap.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;/&#34;</span>, <span style=color:#e6db74>&#34;anon&#34;</span>);
</span></span><span style=display:flex><span>filterChainDefinitionMap.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;/static/**&#34;</span>, <span style=color:#e6db74>&#34;anon&#34;</span>);
</span></span><span style=display:flex><span>filterChainDefinitionMap.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;/login/**&#34;</span>, <span style=color:#e6db74>&#34;anon&#34;</span>);
</span></span><span style=display:flex><span>filterChainDefinitionMap.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;/error&#34;</span>, <span style=color:#e6db74>&#34;anon&#34;</span>);
</span></span><span style=display:flex><span>filterChainDefinitionMap.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;/**&#34;</span>, <span style=color:#e6db74>&#34;authc&#34;</span>);
</span></span></code></pre></div><p>各种百度,能搜到的相关的资料也就只有<a href=https://segmentfault.com/q/1010000010747919>segmentfault的提问没解决,题主给我的回复也不能解决</a> , <a href=https://zhidao.baidu.com/question/436777330932025604.html>百度知道提问的没解决</a> , <a href=http://www.jianshu.com/p/e30dc5e78641>简书方案并不能解决</a> .</p><p>最终在某个百度结果的第三页找到<a href=http://www.hillfly.com/2017/179.html>这篇博客</a> ,博主对问题一步一步的排查分析,debug源码,最终知道</p><p><strong>Springboot 先加载了我们自定义的 Filter，然后再加载了 ShiroFilter</strong></p><p>解决方法:
在自定义的filter里加上下面的代码</p><pre tabindex=0><code>@Bean
public FilterRegistrationBean registration(自定义Filter filter) {
    FilterRegistrationBean registration = new FilterRegistrationBean(filter);
    registration.setEnabled(false);
    return registration;
}
</code></pre><p>在configration类里就不需要声明这个bean,只需要直接调用 <code>filterMap.put("authc", new 自定义Filter());</code></p><h3 id=access-control-allow-origin>Access-Control-Allow-Origin<a hidden class=anchor aria-hidden=true href=#access-control-allow-origin>#</a></h3><p>在上面的自定义filter里,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span> res.<span style=color:#a6e22e>setHeader</span>(<span style=color:#e6db74>&#34;Access-Control-Allow-Origin&#34;</span>, <span style=color:#e6db74>&#34;http://localhost:9528&#34;</span>);
</span></span></code></pre></div><p>如果设置为*的话,前端虽然可以收到json,但还是会报错</p><blockquote><p>Failed to load http://localhost:8080/test: The value of the &lsquo;Access-Control-Allow-Origin&rsquo; header in the response must not be the wildcard &lsquo;*&rsquo; when the request&rsquo;s credentials mode is &lsquo;include&rsquo;. Origin &lsquo;http://localhost:9528&rsquo; is therefore not allowed access. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.</p></blockquote><p>不允许设置为通配符* .</p><p>虽然此处设置了"http://localhost:9528" 但是这种做法终究不合适.</p><p>百度继续搜到<a href=http://blog.csdn.net/u011517841/article/details/68490586>此博客</a></p><p>得到解决方法</p><pre tabindex=0><code>res.setHeader(&#34;Access-Control-Allow-Origin&#34;, ((HttpServletRequest) request).getHeader(&#34;Origin&#34;));
</code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=https://heeexy.com/tags/java/>Java</a></li><li><a href=https://heeexy.com/tags/springboot/>Springboot</a></li><li><a href=https://heeexy.com/tags/shiro/>Shiro</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://heeexy.com/>网站标题</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>