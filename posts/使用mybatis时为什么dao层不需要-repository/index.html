<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="# 问题 Service层注入Dao时， Intellij 总会以红色波浪线提示我们 @Autowired private UserDao userDao; Could not autowire. No beans of &lsquo;UserDao&rsquo; type found. Checks autowiring problems in a bean class. 尽管我们都知道 Dao 层的 Bean 实际上都是有的，并且可以设置关闭这恼人的提示，但是我们有没有想过为什么 Intellij 就找不到这个 Bean 呢？甚至有人有这种做法 @Repository public interface UserDao { } 来避免提示，但是这种做法正确么？ 所以今天我们的疑问就是 为什么 Dao 层不需要加 @Repository 注解，源码里到底做了什么？ 加了 @Repository 注解有什么影响？ # 答案 关键在于 ClassPathMapperScanner 对指定包的扫描，并且扫描过程对 Spring 原本的扫描 Bean 的步骤 &ldquo;加了料” ，Spring 本身只扫实现类，但 MyBatis 的扫描器扫了接口 。并且扫完接口之后，为接口配了个 BeanDefinition ,并且这个 bd 的 BeanClass 是 MapperFactoryBean 。"><title>使用MyBatis时为什么Dao层不需要@Repository</title>
<link rel=canonical href=https://heeexy.com/posts/%E4%BD%BF%E7%94%A8mybatis%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88dao%E5%B1%82%E4%B8%8D%E9%9C%80%E8%A6%81-repository/><link rel=stylesheet href=/scss/style.min.760e3dabc1e140d2e6abd27a8ca0aabb60e568829b29f67d2df12024136eff37.css><meta property='og:title' content="使用MyBatis时为什么Dao层不需要@Repository"><meta property='og:description' content="# 问题 Service层注入Dao时， Intellij 总会以红色波浪线提示我们 @Autowired private UserDao userDao; Could not autowire. No beans of &lsquo;UserDao&rsquo; type found. Checks autowiring problems in a bean class. 尽管我们都知道 Dao 层的 Bean 实际上都是有的，并且可以设置关闭这恼人的提示，但是我们有没有想过为什么 Intellij 就找不到这个 Bean 呢？甚至有人有这种做法 @Repository public interface UserDao { } 来避免提示，但是这种做法正确么？ 所以今天我们的疑问就是 为什么 Dao 层不需要加 @Repository 注解，源码里到底做了什么？ 加了 @Repository 注解有什么影响？ # 答案 关键在于 ClassPathMapperScanner 对指定包的扫描，并且扫描过程对 Spring 原本的扫描 Bean 的步骤 &ldquo;加了料” ，Spring 本身只扫实现类，但 MyBatis 的扫描器扫了接口 。并且扫完接口之后，为接口配了个 BeanDefinition ,并且这个 bd 的 BeanClass 是 MapperFactoryBean 。"><meta property='og:url' content='https://heeexy.com/posts/%E4%BD%BF%E7%94%A8mybatis%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88dao%E5%B1%82%E4%B8%8D%E9%9C%80%E8%A6%81-repository/'><meta property='og:site_name' content='网站标题'><meta property='og:type' content='article'><meta property='article:section' content='Posts'><meta property='article:tag' content='java'><meta property='article:tag' content='Spring'><meta property='article:tag' content='MyBatis'><meta property='article:published_time' content='2018-04-03T17:07:46+00:00'><meta property='article:modified_time' content='2018-04-03T17:07:46+00:00'><meta name=twitter:title content="使用MyBatis时为什么Dao层不需要@Repository"><meta name=twitter:description content="# 问题 Service层注入Dao时， Intellij 总会以红色波浪线提示我们 @Autowired private UserDao userDao; Could not autowire. No beans of &lsquo;UserDao&rsquo; type found. Checks autowiring problems in a bean class. 尽管我们都知道 Dao 层的 Bean 实际上都是有的，并且可以设置关闭这恼人的提示，但是我们有没有想过为什么 Intellij 就找不到这个 Bean 呢？甚至有人有这种做法 @Repository public interface UserDao { } 来避免提示，但是这种做法正确么？ 所以今天我们的疑问就是 为什么 Dao 层不需要加 @Repository 注解，源码里到底做了什么？ 加了 @Repository 注解有什么影响？ # 答案 关键在于 ClassPathMapperScanner 对指定包的扫描，并且扫描过程对 Spring 原本的扫描 Bean 的步骤 &ldquo;加了料” ，Spring 本身只扫实现类，但 MyBatis 的扫描器扫了接口 。并且扫完接口之后，为接口配了个 BeanDefinition ,并且这个 bd 的 BeanClass 是 MapperFactoryBean 。"></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column compact"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_huda2458f72ce188392d75c5d51cd8e24e_373_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>网站标题</a></h1><h2 class=site-description></h2></div></header><ol class=menu id=main-menu><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/posts/%E4%BD%BF%E7%94%A8mybatis%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88dao%E5%B1%82%E4%B8%8D%E9%9C%80%E8%A6%81-repository/>使用MyBatis时为什么Dao层不需要@Repository</a></h2></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Apr 03, 2018</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>2 minute read</time></div></footer></div></header><section class=article-content><h1 id=问题><a href=#%e9%97%ae%e9%a2%98 class=header-anchor>#</a>
问题</h1><p>Service层注入Dao时， Intellij 总会以红色波浪线提示我们</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> UserDao userDao;
</span></span></code></pre></div><p>Could not autowire. No beans of &lsquo;UserDao&rsquo; type found.
Checks autowiring problems in a bean class.</p><p>尽管我们都知道 Dao 层的 Bean 实际上都是有的，并且可以设置关闭这恼人的提示，但是我们有没有想过为什么 Intellij 就找不到这个 Bean 呢？甚至有人有这种做法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Repository</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>UserDao</span> {
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>来避免提示，但是这种做法正确么？</p><p>所以今天我们的疑问就是</p><ol><li>为什么 Dao 层不需要加 @Repository 注解，源码里到底做了什么？</li><li>加了 @Repository 注解有什么影响？</li></ol><h1 id=答案><a href=#%e7%ad%94%e6%a1%88 class=header-anchor>#</a>
答案</h1><ol><li><p>关键在于 ClassPathMapperScanner 对指定包的扫描，并且扫描过程对 Spring 原本的扫描 Bean 的步骤 &ldquo;加了料” ，Spring 本身只扫实现类，但 MyBatis 的扫描器<strong>扫了接口</strong> 。并且扫完接口之后，为接口配了个 <strong>BeanDefinition</strong> ,并且这个 bd 的 BeanClass 是 <strong>MapperFactoryBean</strong> 。</p><blockquote><p>对于 BeanDefinition 和 MapperFactoryBean 不了解的同学请查询相关资料和源码</p></blockquote></li><li><p>仅仅只能解决 Intellij 静态查找 bean 的问题，没有实际作用。即使加了注解，比如@Controller，@Service 等等，也会被 Spring 的扫描器给忽略掉，因为<strong>扫描器会过滤掉接口</strong>。</p></li></ol><h1 id=源码探索><a href=#%e6%ba%90%e7%a0%81%e6%8e%a2%e7%b4%a2 class=header-anchor>#</a>
源码探索</h1><blockquote><p>下面的源码部分如果读者提前有 MyBatis 的 Bean 的执行流程，和 Spring 的 Bean加载的相关知识就更好理解。</p></blockquote><h3 id=1-分析问题><a href=#1-%e5%88%86%e6%9e%90%e9%97%ae%e9%a2%98 class=header-anchor>#</a>
1. 分析问题</h3><p>关于为什么不需要注解就能获取到 Dao 层的 Bean，看似答案很简单，因为配置了扫描指定这个包里的 xxxDao.class 啊，比如使用注解 @MapperScan(&ldquo;com.example.dao&rdquo;)。</p><p>这个答案太过表面，觉得问题简单只是因为对 Spring 的 Bean 不熟悉。</p><p>我们何时见过 @Component 及其衍生的3个注解 @Controller、@Service、@Repository <strong>加在接口上面</strong>的？</p><p>自己测试新建个接口，上面加注解，然后找个 Controller 里 @Autowired 注入一下，项目立马会报错 NoSuchBeanDefinitionException 。</p><h3 id=2-切入源码><a href=#2-%e5%88%87%e5%85%a5%e6%ba%90%e7%a0%81 class=header-anchor>#</a>
2. 切入源码</h3><h4 id=切入点><a href=#%e5%88%87%e5%85%a5%e7%82%b9 class=header-anchor>#</a>
切入点</h4><p>既然使用注解 @MapperScan 就好使，那么我们就从这个点切入源码看一下，先找出源码中何处用了此注解，非常幸运的是，只有一处用到了此注解 ：MapperScannerRegistrar.registerBeanDefinitions() 。</p><p>并且从类名和方法名就可以很清楚的看出这个类的功能是扫描 Mapper 并注册，方法的功能就是注册 BeanDefinitions 到 Spring 中。方法的源码我就不贴了，很容易看出来是创建一个扫描器 <code>ClassPathMapperScanner</code> ，设置好一系列属性比如 Spring 的注册表之后，执行 doScan() 方法去扫描 @MapperScan 提供的包。</p><h4 id=doscan-扫描资源转换为-beandefinition><a href=#doscan-%e6%89%ab%e6%8f%8f%e8%b5%84%e6%ba%90%e8%bd%ac%e6%8d%a2%e4%b8%ba-beandefinition class=header-anchor>#</a>
doScan() 扫描资源，转换为 BeanDefinition</h4><p>doScan() 方法也很简单，就是两步：</p><ol><li>调用父类 ClassPathBeanDefinitionScanner 的doScan()方法，也就是 Spring 扫描BeanDefinition 的方法。过程不是很重要，我们需要知道这个扫描方法的一个关键就是</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Set<span style=color:#f92672>&lt;</span>BeanDefinition<span style=color:#f92672>&gt;</span> candidates <span style=color:#f92672>=</span> findCandidateComponents(basePackage);
</span></span></code></pre></div><p>在其中对所有的候选者使用 isCandidateComponent() 方法判断是否为符合要求的 BeanDefinition。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>for</span> (TypeFilter tf : <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>excludeFilters</span>) {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> (tf.<span style=color:#a6e22e>match</span>(metadataReader, <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>metadataReaderFactory</span>)) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (TypeFilter tf : <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>includeFilters</span>) {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> (tf.<span style=color:#a6e22e>match</span>(metadataReader, <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>metadataReaderFactory</span>)) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> isConditionMatch(metadataReader);
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这有两组过滤器来过滤扫描到的资源。<strong>Spring 默认的过滤器是排除掉抽象类/接口的。而MyBatis 的扫描器重新注册了过滤器，默认对接口放行。</strong></p><blockquote><p>其实还有一些其它的过滤要求，但是不影响我们本问题的探究，所以不深入解读了。</p></blockquote><p>源码读到这里，我们先找到了本文的第二个问题的答案。也就是 Spring 会忽略掉接口上面的注解，不会添加它进入 BeanDefiniiton ,也就难怪测试的时候会抛出 NoSuchBeanDefinitionException 的异常了。而 MyBatis 则会把这些接口拉过来注册BD 。</p><h4 id=对-beandefinition-的加工><a href=#%e5%af%b9-beandefinition-%e7%9a%84%e5%8a%a0%e5%b7%a5 class=header-anchor>#</a>
对 BeanDefinition 的加工</h4><p>读到这里我们可能有了更大的疑问，拿接口注册 BeanDefinition ，那获取 Bean 的时候如何去实例化这个对象啊？接口可是不能实例化出对象的啊，而且我们也没有做实现。</p><p>原来是 MyBatis 的扫描器在调用完父类的扫描方法后，对 BeanDefinition 进行了加工 processBeanDefinitions() 。其中最关键的两行代码是</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>definition.<span style=color:#a6e22e>getConstructorArgumentValues</span>().<span style=color:#a6e22e>addGenericArgumentValue</span>(definition.<span style=color:#a6e22e>getBeanClassName</span>()); 
</span></span><span style=display:flex><span>definition.<span style=color:#a6e22e>setBeanClass</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>mapperFactoryBean</span>.<span style=color:#a6e22e>getClass</span>());
</span></span></code></pre></div><p>第一行，我们发现把这个<strong>接口的类名塞到了构造器参数中</strong>。</p><blockquote><p>小彩蛋，这里塞的是 String ，而我们的构造器参数其实要的是 Class 。但是 Spring 的 ConstructorResolver.autowireConstructor 中用到了 Object[] argsToUse 去做了个转换 。</p></blockquote><p>第二行，beanDefinition 的 <strong>BeanClass 被设置成了 MapperFactoryBean</strong> !</p><p>熟悉 Spring 和 MyBatis 的读者肯定一下就明白了，就是这个地方进行了"偷梁换柱&rdquo;！</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> UserDao userDao;
</span></span></code></pre></div><p>还是拿 UserDao 为例，我们向 Spring 容器说 &ldquo;给我来个 UserDao 的实例&rdquo;，而 Spring 根据注册时候的 BeanDefinition ，去工厂( <strong>MapperFactoryBean</strong> )里面扔了个 UserDao.class 的参数进去，工厂的 getObject() 方法给我们返回了它制造的 userDao 。</p><p>就这样，我们没有去写实现类，轻轻松松拿到了我们需要的 userDao 。</p><p>至于 <strong>MapperFactoryBean</strong> 里做了什么返回了 userDao 出来？其实就是它的 getObject 方法返回的是 DefaultSqlSession.getMapper(Class type)方法，返回的是 MapperProxy 代理的类，而这个代理类的 invoke 方法并不像我们平时见到的代理中的 invoke 方法一样调用原始目标的 method.invoke ，而是去找 MapperMethod 执行了。</p><h1 id=收获><a href=#%e6%94%b6%e8%8e%b7 class=header-anchor>#</a>
收获</h1><p>这次的源码探究下来，收获的不仅仅是了解了 Dao 层 Bean 的注入，更是串起了我们最常用的 Spring 和 MyBatis ，换句话说，我们打通了从 Service 层到 Dao 层。</p><p>在以往 Debug 代码时看到的 MapperProxy，MapperMethod，我们清楚了这是从何而来，也对 MyBatis 中代理的巧妙运用更加熟悉。</p><h1 id=参考文献><a href=#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae class=header-anchor>#</a>
参考文献</h1><p><a class=link href=https://blog.csdn.net/java280580332/article/details/72123890 target=_blank rel=noopener>https://blog.csdn.net/java280580332/article/details/72123890</a></p><p><a class=link href=https://blog.csdn.net/mingtian625/article/details/47684271 target=_blank rel=noopener>https://blog.csdn.net/mingtian625/article/details/47684271</a></p></section><footer class=article-footer><section class=article-tags><a href=/tags/java/>Java</a>
<a href=/tags/spring/>Spring</a>
<a href=/tags/mybatis/>MyBatis</a></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/posts/mybatis%E6%97%A5%E5%BF%97--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/><div class=article-details><h2 class=article-title>MyBatis 的日志设计--适配器模式 & 工厂模式</h2></div></a></article><article><a href=/posts/spring-note-18-ioc/><div class=article-details><h2 class=article-title>极简 Spring 框架 -- 浅析循环依赖</h2></div></a></article><article><a href=/posts/spring-note-16-beannamesfortypeincludingancestors/><div class=article-details><h2 class=article-title>Spring 源码笔记-2.8 根据类型寻找 bean--找出所有匹配类型的 beanName</h2></div></a></article><article><a href=/posts/spring-note-15-findautowirecandidates/><div class=article-details><h2 class=article-title>Spring 源码笔记-2.7 根据类型寻找 bean</h2></div></a></article><article><a href=/posts/spring-note-14-beanwrapper/><div class=article-details><h2 class=article-title>Spring 源码笔记-2.6 BeanWrapper 对比 MyBatis</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2024 网站标题</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.25.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>