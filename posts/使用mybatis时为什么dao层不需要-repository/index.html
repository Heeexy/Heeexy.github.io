<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>使用MyBatis时为什么Dao层不需要@Repository | 网站标题</title>
<meta name=keywords content="java,Spring,MyBatis"><meta name=description content="问题 Service层注入Dao时， Intellij 总会以红色波浪线提示我们
@Autowired private UserDao userDao; Could not autowire. No beans of &lsquo;UserDao&rsquo; type found. Checks autowiring problems in a bean class.
尽管我们都知道 Dao 层的 Bean 实际上都是有的，并且可以设置关闭这恼人的提示，但是我们有没有想过为什么 Intellij 就找不到这个 Bean 呢？甚至有人有这种做法
@Repository public interface UserDao { } 来避免提示，但是这种做法正确么？
所以今天我们的疑问就是
为什么 Dao 层不需要加 @Repository 注解，源码里到底做了什么？ 加了 @Repository 注解有什么影响？ 答案 关键在于 ClassPathMapperScanner 对指定包的扫描，并且扫描过程对 Spring 原本的扫描 Bean 的步骤 &ldquo;加了料” ，Spring 本身只扫实现类，但 MyBatis 的扫描器扫了接口 。并且扫完接口之后，为接口配了个 BeanDefinition ,并且这个 bd 的 BeanClass 是 MapperFactoryBean 。"><meta name=author content><link rel=canonical href=https://heeexy.com/posts/%E4%BD%BF%E7%94%A8mybatis%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88dao%E5%B1%82%E4%B8%8D%E9%9C%80%E8%A6%81-repository/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://heeexy.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://heeexy.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://heeexy.com/favicon-32x32.png><link rel=apple-touch-icon href=https://heeexy.com/apple-touch-icon.png><link rel=mask-icon href=https://heeexy.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://heeexy.com/posts/%E4%BD%BF%E7%94%A8mybatis%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88dao%E5%B1%82%E4%B8%8D%E9%9C%80%E8%A6%81-repository/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="使用MyBatis时为什么Dao层不需要@Repository"><meta property="og:description" content="问题 Service层注入Dao时， Intellij 总会以红色波浪线提示我们
@Autowired private UserDao userDao; Could not autowire. No beans of &lsquo;UserDao&rsquo; type found. Checks autowiring problems in a bean class.
尽管我们都知道 Dao 层的 Bean 实际上都是有的，并且可以设置关闭这恼人的提示，但是我们有没有想过为什么 Intellij 就找不到这个 Bean 呢？甚至有人有这种做法
@Repository public interface UserDao { } 来避免提示，但是这种做法正确么？
所以今天我们的疑问就是
为什么 Dao 层不需要加 @Repository 注解，源码里到底做了什么？ 加了 @Repository 注解有什么影响？ 答案 关键在于 ClassPathMapperScanner 对指定包的扫描，并且扫描过程对 Spring 原本的扫描 Bean 的步骤 &ldquo;加了料” ，Spring 本身只扫实现类，但 MyBatis 的扫描器扫了接口 。并且扫完接口之后，为接口配了个 BeanDefinition ,并且这个 bd 的 BeanClass 是 MapperFactoryBean 。"><meta property="og:type" content="article"><meta property="og:url" content="https://heeexy.com/posts/%E4%BD%BF%E7%94%A8mybatis%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88dao%E5%B1%82%E4%B8%8D%E9%9C%80%E8%A6%81-repository/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-04-03T17:07:46+00:00"><meta property="article:modified_time" content="2018-04-03T17:07:46+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="使用MyBatis时为什么Dao层不需要@Repository"><meta name=twitter:description content="问题 Service层注入Dao时， Intellij 总会以红色波浪线提示我们
@Autowired private UserDao userDao; Could not autowire. No beans of &lsquo;UserDao&rsquo; type found. Checks autowiring problems in a bean class.
尽管我们都知道 Dao 层的 Bean 实际上都是有的，并且可以设置关闭这恼人的提示，但是我们有没有想过为什么 Intellij 就找不到这个 Bean 呢？甚至有人有这种做法
@Repository public interface UserDao { } 来避免提示，但是这种做法正确么？
所以今天我们的疑问就是
为什么 Dao 层不需要加 @Repository 注解，源码里到底做了什么？ 加了 @Repository 注解有什么影响？ 答案 关键在于 ClassPathMapperScanner 对指定包的扫描，并且扫描过程对 Spring 原本的扫描 Bean 的步骤 &ldquo;加了料” ，Spring 本身只扫实现类，但 MyBatis 的扫描器扫了接口 。并且扫完接口之后，为接口配了个 BeanDefinition ,并且这个 bd 的 BeanClass 是 MapperFactoryBean 。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://heeexy.com/posts/"},{"@type":"ListItem","position":2,"name":"使用MyBatis时为什么Dao层不需要@Repository","item":"https://heeexy.com/posts/%E4%BD%BF%E7%94%A8mybatis%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88dao%E5%B1%82%E4%B8%8D%E9%9C%80%E8%A6%81-repository/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"使用MyBatis时为什么Dao层不需要@Repository","name":"使用MyBatis时为什么Dao层不需要@Repository","description":"问题 Service层注入Dao时， Intellij 总会以红色波浪线提示我们\n@Autowired private UserDao userDao; Could not autowire. No beans of \u0026lsquo;UserDao\u0026rsquo; type found. Checks autowiring problems in a bean class.\n尽管我们都知道 Dao 层的 Bean 实际上都是有的，并且可以设置关闭这恼人的提示，但是我们有没有想过为什么 Intellij 就找不到这个 Bean 呢？甚至有人有这种做法\n@Repository public interface UserDao { } 来避免提示，但是这种做法正确么？\n所以今天我们的疑问就是\n为什么 Dao 层不需要加 @Repository 注解，源码里到底做了什么？ 加了 @Repository 注解有什么影响？ 答案 关键在于 ClassPathMapperScanner 对指定包的扫描，并且扫描过程对 Spring 原本的扫描 Bean 的步骤 \u0026ldquo;加了料” ，Spring 本身只扫实现类，但 MyBatis 的扫描器扫了接口 。并且扫完接口之后，为接口配了个 BeanDefinition ,并且这个 bd 的 BeanClass 是 MapperFactoryBean 。","keywords":["java","Spring","MyBatis"],"articleBody":"问题 Service层注入Dao时， Intellij 总会以红色波浪线提示我们\n@Autowired private UserDao userDao; Could not autowire. No beans of ‘UserDao’ type found. Checks autowiring problems in a bean class.\n尽管我们都知道 Dao 层的 Bean 实际上都是有的，并且可以设置关闭这恼人的提示，但是我们有没有想过为什么 Intellij 就找不到这个 Bean 呢？甚至有人有这种做法\n@Repository public interface UserDao { } 来避免提示，但是这种做法正确么？\n所以今天我们的疑问就是\n为什么 Dao 层不需要加 @Repository 注解，源码里到底做了什么？ 加了 @Repository 注解有什么影响？ 答案 关键在于 ClassPathMapperScanner 对指定包的扫描，并且扫描过程对 Spring 原本的扫描 Bean 的步骤 “加了料” ，Spring 本身只扫实现类，但 MyBatis 的扫描器扫了接口 。并且扫完接口之后，为接口配了个 BeanDefinition ,并且这个 bd 的 BeanClass 是 MapperFactoryBean 。\n对于 BeanDefinition 和 MapperFactoryBean 不了解的同学请查询相关资料和源码\n仅仅只能解决 Intellij 静态查找 bean 的问题，没有实际作用。即使加了注解，比如@Controller，@Service 等等，也会被 Spring 的扫描器给忽略掉，因为扫描器会过滤掉接口。\n源码探索 下面的源码部分如果读者提前有 MyBatis 的 Bean 的执行流程，和 Spring 的 Bean加载的相关知识就更好理解。\n1. 分析问题 关于为什么不需要注解就能获取到 Dao 层的 Bean，看似答案很简单，因为配置了扫描指定这个包里的 xxxDao.class 啊，比如使用注解 @MapperScan(“com.example.dao”)。\n这个答案太过表面，觉得问题简单只是因为对 Spring 的 Bean 不熟悉。\n我们何时见过 @Component 及其衍生的3个注解 @Controller、@Service、@Repository 加在接口上面的？\n自己测试新建个接口，上面加注解，然后找个 Controller 里 @Autowired 注入一下，项目立马会报错 NoSuchBeanDefinitionException 。\n2. 切入源码 切入点 既然使用注解 @MapperScan 就好使，那么我们就从这个点切入源码看一下，先找出源码中何处用了此注解，非常幸运的是，只有一处用到了此注解 ：MapperScannerRegistrar.registerBeanDefinitions() 。\n并且从类名和方法名就可以很清楚的看出这个类的功能是扫描 Mapper 并注册，方法的功能就是注册 BeanDefinitions 到 Spring 中。方法的源码我就不贴了，很容易看出来是创建一个扫描器 ClassPathMapperScanner ，设置好一系列属性比如 Spring 的注册表之后，执行 doScan() 方法去扫描 @MapperScan 提供的包。\ndoScan() 扫描资源，转换为 BeanDefinition doScan() 方法也很简单，就是两步：\n调用父类 ClassPathBeanDefinitionScanner 的doScan()方法，也就是 Spring 扫描BeanDefinition 的方法。过程不是很重要，我们需要知道这个扫描方法的一个关键就是 Set\u003cBeanDefinition\u003e candidates = findCandidateComponents(basePackage); 在其中对所有的候选者使用 isCandidateComponent() 方法判断是否为符合要求的 BeanDefinition。\nfor (TypeFilter tf : this.excludeFilters) { if (tf.match(metadataReader, this.metadataReaderFactory)) { return false; } } for (TypeFilter tf : this.includeFilters) { if (tf.match(metadataReader, this.metadataReaderFactory)) { return isConditionMatch(metadataReader); } } 这有两组过滤器来过滤扫描到的资源。Spring 默认的过滤器是排除掉抽象类/接口的。而MyBatis 的扫描器重新注册了过滤器，默认对接口放行。\n其实还有一些其它的过滤要求，但是不影响我们本问题的探究，所以不深入解读了。\n源码读到这里，我们先找到了本文的第二个问题的答案。也就是 Spring 会忽略掉接口上面的注解，不会添加它进入 BeanDefiniiton ,也就难怪测试的时候会抛出 NoSuchBeanDefinitionException 的异常了。而 MyBatis 则会把这些接口拉过来注册BD 。\n对 BeanDefinition 的加工 读到这里我们可能有了更大的疑问，拿接口注册 BeanDefinition ，那获取 Bean 的时候如何去实例化这个对象啊？接口可是不能实例化出对象的啊，而且我们也没有做实现。\n原来是 MyBatis 的扫描器在调用完父类的扫描方法后，对 BeanDefinition 进行了加工 processBeanDefinitions() 。其中最关键的两行代码是\ndefinition.getConstructorArgumentValues().addGenericArgumentValue(definition.getBeanClassName()); definition.setBeanClass(this.mapperFactoryBean.getClass()); 第一行，我们发现把这个接口的类名塞到了构造器参数中。\n小彩蛋，这里塞的是 String ，而我们的构造器参数其实要的是 Class 。但是 Spring 的 ConstructorResolver.autowireConstructor 中用到了 Object[] argsToUse 去做了个转换 。\n第二行，beanDefinition 的 BeanClass 被设置成了 MapperFactoryBean !\n熟悉 Spring 和 MyBatis 的读者肯定一下就明白了，就是这个地方进行了\"偷梁换柱”！\n@Autowired private UserDao userDao; 还是拿 UserDao 为例，我们向 Spring 容器说 “给我来个 UserDao 的实例”，而 Spring 根据注册时候的 BeanDefinition ，去工厂( MapperFactoryBean )里面扔了个 UserDao.class 的参数进去，工厂的 getObject() 方法给我们返回了它制造的 userDao 。\n就这样，我们没有去写实现类，轻轻松松拿到了我们需要的 userDao 。\n至于 MapperFactoryBean 里做了什么返回了 userDao 出来？其实就是它的 getObject 方法返回的是 DefaultSqlSession.getMapper(Class type)方法，返回的是 MapperProxy 代理的类，而这个代理类的 invoke 方法并不像我们平时见到的代理中的 invoke 方法一样调用原始目标的 method.invoke ，而是去找 MapperMethod 执行了。\n收获 这次的源码探究下来，收获的不仅仅是了解了 Dao 层 Bean 的注入，更是串起了我们最常用的 Spring 和 MyBatis ，换句话说，我们打通了从 Service 层到 Dao 层。\n在以往 Debug 代码时看到的 MapperProxy，MapperMethod，我们清楚了这是从何而来，也对 MyBatis 中代理的巧妙运用更加熟悉。\n参考文献 https://blog.csdn.net/java280580332/article/details/72123890\nhttps://blog.csdn.net/mingtian625/article/details/47684271\n","wordCount":"314","inLanguage":"en","datePublished":"2018-04-03T17:07:46Z","dateModified":"2018-04-03T17:07:46Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://heeexy.com/posts/%E4%BD%BF%E7%94%A8mybatis%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88dao%E5%B1%82%E4%B8%8D%E9%9C%80%E8%A6%81-repository/"},"publisher":{"@type":"Organization","name":"网站标题","logo":{"@type":"ImageObject","url":"https://heeexy.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://heeexy.com/ accesskey=h title="网站标题 (Alt + H)">网站标题</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">使用MyBatis时为什么Dao层不需要@Repository</h1><div class=post-meta><span title='2018-04-03 17:07:46 +0000 UTC'>April 3, 2018</span></div></header><div class=post-content><h1 id=问题>问题<a hidden class=anchor aria-hidden=true href=#问题>#</a></h1><p>Service层注入Dao时， Intellij 总会以红色波浪线提示我们</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> UserDao userDao;
</span></span></code></pre></div><p>Could not autowire. No beans of &lsquo;UserDao&rsquo; type found.
Checks autowiring problems in a bean class.</p><p>尽管我们都知道 Dao 层的 Bean 实际上都是有的，并且可以设置关闭这恼人的提示，但是我们有没有想过为什么 Intellij 就找不到这个 Bean 呢？甚至有人有这种做法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Repository</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>UserDao</span> {
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>来避免提示，但是这种做法正确么？</p><p>所以今天我们的疑问就是</p><ol><li>为什么 Dao 层不需要加 @Repository 注解，源码里到底做了什么？</li><li>加了 @Repository 注解有什么影响？</li></ol><h1 id=答案>答案<a hidden class=anchor aria-hidden=true href=#答案>#</a></h1><ol><li><p>关键在于 ClassPathMapperScanner 对指定包的扫描，并且扫描过程对 Spring 原本的扫描 Bean 的步骤 &ldquo;加了料” ，Spring 本身只扫实现类，但 MyBatis 的扫描器<strong>扫了接口</strong> 。并且扫完接口之后，为接口配了个 <strong>BeanDefinition</strong> ,并且这个 bd 的 BeanClass 是 <strong>MapperFactoryBean</strong> 。</p><blockquote><p>对于 BeanDefinition 和 MapperFactoryBean 不了解的同学请查询相关资料和源码</p></blockquote></li><li><p>仅仅只能解决 Intellij 静态查找 bean 的问题，没有实际作用。即使加了注解，比如@Controller，@Service 等等，也会被 Spring 的扫描器给忽略掉，因为<strong>扫描器会过滤掉接口</strong>。</p></li></ol><h1 id=源码探索>源码探索<a hidden class=anchor aria-hidden=true href=#源码探索>#</a></h1><blockquote><p>下面的源码部分如果读者提前有 MyBatis 的 Bean 的执行流程，和 Spring 的 Bean加载的相关知识就更好理解。</p></blockquote><h3 id=1-分析问题>1. 分析问题<a hidden class=anchor aria-hidden=true href=#1-分析问题>#</a></h3><p>关于为什么不需要注解就能获取到 Dao 层的 Bean，看似答案很简单，因为配置了扫描指定这个包里的 xxxDao.class 啊，比如使用注解 @MapperScan(&ldquo;com.example.dao&rdquo;)。</p><p>这个答案太过表面，觉得问题简单只是因为对 Spring 的 Bean 不熟悉。</p><p>我们何时见过 @Component 及其衍生的3个注解 @Controller、@Service、@Repository <strong>加在接口上面</strong>的？</p><p>自己测试新建个接口，上面加注解，然后找个 Controller 里 @Autowired 注入一下，项目立马会报错 NoSuchBeanDefinitionException 。</p><h3 id=2-切入源码>2. 切入源码<a hidden class=anchor aria-hidden=true href=#2-切入源码>#</a></h3><h4 id=切入点>切入点<a hidden class=anchor aria-hidden=true href=#切入点>#</a></h4><p>既然使用注解 @MapperScan 就好使，那么我们就从这个点切入源码看一下，先找出源码中何处用了此注解，非常幸运的是，只有一处用到了此注解 ：MapperScannerRegistrar.registerBeanDefinitions() 。</p><p>并且从类名和方法名就可以很清楚的看出这个类的功能是扫描 Mapper 并注册，方法的功能就是注册 BeanDefinitions 到 Spring 中。方法的源码我就不贴了，很容易看出来是创建一个扫描器 <code>ClassPathMapperScanner</code> ，设置好一系列属性比如 Spring 的注册表之后，执行 doScan() 方法去扫描 @MapperScan 提供的包。</p><h4 id=doscan-扫描资源转换为-beandefinition>doScan() 扫描资源，转换为 BeanDefinition<a hidden class=anchor aria-hidden=true href=#doscan-扫描资源转换为-beandefinition>#</a></h4><p>doScan() 方法也很简单，就是两步：</p><ol><li>调用父类 ClassPathBeanDefinitionScanner 的doScan()方法，也就是 Spring 扫描BeanDefinition 的方法。过程不是很重要，我们需要知道这个扫描方法的一个关键就是</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Set<span style=color:#f92672>&lt;</span>BeanDefinition<span style=color:#f92672>&gt;</span> candidates <span style=color:#f92672>=</span> findCandidateComponents(basePackage);
</span></span></code></pre></div><p>在其中对所有的候选者使用 isCandidateComponent() 方法判断是否为符合要求的 BeanDefinition。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>for</span> (TypeFilter tf : <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>excludeFilters</span>) {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> (tf.<span style=color:#a6e22e>match</span>(metadataReader, <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>metadataReaderFactory</span>)) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (TypeFilter tf : <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>includeFilters</span>) {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> (tf.<span style=color:#a6e22e>match</span>(metadataReader, <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>metadataReaderFactory</span>)) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> isConditionMatch(metadataReader);
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这有两组过滤器来过滤扫描到的资源。<strong>Spring 默认的过滤器是排除掉抽象类/接口的。而MyBatis 的扫描器重新注册了过滤器，默认对接口放行。</strong></p><blockquote><p>其实还有一些其它的过滤要求，但是不影响我们本问题的探究，所以不深入解读了。</p></blockquote><p>源码读到这里，我们先找到了本文的第二个问题的答案。也就是 Spring 会忽略掉接口上面的注解，不会添加它进入 BeanDefiniiton ,也就难怪测试的时候会抛出 NoSuchBeanDefinitionException 的异常了。而 MyBatis 则会把这些接口拉过来注册BD 。</p><h4 id=对-beandefinition-的加工>对 BeanDefinition 的加工<a hidden class=anchor aria-hidden=true href=#对-beandefinition-的加工>#</a></h4><p>读到这里我们可能有了更大的疑问，拿接口注册 BeanDefinition ，那获取 Bean 的时候如何去实例化这个对象啊？接口可是不能实例化出对象的啊，而且我们也没有做实现。</p><p>原来是 MyBatis 的扫描器在调用完父类的扫描方法后，对 BeanDefinition 进行了加工 processBeanDefinitions() 。其中最关键的两行代码是</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>definition.<span style=color:#a6e22e>getConstructorArgumentValues</span>().<span style=color:#a6e22e>addGenericArgumentValue</span>(definition.<span style=color:#a6e22e>getBeanClassName</span>()); 
</span></span><span style=display:flex><span>definition.<span style=color:#a6e22e>setBeanClass</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>mapperFactoryBean</span>.<span style=color:#a6e22e>getClass</span>());
</span></span></code></pre></div><p>第一行，我们发现把这个<strong>接口的类名塞到了构造器参数中</strong>。</p><blockquote><p>小彩蛋，这里塞的是 String ，而我们的构造器参数其实要的是 Class 。但是 Spring 的 ConstructorResolver.autowireConstructor 中用到了 Object[] argsToUse 去做了个转换 。</p></blockquote><p>第二行，beanDefinition 的 <strong>BeanClass 被设置成了 MapperFactoryBean</strong> !</p><p>熟悉 Spring 和 MyBatis 的读者肯定一下就明白了，就是这个地方进行了"偷梁换柱&rdquo;！</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> UserDao userDao;
</span></span></code></pre></div><p>还是拿 UserDao 为例，我们向 Spring 容器说 &ldquo;给我来个 UserDao 的实例&rdquo;，而 Spring 根据注册时候的 BeanDefinition ，去工厂( <strong>MapperFactoryBean</strong> )里面扔了个 UserDao.class 的参数进去，工厂的 getObject() 方法给我们返回了它制造的 userDao 。</p><p>就这样，我们没有去写实现类，轻轻松松拿到了我们需要的 userDao 。</p><p>至于 <strong>MapperFactoryBean</strong> 里做了什么返回了 userDao 出来？其实就是它的 getObject 方法返回的是 DefaultSqlSession.getMapper(Class type)方法，返回的是 MapperProxy 代理的类，而这个代理类的 invoke 方法并不像我们平时见到的代理中的 invoke 方法一样调用原始目标的 method.invoke ，而是去找 MapperMethod 执行了。</p><h1 id=收获>收获<a hidden class=anchor aria-hidden=true href=#收获>#</a></h1><p>这次的源码探究下来，收获的不仅仅是了解了 Dao 层 Bean 的注入，更是串起了我们最常用的 Spring 和 MyBatis ，换句话说，我们打通了从 Service 层到 Dao 层。</p><p>在以往 Debug 代码时看到的 MapperProxy，MapperMethod，我们清楚了这是从何而来，也对 MyBatis 中代理的巧妙运用更加熟悉。</p><h1 id=参考文献>参考文献<a hidden class=anchor aria-hidden=true href=#参考文献>#</a></h1><p><a href=https://blog.csdn.net/java280580332/article/details/72123890>https://blog.csdn.net/java280580332/article/details/72123890</a></p><p><a href=https://blog.csdn.net/mingtian625/article/details/47684271>https://blog.csdn.net/mingtian625/article/details/47684271</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://heeexy.com/tags/java/>Java</a></li><li><a href=https://heeexy.com/tags/spring/>Spring</a></li><li><a href=https://heeexy.com/tags/mybatis/>MyBatis</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://heeexy.com/>网站标题</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>