<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="# 本文要看啥 先不细谈volatile的基本原理,在读(写)这篇文章时,都是假设我们已经粗略了解了一点volatile的原理和作用的,主要就是 &ldquo;读写都走主内存,保证任意线程对这个变量的可见性&rdquo; 在查看spring源码的时候,注意到spring在处理并发的操作List时, 虽然对list使用了volatile, 然而向list里面添加元素时,用的还是新建一个list,复制全部旧值,增加新元素,然后将旧的list地址指向新的list. List<String> updatedDefinitions = new ArrayList(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); this.beanDefinitionNames = updatedDefinitions; 这么麻烦的操作,第一反应就是,volatile修饰的list, 直接添加元素依然不安全么? 去网上搜了一下相关问题, 参考博文地址 ,发现不止list, 对象也是一样的. 本文就是要来用代码直观地看看volatile 到底有什么效果,怎么用才有效果. # 开始代码吧 # 线程共享对象里的boolean 注意代码要以**-server模式**运行，强制虚拟机开启优化 public class VolatileObjectTest implements Runnable { // 加上volatile 就可以正常结束While循环了 private ObjectA a; public VolatileObjectTest(ObjectA a) { this.a = a; } public void stop() { a.setFlag(false); } @Override public void run() { long i = 0; while (a.isFlag()) { i++; /** 注意这里的sysout,如果有调用的话,即使没有volatile,子线程也经常能拿到a."><title>test_volatile_object</title>
<link rel=canonical href=https://heeexy.com/posts/test-volatile-object/><link rel=stylesheet href=/scss/style.min.760e3dabc1e140d2e6abd27a8ca0aabb60e568829b29f67d2df12024136eff37.css><meta property='og:title' content="test_volatile_object"><meta property='og:description' content="# 本文要看啥 先不细谈volatile的基本原理,在读(写)这篇文章时,都是假设我们已经粗略了解了一点volatile的原理和作用的,主要就是 &ldquo;读写都走主内存,保证任意线程对这个变量的可见性&rdquo; 在查看spring源码的时候,注意到spring在处理并发的操作List时, 虽然对list使用了volatile, 然而向list里面添加元素时,用的还是新建一个list,复制全部旧值,增加新元素,然后将旧的list地址指向新的list. List<String> updatedDefinitions = new ArrayList(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); this.beanDefinitionNames = updatedDefinitions; 这么麻烦的操作,第一反应就是,volatile修饰的list, 直接添加元素依然不安全么? 去网上搜了一下相关问题, 参考博文地址 ,发现不止list, 对象也是一样的. 本文就是要来用代码直观地看看volatile 到底有什么效果,怎么用才有效果. # 开始代码吧 # 线程共享对象里的boolean 注意代码要以**-server模式**运行，强制虚拟机开启优化 public class VolatileObjectTest implements Runnable { // 加上volatile 就可以正常结束While循环了 private ObjectA a; public VolatileObjectTest(ObjectA a) { this.a = a; } public void stop() { a.setFlag(false); } @Override public void run() { long i = 0; while (a.isFlag()) { i++; /** 注意这里的sysout,如果有调用的话,即使没有volatile,子线程也经常能拿到a."><meta property='og:url' content='https://heeexy.com/posts/test-volatile-object/'><meta property='og:site_name' content='网站标题'><meta property='og:type' content='article'><meta property='article:section' content='Posts'><meta property='article:tag' content='java'><meta property='article:tag' content='笔记'><meta property='article:published_time' content='2017-09-18T22:28:29+00:00'><meta property='article:modified_time' content='2017-09-18T22:28:29+00:00'><meta name=twitter:title content="test_volatile_object"><meta name=twitter:description content="# 本文要看啥 先不细谈volatile的基本原理,在读(写)这篇文章时,都是假设我们已经粗略了解了一点volatile的原理和作用的,主要就是 &ldquo;读写都走主内存,保证任意线程对这个变量的可见性&rdquo; 在查看spring源码的时候,注意到spring在处理并发的操作List时, 虽然对list使用了volatile, 然而向list里面添加元素时,用的还是新建一个list,复制全部旧值,增加新元素,然后将旧的list地址指向新的list. List<String> updatedDefinitions = new ArrayList(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); this.beanDefinitionNames = updatedDefinitions; 这么麻烦的操作,第一反应就是,volatile修饰的list, 直接添加元素依然不安全么? 去网上搜了一下相关问题, 参考博文地址 ,发现不止list, 对象也是一样的. 本文就是要来用代码直观地看看volatile 到底有什么效果,怎么用才有效果. # 开始代码吧 # 线程共享对象里的boolean 注意代码要以**-server模式**运行，强制虚拟机开启优化 public class VolatileObjectTest implements Runnable { // 加上volatile 就可以正常结束While循环了 private ObjectA a; public VolatileObjectTest(ObjectA a) { this.a = a; } public void stop() { a.setFlag(false); } @Override public void run() { long i = 0; while (a.isFlag()) { i++; /** 注意这里的sysout,如果有调用的话,即使没有volatile,子线程也经常能拿到a."></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column compact"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_huda2458f72ce188392d75c5d51cd8e24e_373_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>网站标题</a></h1><h2 class=site-description></h2></div></header><ol class=menu id=main-menu><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/posts/test-volatile-object/>test_volatile_object</a></h2></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Sep 18, 2017</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>2 minute read</time></div></footer></div></header><section class=article-content><h3 id=本文要看啥><a href=#%e6%9c%ac%e6%96%87%e8%a6%81%e7%9c%8b%e5%95%a5 class=header-anchor>#</a>
本文要看啥</h3><hr><p>先不细谈volatile的基本原理,在读(写)这篇文章时,都是假设我们已经粗略了解了一点volatile的原理和作用的,主要就是 &ldquo;读写都走主内存,保证任意线程对这个变量的可见性&rdquo;</p><p>在查看spring源码的时候,注意到spring在处理并发的操作List时, 虽然对list使用了volatile, 然而向list里面添加元素时,用的还是新建一个list,复制全部旧值,增加新元素,然后将旧的list地址指向新的list.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span> 	List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> updatedDefinitions <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>beanDefinitionNames</span>.<span style=color:#a6e22e>size</span>() <span style=color:#f92672>+</span> 1);
</span></span><span style=display:flex><span>    updatedDefinitions.<span style=color:#a6e22e>addAll</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>beanDefinitionNames</span>);
</span></span><span style=display:flex><span>    updatedDefinitions.<span style=color:#a6e22e>add</span>(beanName);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>beanDefinitionNames</span> <span style=color:#f92672>=</span> updatedDefinitions;
</span></span></code></pre></div><p>这么麻烦的操作,第一反应就是,volatile修饰的list, 直接添加元素<strong>依然不安全</strong>么?</p><p>去网上搜了一下相关问题, <a class=link href=http://blog.csdn.net/u014108122/article/details/38173201 target=_blank rel=noopener>参考博文地址</a> ,发现不止list, 对象也是一样的.</p><p>本文就是要来用代码直观地看看volatile 到底有什么效果,怎么用才有效果.</p><h3 id=开始代码吧><a href=#%e5%bc%80%e5%a7%8b%e4%bb%a3%e7%a0%81%e5%90%a7 class=header-anchor>#</a>
开始代码吧</h3><hr><h4 id=线程共享对象里的boolean><a href=#%e7%ba%bf%e7%a8%8b%e5%85%b1%e4%ba%ab%e5%af%b9%e8%b1%a1%e9%87%8c%e7%9a%84boolean class=header-anchor>#</a>
线程共享对象里的boolean</h4><p>注意代码要以**-server模式**运行，强制虚拟机开启优化</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>VolatileObjectTest</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 加上volatile 就可以正常结束While循环了</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> ObjectA a;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>VolatileObjectTest</span>(ObjectA a) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> a;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>stop</span>() {
</span></span><span style=display:flex><span>        a.<span style=color:#a6e22e>setFlag</span>(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> i <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (a.<span style=color:#a6e22e>isFlag</span>()) {
</span></span><span style=display:flex><span>            i<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>          <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         	 注意这里的sysout,如果有调用的话,即使没有volatile,子线程也经常能拿到a.flag,
</span></span></span><span style=display:flex><span><span style=color:#75715e>         	 结合后面的测试,发现sysout 或者 sysout(a.isFlag())之前有&#34;---&#34;之类字符串
</span></span></span><span style=display:flex><span><span style=color:#75715e>         	 都可能让a去从主内存去获取值,影响我们测试的结果
</span></span></span><span style=display:flex><span><span style=color:#75715e>         	 所以测试的时候不要乱打sysout了,感兴趣的话可以自己去各种测试一遍
</span></span></span><span style=display:flex><span><span style=color:#75715e>          */</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// System.out.println();  </span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;子线程正常结束&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 注意代码要以-server模式运行，强制虚拟机开启优化</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果启动的时候加上-server 参数则会 输出 Java HotSpot(TM) Server VM</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(System.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;java.vm.name&#34;</span>));
</span></span><span style=display:flex><span>        VolatileObjectTest2 test <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> VolatileObjectTest2(<span style=color:#66d9ef>new</span> ObjectA());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(test).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        Thread.<span style=color:#a6e22e>sleep</span>(200);
</span></span><span style=display:flex><span>        test.<span style=color:#a6e22e>stop</span>();
</span></span><span style=display:flex><span>        Thread.<span style=color:#a6e22e>sleep</span>(200);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;主线程结束&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ObjectA</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span> flag <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isFlag</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> flag;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setFlag</span>(<span style=color:#66d9ef>boolean</span> flag) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>flag</span> <span style=color:#f92672>=</span> flag;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个代码还是很简单,</p><p>主线程将a的flag改为false,</p><p>子线程能正常结束的话, 说明子线程里 a 的 flag值获取到了false,</p><p>不能正常结束的话, 说明子线程a一直都是用其本地内存里的flag值,一直都是true.</p><p>测试结果就是</p><ol><li>有volatile 修饰的情况下, 子线程能拿到false值</li><li>没有volatile ,子线程无法正常结束</li></ol><p>在初步了解volatile 的可见性的情况下, 我会觉得这个结果很正常, 觉得自己掌握了volatile , 但是我们继续往下看&mldr;</p><h4 id=线程共享对象里的对象><a href=#%e7%ba%bf%e7%a8%8b%e5%85%b1%e4%ba%ab%e5%af%b9%e8%b1%a1%e9%87%8c%e7%9a%84%e5%af%b9%e8%b1%a1 class=header-anchor>#</a>
线程共享对象里的对象</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>VolatileObjectTest</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 加上volatile 就可以正常结束While循环了</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> ObjectA a;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>VolatileObjectTest</span>(ObjectA a) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> a;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>stop</span>() {
</span></span><span style=display:flex><span>        a.<span style=color:#a6e22e>getObjectB</span>().<span style=color:#a6e22e>setFlag</span>(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> i <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>        ObjectB b <span style=color:#f92672>=</span> a.<span style=color:#a6e22e>getObjectB</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (b.<span style=color:#a6e22e>isFlag</span>()) {
</span></span><span style=display:flex><span>            i<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(b.<span style=color:#a6e22e>isFlag</span>());
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(a.<span style=color:#a6e22e>getObjectB</span>().<span style=color:#a6e22e>isFlag</span>());
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;子线程正常结束&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果启动的时候加上-server 参数则会 输出 Java HotSpot(TM) Server VM</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(System.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;java.vm.name&#34;</span>));
</span></span><span style=display:flex><span>        VolatileObjectTest test <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> VolatileObjectTest(<span style=color:#66d9ef>new</span> ObjectA());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(test).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        Thread.<span style=color:#a6e22e>sleep</span>(200);
</span></span><span style=display:flex><span>        test.<span style=color:#a6e22e>stop</span>();
</span></span><span style=display:flex><span>        Thread.<span style=color:#a6e22e>sleep</span>(200);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;主线程结束&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ObjectA</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span> flag <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ObjectB objectB <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ObjectB();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isFlag</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> flag;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setFlag</span>(<span style=color:#66d9ef>boolean</span> flag) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>flag</span> <span style=color:#f92672>=</span> flag;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> ObjectB <span style=color:#a6e22e>getObjectB</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> objectB;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ObjectB</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span> flag <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isFlag</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> flag;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setFlag</span>(<span style=color:#66d9ef>boolean</span> flag) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>flag</span> <span style=color:#f92672>=</span> flag;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>这次在ObjectA内添加了一个成员变量ObjectB,我们在子线程中跳出循环需要ObjectB中的flag变为false;</p><p>实际测试时发现:</p><ol><li>无论ObjectA前有没有 volatile, 调用stop()方法都并不能正确终止子线程</li><li>成员变量ObjectB前添加volatile,同样不能正确终止子线程</li><li>ObjectB的flag前加volatile,可以终止子线程 (这是当然的啦&mldr;)</li><li>如果循环里用的是 <code>while (a.getObjectB().isFlag())</code> , ObjectA前又有volatile的话, 这样还是可以终止子线程.</li></ol><p>测到这里,感觉这个博主给的例子是不是有问题啊,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span> ObjectB b <span style=color:#f92672>=</span> a.<span style=color:#a6e22e>getObjectB</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (b.<span style=color:#a6e22e>isFlag</span>()) {
</span></span><span style=display:flex><span>            i<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p>问题是出在这里提前从a里面取出了b么,b已经指向不同的内存地址了么?不应该吧&mldr;</p><p>稍加思考,第三种结果里,b.flag用volatile修饰后,就可以正常退出,说明b还是指向的a里面的b的地址啊,没毛病啊.</p><p>突然感觉更晕了,把原博的评论翻到底,发现还真有人评论到这个,从评论里又学到了很多东西.</p><h4 id=原博评论区的解疑><a href=#%e5%8e%9f%e5%8d%9a%e8%af%84%e8%ae%ba%e5%8c%ba%e7%9a%84%e8%a7%a3%e7%96%91 class=header-anchor>#</a>
原博评论区的解疑</h4><p>Q: 为什么sysout影响结果?</p><p>A: 如果在循环体内加一些语句,比如sysout或者new对象之类的稍微复杂而耗时的操作,就会发现就算没有volatile,线程同样可能被正常中断.因为<strong>经过高耗时操作之后,CPU会"怀疑人生"</strong>,单心自己对b.flag的缓存不是最新的,而去从主存获取.在这种情况下，线程会结束，只不过不及时而已。</p><p>Q: 为什么 while (b.isFlag()) 和while(a.getObjectB.isFlag()) 结果有区别,后者就可以拿到最新的flag值?</p><p>A: 一个volatile引用的域或者元素并不具备volatile特性，因为对于该域的写入并不会触发StoreLoad屏障，就<strong>不会强迫该域值立刻回写主存</strong>。不过其读特性并没有问题，<strong>对volatile的读操作一定是去主存当中读取的</strong>。</p><p>所以a.getObjectB 在这里a就已经去从主存中读取了.</p><p>这一点因此也就解释了第一个例子中,我们修改a.flag,可以正常地读到flag值.</p><p>Q: 但是问题又来了,写入不能保证刷新到主存的话,岂不是即使<code>while(a.getObjectB.isFlag())</code> 也是仍然很有可能失败的?经过刚才例子的反复测试,依然很难碰到终止线程失败的情况.</p><p>A: 这个例子还是无法测出这种刷新主存不及时的情况,毕竟即使是不及时刷新,最终刷新了还是可以让子线程结束的.</p><p><a class=link href=http://ifeve.com/volatile-array-visiblity/ target=_blank rel=noopener>另外一篇博客</a> 从汇编语句的角度分析了<strong>volatile的数组只针对数组的引用具有volatile的语义，而不是它的元素</strong> , 暂时只能记录下来,待以后再深入原理去理解.</p><h4 id=留下更多的疑惑><a href=#%e7%95%99%e4%b8%8b%e6%9b%b4%e5%a4%9a%e7%9a%84%e7%96%91%e6%83%91 class=header-anchor>#</a>
留下更多的疑惑</h4><ol><li><p>如上面所说,一个volatile引用的域或者元素并不具备volatile特性，因为对于该域的写入并不会触发StoreLoad屏障，就<strong>不会强迫该域值立刻回写主存</strong>。 如何证明?</p></li><li><p>spring里用置换的方式真的不会出问题么? 多个线程同时读取了一个list,然后各自加一个元素进去,刷新,这样不就出了问题?</p></li><li><p>如果说这样并不安全,那么concurrent包里是怎么实现安全的list的呢?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>add</span>(E e) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> ReentrantLock lock <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>lock</span>;
</span></span><span style=display:flex><span>        lock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            Object<span style=color:#f92672>[]</span> elements <span style=color:#f92672>=</span> getArray();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> len <span style=color:#f92672>=</span> elements.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>            Object<span style=color:#f92672>[]</span> newElements <span style=color:#f92672>=</span> Arrays.<span style=color:#a6e22e>copyOf</span>(elements, len <span style=color:#f92672>+</span> 1);
</span></span><span style=display:flex><span>            newElements<span style=color:#f92672>[</span>len<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>            setArray(newElements);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>            lock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>ReentrantLock 貌似是安全了, 但是为什么这里也用了置换数组啊???</p><p>​</p></li></ol></section><footer class=article-footer><section class=article-tags><a href=/tags/java/>Java</a>
<a href=/tags/%E7%AC%94%E8%AE%B0/>笔记</a></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/posts/spring-note-5-simplealiasregistry/><div class=article-details><h2 class=article-title>SimpleAliasRegistry</h2></div></a></article><article><a href=/posts/spring-note-6-registerbeandefinition/><div class=article-details><h2 class=article-title>Spring源码笔记-1.4 获取bean流程之注册BeanDefinition</h2></div></a></article><article><a href=/posts/spring-note-4-decoratebeandefinitionifrequired/><div class=article-details><h2 class=article-title>Spring源码笔记-1.3 获取bean流程之解析bean标签中的自定义标签元素</h2></div></a></article><article><a href=/posts/spring-note-3-constructorargumentvalues/><div class=article-details><h2 class=article-title>ConstructorArgumentValues 构造器参数值保存器</h2></div></a></article><article><a href=/posts/spring-note-2/><div class=article-details><h2 class=article-title>Spring源码笔记-1.2 获取bean流程之bean标签的解析及注册</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2024 网站标题</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.25.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>