<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>test_volatile_object | 网站标题</title>
<meta name=keywords content="java,笔记"><meta name=description content="本文要看啥 先不细谈volatile的基本原理,在读(写)这篇文章时,都是假设我们已经粗略了解了一点volatile的原理和作用的,主要就是 &ldquo;读写都走主内存,保证任意线程对这个变量的可见性&rdquo;
在查看spring源码的时候,注意到spring在处理并发的操作List时, 虽然对list使用了volatile, 然而向list里面添加元素时,用的还是新建一个list,复制全部旧值,增加新元素,然后将旧的list地址指向新的list.
List<String> updatedDefinitions = new ArrayList(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); this.beanDefinitionNames = updatedDefinitions; 这么麻烦的操作,第一反应就是,volatile修饰的list, 直接添加元素依然不安全么?
去网上搜了一下相关问题, 参考博文地址 ,发现不止list, 对象也是一样的.
本文就是要来用代码直观地看看volatile 到底有什么效果,怎么用才有效果.
开始代码吧 线程共享对象里的boolean 注意代码要以**-server模式**运行，强制虚拟机开启优化
public class VolatileObjectTest implements Runnable { // 加上volatile 就可以正常结束While循环了 private ObjectA a; public VolatileObjectTest(ObjectA a) { this.a = a; } public void stop() { a.setFlag(false); } @Override public void run() { long i = 0; while (a.isFlag()) { i++; /** 注意这里的sysout,如果有调用的话,即使没有volatile,子线程也经常能拿到a.flag, 结合后面的测试,发现sysout 或者 sysout(a."><meta name=author content><link rel=canonical href=https://heeexy.com/posts/test-volatile-object/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://heeexy.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://heeexy.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://heeexy.com/favicon-32x32.png><link rel=apple-touch-icon href=https://heeexy.com/apple-touch-icon.png><link rel=mask-icon href=https://heeexy.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://heeexy.com/posts/test-volatile-object/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="test_volatile_object"><meta property="og:description" content="本文要看啥 先不细谈volatile的基本原理,在读(写)这篇文章时,都是假设我们已经粗略了解了一点volatile的原理和作用的,主要就是 &ldquo;读写都走主内存,保证任意线程对这个变量的可见性&rdquo;
在查看spring源码的时候,注意到spring在处理并发的操作List时, 虽然对list使用了volatile, 然而向list里面添加元素时,用的还是新建一个list,复制全部旧值,增加新元素,然后将旧的list地址指向新的list.
List<String> updatedDefinitions = new ArrayList(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); this.beanDefinitionNames = updatedDefinitions; 这么麻烦的操作,第一反应就是,volatile修饰的list, 直接添加元素依然不安全么?
去网上搜了一下相关问题, 参考博文地址 ,发现不止list, 对象也是一样的.
本文就是要来用代码直观地看看volatile 到底有什么效果,怎么用才有效果.
开始代码吧 线程共享对象里的boolean 注意代码要以**-server模式**运行，强制虚拟机开启优化
public class VolatileObjectTest implements Runnable { // 加上volatile 就可以正常结束While循环了 private ObjectA a; public VolatileObjectTest(ObjectA a) { this.a = a; } public void stop() { a.setFlag(false); } @Override public void run() { long i = 0; while (a.isFlag()) { i++; /** 注意这里的sysout,如果有调用的话,即使没有volatile,子线程也经常能拿到a.flag, 结合后面的测试,发现sysout 或者 sysout(a."><meta property="og:type" content="article"><meta property="og:url" content="https://heeexy.com/posts/test-volatile-object/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-09-18T22:28:29+00:00"><meta property="article:modified_time" content="2017-09-18T22:28:29+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="test_volatile_object"><meta name=twitter:description content="本文要看啥 先不细谈volatile的基本原理,在读(写)这篇文章时,都是假设我们已经粗略了解了一点volatile的原理和作用的,主要就是 &ldquo;读写都走主内存,保证任意线程对这个变量的可见性&rdquo;
在查看spring源码的时候,注意到spring在处理并发的操作List时, 虽然对list使用了volatile, 然而向list里面添加元素时,用的还是新建一个list,复制全部旧值,增加新元素,然后将旧的list地址指向新的list.
List<String> updatedDefinitions = new ArrayList(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); this.beanDefinitionNames = updatedDefinitions; 这么麻烦的操作,第一反应就是,volatile修饰的list, 直接添加元素依然不安全么?
去网上搜了一下相关问题, 参考博文地址 ,发现不止list, 对象也是一样的.
本文就是要来用代码直观地看看volatile 到底有什么效果,怎么用才有效果.
开始代码吧 线程共享对象里的boolean 注意代码要以**-server模式**运行，强制虚拟机开启优化
public class VolatileObjectTest implements Runnable { // 加上volatile 就可以正常结束While循环了 private ObjectA a; public VolatileObjectTest(ObjectA a) { this.a = a; } public void stop() { a.setFlag(false); } @Override public void run() { long i = 0; while (a.isFlag()) { i++; /** 注意这里的sysout,如果有调用的话,即使没有volatile,子线程也经常能拿到a.flag, 结合后面的测试,发现sysout 或者 sysout(a."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://heeexy.com/posts/"},{"@type":"ListItem","position":2,"name":"test_volatile_object","item":"https://heeexy.com/posts/test-volatile-object/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"test_volatile_object","name":"test_volatile_object","description":"本文要看啥 先不细谈volatile的基本原理,在读(写)这篇文章时,都是假设我们已经粗略了解了一点volatile的原理和作用的,主要就是 \u0026ldquo;读写都走主内存,保证任意线程对这个变量的可见性\u0026rdquo;\n在查看spring源码的时候,注意到spring在处理并发的操作List时, 虽然对list使用了volatile, 然而向list里面添加元素时,用的还是新建一个list,复制全部旧值,增加新元素,然后将旧的list地址指向新的list.\nList\u0026lt;String\u0026gt; updatedDefinitions = new ArrayList(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); this.beanDefinitionNames = updatedDefinitions; 这么麻烦的操作,第一反应就是,volatile修饰的list, 直接添加元素依然不安全么?\n去网上搜了一下相关问题, 参考博文地址 ,发现不止list, 对象也是一样的.\n本文就是要来用代码直观地看看volatile 到底有什么效果,怎么用才有效果.\n开始代码吧 线程共享对象里的boolean 注意代码要以**-server模式**运行，强制虚拟机开启优化\npublic class VolatileObjectTest implements Runnable { // 加上volatile 就可以正常结束While循环了 private ObjectA a; public VolatileObjectTest(ObjectA a) { this.a = a; } public void stop() { a.setFlag(false); } @Override public void run() { long i = 0; while (a.isFlag()) { i++; /** 注意这里的sysout,如果有调用的话,即使没有volatile,子线程也经常能拿到a.flag, 结合后面的测试,发现sysout 或者 sysout(a.","keywords":["java","笔记"],"articleBody":"本文要看啥 先不细谈volatile的基本原理,在读(写)这篇文章时,都是假设我们已经粗略了解了一点volatile的原理和作用的,主要就是 “读写都走主内存,保证任意线程对这个变量的可见性”\n在查看spring源码的时候,注意到spring在处理并发的操作List时, 虽然对list使用了volatile, 然而向list里面添加元素时,用的还是新建一个list,复制全部旧值,增加新元素,然后将旧的list地址指向新的list.\nList\u003cString\u003e updatedDefinitions = new ArrayList(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); this.beanDefinitionNames = updatedDefinitions; 这么麻烦的操作,第一反应就是,volatile修饰的list, 直接添加元素依然不安全么?\n去网上搜了一下相关问题, 参考博文地址 ,发现不止list, 对象也是一样的.\n本文就是要来用代码直观地看看volatile 到底有什么效果,怎么用才有效果.\n开始代码吧 线程共享对象里的boolean 注意代码要以**-server模式**运行，强制虚拟机开启优化\npublic class VolatileObjectTest implements Runnable { // 加上volatile 就可以正常结束While循环了 private ObjectA a; public VolatileObjectTest(ObjectA a) { this.a = a; } public void stop() { a.setFlag(false); } @Override public void run() { long i = 0; while (a.isFlag()) { i++; /** 注意这里的sysout,如果有调用的话,即使没有volatile,子线程也经常能拿到a.flag, 结合后面的测试,发现sysout 或者 sysout(a.isFlag())之前有\"---\"之类字符串 都可能让a去从主内存去获取值,影响我们测试的结果 所以测试的时候不要乱打sysout了,感兴趣的话可以自己去各种测试一遍 */ // System.out.println(); } System.out.println(\"子线程正常结束\"); } public static void main(String[] args) throws InterruptedException { // 注意代码要以-server模式运行，强制虚拟机开启优化 // 如果启动的时候加上-server 参数则会 输出 Java HotSpot(TM) Server VM System.out.println(System.getProperty(\"java.vm.name\")); VolatileObjectTest2 test = new VolatileObjectTest2(new ObjectA()); new Thread(test).start(); Thread.sleep(200); test.stop(); Thread.sleep(200); System.out.println(\"主线程结束\"); } static class ObjectA { private boolean flag = true; public boolean isFlag() { return flag; } public void setFlag(boolean flag) { this.flag = flag; } } } 这个代码还是很简单,\n主线程将a的flag改为false,\n子线程能正常结束的话, 说明子线程里 a 的 flag值获取到了false,\n不能正常结束的话, 说明子线程a一直都是用其本地内存里的flag值,一直都是true.\n测试结果就是\n有volatile 修饰的情况下, 子线程能拿到false值 没有volatile ,子线程无法正常结束 在初步了解volatile 的可见性的情况下, 我会觉得这个结果很正常, 觉得自己掌握了volatile , 但是我们继续往下看…\n线程共享对象里的对象 public class VolatileObjectTest implements Runnable { // 加上volatile 就可以正常结束While循环了 private volatile ObjectA a; public VolatileObjectTest(ObjectA a) { this.a = a; } public void stop() { a.getObjectB().setFlag(false); } @Override public void run() { long i = 0; ObjectB b = a.getObjectB(); while (b.isFlag()) { i++; } System.out.println(b.isFlag()); System.out.println(a.getObjectB().isFlag()); System.out.println(\"子线程正常结束\"); } public static void main(String[] args) throws InterruptedException { // 如果启动的时候加上-server 参数则会 输出 Java HotSpot(TM) Server VM System.out.println(System.getProperty(\"java.vm.name\")); VolatileObjectTest test = new VolatileObjectTest(new ObjectA()); new Thread(test).start(); Thread.sleep(200); test.stop(); Thread.sleep(200); System.out.println(\"主线程结束\"); } static class ObjectA { private boolean flag = true; private ObjectB objectB = new ObjectB(); public boolean isFlag() { return flag; } public void setFlag(boolean flag) { this.flag = flag; } public ObjectB getObjectB() { return objectB; } } static class ObjectB { private boolean flag = true; public boolean isFlag() { return flag; } public void setFlag(boolean flag) { this.flag = flag; } } } 这次在ObjectA内添加了一个成员变量ObjectB,我们在子线程中跳出循环需要ObjectB中的flag变为false;\n实际测试时发现:\n无论ObjectA前有没有 volatile, 调用stop()方法都并不能正确终止子线程 成员变量ObjectB前添加volatile,同样不能正确终止子线程 ObjectB的flag前加volatile,可以终止子线程 (这是当然的啦…) 如果循环里用的是 while (a.getObjectB().isFlag()) , ObjectA前又有volatile的话, 这样还是可以终止子线程. 测到这里,感觉这个博主给的例子是不是有问题啊,\nObjectB b = a.getObjectB(); while (b.isFlag()) { i++; } 问题是出在这里提前从a里面取出了b么,b已经指向不同的内存地址了么?不应该吧…\n稍加思考,第三种结果里,b.flag用volatile修饰后,就可以正常退出,说明b还是指向的a里面的b的地址啊,没毛病啊.\n突然感觉更晕了,把原博的评论翻到底,发现还真有人评论到这个,从评论里又学到了很多东西.\n原博评论区的解疑 Q: 为什么sysout影响结果?\nA: 如果在循环体内加一些语句,比如sysout或者new对象之类的稍微复杂而耗时的操作,就会发现就算没有volatile,线程同样可能被正常中断.因为经过高耗时操作之后,CPU会\"怀疑人生\",单心自己对b.flag的缓存不是最新的,而去从主存获取.在这种情况下，线程会结束，只不过不及时而已。\nQ: 为什么 while (b.isFlag()) 和while(a.getObjectB.isFlag()) 结果有区别,后者就可以拿到最新的flag值?\nA: 一个volatile引用的域或者元素并不具备volatile特性，因为对于该域的写入并不会触发StoreLoad屏障，就不会强迫该域值立刻回写主存。不过其读特性并没有问题，对volatile的读操作一定是去主存当中读取的。\n所以a.getObjectB 在这里a就已经去从主存中读取了.\n这一点因此也就解释了第一个例子中,我们修改a.flag,可以正常地读到flag值.\nQ: 但是问题又来了,写入不能保证刷新到主存的话,岂不是即使while(a.getObjectB.isFlag()) 也是仍然很有可能失败的?经过刚才例子的反复测试,依然很难碰到终止线程失败的情况.\nA: 这个例子还是无法测出这种刷新主存不及时的情况,毕竟即使是不及时刷新,最终刷新了还是可以让子线程结束的.\n另外一篇博客 从汇编语句的角度分析了volatile的数组只针对数组的引用具有volatile的语义，而不是它的元素 , 暂时只能记录下来,待以后再深入原理去理解.\n留下更多的疑惑 如上面所说,一个volatile引用的域或者元素并不具备volatile特性，因为对于该域的写入并不会触发StoreLoad屏障，就不会强迫该域值立刻回写主存。 如何证明?\nspring里用置换的方式真的不会出问题么? 多个线程同时读取了一个list,然后各自加一个元素进去,刷新,这样不就出了问题?\n如果说这样并不安全,那么concurrent包里是怎么实现安全的list的呢?\npublic boolean add(E e) { final ReentrantLock lock = this.lock; lock.lock(); try { Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; } finally { lock.unlock(); } } ReentrantLock 貌似是安全了, 但是为什么这里也用了置换数组啊???\n​\n","wordCount":"409","inLanguage":"en","datePublished":"2017-09-18T22:28:29Z","dateModified":"2017-09-18T22:28:29Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://heeexy.com/posts/test-volatile-object/"},"publisher":{"@type":"Organization","name":"网站标题","logo":{"@type":"ImageObject","url":"https://heeexy.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://heeexy.com/ accesskey=h title="网站标题 (Alt + H)">网站标题</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">test_volatile_object</h1><div class=post-meta><span title='2017-09-18 22:28:29 +0000 UTC'>September 18, 2017</span></div></header><div class=post-content><h3 id=本文要看啥>本文要看啥<a hidden class=anchor aria-hidden=true href=#本文要看啥>#</a></h3><hr><p>先不细谈volatile的基本原理,在读(写)这篇文章时,都是假设我们已经粗略了解了一点volatile的原理和作用的,主要就是 &ldquo;读写都走主内存,保证任意线程对这个变量的可见性&rdquo;</p><p>在查看spring源码的时候,注意到spring在处理并发的操作List时, 虽然对list使用了volatile, 然而向list里面添加元素时,用的还是新建一个list,复制全部旧值,增加新元素,然后将旧的list地址指向新的list.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span> 	List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> updatedDefinitions <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>beanDefinitionNames</span>.<span style=color:#a6e22e>size</span>() <span style=color:#f92672>+</span> 1);
</span></span><span style=display:flex><span>    updatedDefinitions.<span style=color:#a6e22e>addAll</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>beanDefinitionNames</span>);
</span></span><span style=display:flex><span>    updatedDefinitions.<span style=color:#a6e22e>add</span>(beanName);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>beanDefinitionNames</span> <span style=color:#f92672>=</span> updatedDefinitions;
</span></span></code></pre></div><p>这么麻烦的操作,第一反应就是,volatile修饰的list, 直接添加元素<strong>依然不安全</strong>么?</p><p>去网上搜了一下相关问题, <a href=http://blog.csdn.net/u014108122/article/details/38173201>参考博文地址</a> ,发现不止list, 对象也是一样的.</p><p>本文就是要来用代码直观地看看volatile 到底有什么效果,怎么用才有效果.</p><h3 id=开始代码吧>开始代码吧<a hidden class=anchor aria-hidden=true href=#开始代码吧>#</a></h3><hr><h4 id=线程共享对象里的boolean>线程共享对象里的boolean<a hidden class=anchor aria-hidden=true href=#线程共享对象里的boolean>#</a></h4><p>注意代码要以**-server模式**运行，强制虚拟机开启优化</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>VolatileObjectTest</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 加上volatile 就可以正常结束While循环了</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> ObjectA a;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>VolatileObjectTest</span>(ObjectA a) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> a;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>stop</span>() {
</span></span><span style=display:flex><span>        a.<span style=color:#a6e22e>setFlag</span>(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> i <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (a.<span style=color:#a6e22e>isFlag</span>()) {
</span></span><span style=display:flex><span>            i<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>          <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         	 注意这里的sysout,如果有调用的话,即使没有volatile,子线程也经常能拿到a.flag,
</span></span></span><span style=display:flex><span><span style=color:#75715e>         	 结合后面的测试,发现sysout 或者 sysout(a.isFlag())之前有&#34;---&#34;之类字符串
</span></span></span><span style=display:flex><span><span style=color:#75715e>         	 都可能让a去从主内存去获取值,影响我们测试的结果
</span></span></span><span style=display:flex><span><span style=color:#75715e>         	 所以测试的时候不要乱打sysout了,感兴趣的话可以自己去各种测试一遍
</span></span></span><span style=display:flex><span><span style=color:#75715e>          */</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// System.out.println();  </span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;子线程正常结束&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 注意代码要以-server模式运行，强制虚拟机开启优化</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果启动的时候加上-server 参数则会 输出 Java HotSpot(TM) Server VM</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(System.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;java.vm.name&#34;</span>));
</span></span><span style=display:flex><span>        VolatileObjectTest2 test <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> VolatileObjectTest2(<span style=color:#66d9ef>new</span> ObjectA());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(test).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        Thread.<span style=color:#a6e22e>sleep</span>(200);
</span></span><span style=display:flex><span>        test.<span style=color:#a6e22e>stop</span>();
</span></span><span style=display:flex><span>        Thread.<span style=color:#a6e22e>sleep</span>(200);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;主线程结束&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ObjectA</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span> flag <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isFlag</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> flag;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setFlag</span>(<span style=color:#66d9ef>boolean</span> flag) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>flag</span> <span style=color:#f92672>=</span> flag;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个代码还是很简单,</p><p>主线程将a的flag改为false,</p><p>子线程能正常结束的话, 说明子线程里 a 的 flag值获取到了false,</p><p>不能正常结束的话, 说明子线程a一直都是用其本地内存里的flag值,一直都是true.</p><p>测试结果就是</p><ol><li>有volatile 修饰的情况下, 子线程能拿到false值</li><li>没有volatile ,子线程无法正常结束</li></ol><p>在初步了解volatile 的可见性的情况下, 我会觉得这个结果很正常, 觉得自己掌握了volatile , 但是我们继续往下看&mldr;</p><h4 id=线程共享对象里的对象>线程共享对象里的对象<a hidden class=anchor aria-hidden=true href=#线程共享对象里的对象>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>VolatileObjectTest</span> <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 加上volatile 就可以正常结束While循环了</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> ObjectA a;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>VolatileObjectTest</span>(ObjectA a) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>a</span> <span style=color:#f92672>=</span> a;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>stop</span>() {
</span></span><span style=display:flex><span>        a.<span style=color:#a6e22e>getObjectB</span>().<span style=color:#a6e22e>setFlag</span>(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> i <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>        ObjectB b <span style=color:#f92672>=</span> a.<span style=color:#a6e22e>getObjectB</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (b.<span style=color:#a6e22e>isFlag</span>()) {
</span></span><span style=display:flex><span>            i<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(b.<span style=color:#a6e22e>isFlag</span>());
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(a.<span style=color:#a6e22e>getObjectB</span>().<span style=color:#a6e22e>isFlag</span>());
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;子线程正常结束&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果启动的时候加上-server 参数则会 输出 Java HotSpot(TM) Server VM</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(System.<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;java.vm.name&#34;</span>));
</span></span><span style=display:flex><span>        VolatileObjectTest test <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> VolatileObjectTest(<span style=color:#66d9ef>new</span> ObjectA());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> Thread(test).<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        Thread.<span style=color:#a6e22e>sleep</span>(200);
</span></span><span style=display:flex><span>        test.<span style=color:#a6e22e>stop</span>();
</span></span><span style=display:flex><span>        Thread.<span style=color:#a6e22e>sleep</span>(200);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;主线程结束&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ObjectA</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span> flag <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> ObjectB objectB <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ObjectB();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isFlag</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> flag;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setFlag</span>(<span style=color:#66d9ef>boolean</span> flag) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>flag</span> <span style=color:#f92672>=</span> flag;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> ObjectB <span style=color:#a6e22e>getObjectB</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> objectB;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ObjectB</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span> flag <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isFlag</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> flag;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setFlag</span>(<span style=color:#66d9ef>boolean</span> flag) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>flag</span> <span style=color:#f92672>=</span> flag;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>这次在ObjectA内添加了一个成员变量ObjectB,我们在子线程中跳出循环需要ObjectB中的flag变为false;</p><p>实际测试时发现:</p><ol><li>无论ObjectA前有没有 volatile, 调用stop()方法都并不能正确终止子线程</li><li>成员变量ObjectB前添加volatile,同样不能正确终止子线程</li><li>ObjectB的flag前加volatile,可以终止子线程 (这是当然的啦&mldr;)</li><li>如果循环里用的是 <code>while (a.getObjectB().isFlag())</code> , ObjectA前又有volatile的话, 这样还是可以终止子线程.</li></ol><p>测到这里,感觉这个博主给的例子是不是有问题啊,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span> ObjectB b <span style=color:#f92672>=</span> a.<span style=color:#a6e22e>getObjectB</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (b.<span style=color:#a6e22e>isFlag</span>()) {
</span></span><span style=display:flex><span>            i<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p>问题是出在这里提前从a里面取出了b么,b已经指向不同的内存地址了么?不应该吧&mldr;</p><p>稍加思考,第三种结果里,b.flag用volatile修饰后,就可以正常退出,说明b还是指向的a里面的b的地址啊,没毛病啊.</p><p>突然感觉更晕了,把原博的评论翻到底,发现还真有人评论到这个,从评论里又学到了很多东西.</p><h4 id=原博评论区的解疑>原博评论区的解疑<a hidden class=anchor aria-hidden=true href=#原博评论区的解疑>#</a></h4><p>Q: 为什么sysout影响结果?</p><p>A: 如果在循环体内加一些语句,比如sysout或者new对象之类的稍微复杂而耗时的操作,就会发现就算没有volatile,线程同样可能被正常中断.因为<strong>经过高耗时操作之后,CPU会"怀疑人生"</strong>,单心自己对b.flag的缓存不是最新的,而去从主存获取.在这种情况下，线程会结束，只不过不及时而已。</p><p>Q: 为什么 while (b.isFlag()) 和while(a.getObjectB.isFlag()) 结果有区别,后者就可以拿到最新的flag值?</p><p>A: 一个volatile引用的域或者元素并不具备volatile特性，因为对于该域的写入并不会触发StoreLoad屏障，就<strong>不会强迫该域值立刻回写主存</strong>。不过其读特性并没有问题，<strong>对volatile的读操作一定是去主存当中读取的</strong>。</p><p>所以a.getObjectB 在这里a就已经去从主存中读取了.</p><p>这一点因此也就解释了第一个例子中,我们修改a.flag,可以正常地读到flag值.</p><p>Q: 但是问题又来了,写入不能保证刷新到主存的话,岂不是即使<code>while(a.getObjectB.isFlag())</code> 也是仍然很有可能失败的?经过刚才例子的反复测试,依然很难碰到终止线程失败的情况.</p><p>A: 这个例子还是无法测出这种刷新主存不及时的情况,毕竟即使是不及时刷新,最终刷新了还是可以让子线程结束的.</p><p><a href=http://ifeve.com/volatile-array-visiblity/>另外一篇博客</a> 从汇编语句的角度分析了<strong>volatile的数组只针对数组的引用具有volatile的语义，而不是它的元素</strong> , 暂时只能记录下来,待以后再深入原理去理解.</p><h4 id=留下更多的疑惑>留下更多的疑惑<a hidden class=anchor aria-hidden=true href=#留下更多的疑惑>#</a></h4><ol><li><p>如上面所说,一个volatile引用的域或者元素并不具备volatile特性，因为对于该域的写入并不会触发StoreLoad屏障，就<strong>不会强迫该域值立刻回写主存</strong>。 如何证明?</p></li><li><p>spring里用置换的方式真的不会出问题么? 多个线程同时读取了一个list,然后各自加一个元素进去,刷新,这样不就出了问题?</p></li><li><p>如果说这样并不安全,那么concurrent包里是怎么实现安全的list的呢?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>add</span>(E e) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> ReentrantLock lock <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>lock</span>;
</span></span><span style=display:flex><span>        lock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            Object<span style=color:#f92672>[]</span> elements <span style=color:#f92672>=</span> getArray();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> len <span style=color:#f92672>=</span> elements.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>            Object<span style=color:#f92672>[]</span> newElements <span style=color:#f92672>=</span> Arrays.<span style=color:#a6e22e>copyOf</span>(elements, len <span style=color:#f92672>+</span> 1);
</span></span><span style=display:flex><span>            newElements<span style=color:#f92672>[</span>len<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> e;
</span></span><span style=display:flex><span>            setArray(newElements);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>            lock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>ReentrantLock 貌似是安全了, 但是为什么这里也用了置换数组啊???</p><p>​</p></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://heeexy.com/tags/java/>Java</a></li><li><a href=https://heeexy.com/tags/%E7%AC%94%E8%AE%B0/>笔记</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://heeexy.com/>网站标题</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>