<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Spring源码笔记-1.4 获取bean流程之注册BeanDefinition | 网站标题</title>
<meta name=keywords content="java,spring,笔记"><meta name=description content="本文要看啥 这个bean总算是解析完了,也装饰完了,等于是说信息我们都提取好了,现在该做的就是去注册啦.
BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, this.getReaderContext().getRegistry()); 就是这个方法了
开始进入方法吧 public static void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException { String beanName = definitionHolder.getBeanName(); registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition()); String[] aliases = definitionHolder.getAliases(); if (aliases != null) { String[] var4 = aliases; int var5 = aliases.length; for(int var6 = 0; var6 < var5; ++var6) { String alias = var4[var6]; registry.registerAlias(beanName, alias); } } } 拿到beanName
用beanName和bd去registry里注册.
registry是个接口,具体的实现在4.3.7版本中看到两种,一种是SimpleBeanDefinitionRegistry里,和它名字一样非常简单,就是塞进map, 另外一种就复杂了,稍后我们再来看
用beanName和alias去registry里注册
注册aliases也是接口 ,BeanDefinitionRegistry还是继承自AliasRegistry的, 4.3.7只看到SimpleAliasRegistry一种实现
注册alias就简单多了, SimpleAliasRegistry里有
private final Map<String, String> aliasMap = new ConcurrentHashMap(16); 稍后我再另开一文把SimpleAliasRegistry来读一遍"><meta name=author content><link rel=canonical href=https://heeexy.com/posts/spring-note-6-registerbeandefinition/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://heeexy.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://heeexy.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://heeexy.com/favicon-32x32.png><link rel=apple-touch-icon href=https://heeexy.com/apple-touch-icon.png><link rel=mask-icon href=https://heeexy.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://heeexy.com/posts/spring-note-6-registerbeandefinition/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Spring源码笔记-1.4 获取bean流程之注册BeanDefinition"><meta property="og:description" content="本文要看啥 这个bean总算是解析完了,也装饰完了,等于是说信息我们都提取好了,现在该做的就是去注册啦.
BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, this.getReaderContext().getRegistry()); 就是这个方法了
开始进入方法吧 public static void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException { String beanName = definitionHolder.getBeanName(); registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition()); String[] aliases = definitionHolder.getAliases(); if (aliases != null) { String[] var4 = aliases; int var5 = aliases.length; for(int var6 = 0; var6 < var5; ++var6) { String alias = var4[var6]; registry.registerAlias(beanName, alias); } } } 拿到beanName
用beanName和bd去registry里注册.
registry是个接口,具体的实现在4.3.7版本中看到两种,一种是SimpleBeanDefinitionRegistry里,和它名字一样非常简单,就是塞进map, 另外一种就复杂了,稍后我们再来看
用beanName和alias去registry里注册
注册aliases也是接口 ,BeanDefinitionRegistry还是继承自AliasRegistry的, 4.3.7只看到SimpleAliasRegistry一种实现
注册alias就简单多了, SimpleAliasRegistry里有
private final Map<String, String> aliasMap = new ConcurrentHashMap(16); 稍后我再另开一文把SimpleAliasRegistry来读一遍"><meta property="og:type" content="article"><meta property="og:url" content="https://heeexy.com/posts/spring-note-6-registerbeandefinition/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-09-15T21:26:00+00:00"><meta property="article:modified_time" content="2017-09-15T21:26:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Spring源码笔记-1.4 获取bean流程之注册BeanDefinition"><meta name=twitter:description content="本文要看啥 这个bean总算是解析完了,也装饰完了,等于是说信息我们都提取好了,现在该做的就是去注册啦.
BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, this.getReaderContext().getRegistry()); 就是这个方法了
开始进入方法吧 public static void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException { String beanName = definitionHolder.getBeanName(); registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition()); String[] aliases = definitionHolder.getAliases(); if (aliases != null) { String[] var4 = aliases; int var5 = aliases.length; for(int var6 = 0; var6 < var5; ++var6) { String alias = var4[var6]; registry.registerAlias(beanName, alias); } } } 拿到beanName
用beanName和bd去registry里注册.
registry是个接口,具体的实现在4.3.7版本中看到两种,一种是SimpleBeanDefinitionRegistry里,和它名字一样非常简单,就是塞进map, 另外一种就复杂了,稍后我们再来看
用beanName和alias去registry里注册
注册aliases也是接口 ,BeanDefinitionRegistry还是继承自AliasRegistry的, 4.3.7只看到SimpleAliasRegistry一种实现
注册alias就简单多了, SimpleAliasRegistry里有
private final Map<String, String> aliasMap = new ConcurrentHashMap(16); 稍后我再另开一文把SimpleAliasRegistry来读一遍"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://heeexy.com/posts/"},{"@type":"ListItem","position":2,"name":"Spring源码笔记-1.4 获取bean流程之注册BeanDefinition","item":"https://heeexy.com/posts/spring-note-6-registerbeandefinition/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Spring源码笔记-1.4 获取bean流程之注册BeanDefinition","name":"Spring源码笔记-1.4 获取bean流程之注册BeanDefinition","description":"本文要看啥 这个bean总算是解析完了,也装饰完了,等于是说信息我们都提取好了,现在该做的就是去注册啦.\nBeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, this.getReaderContext().getRegistry()); 就是这个方法了\n开始进入方法吧 public static void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException { String beanName = definitionHolder.getBeanName(); registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition()); String[] aliases = definitionHolder.getAliases(); if (aliases != null) { String[] var4 = aliases; int var5 = aliases.length; for(int var6 = 0; var6 \u0026lt; var5; ++var6) { String alias = var4[var6]; registry.registerAlias(beanName, alias); } } } 拿到beanName\n用beanName和bd去registry里注册.\nregistry是个接口,具体的实现在4.3.7版本中看到两种,一种是SimpleBeanDefinitionRegistry里,和它名字一样非常简单,就是塞进map, 另外一种就复杂了,稍后我们再来看\n用beanName和alias去registry里注册\n注册aliases也是接口 ,BeanDefinitionRegistry还是继承自AliasRegistry的, 4.3.7只看到SimpleAliasRegistry一种实现\n注册alias就简单多了, SimpleAliasRegistry里有\nprivate final Map\u0026lt;String, String\u0026gt; aliasMap = new ConcurrentHashMap(16); 稍后我再另开一文把SimpleAliasRegistry来读一遍","keywords":["java","spring","笔记"],"articleBody":"本文要看啥 这个bean总算是解析完了,也装饰完了,等于是说信息我们都提取好了,现在该做的就是去注册啦.\nBeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, this.getReaderContext().getRegistry()); 就是这个方法了\n开始进入方法吧 public static void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException { String beanName = definitionHolder.getBeanName(); registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition()); String[] aliases = definitionHolder.getAliases(); if (aliases != null) { String[] var4 = aliases; int var5 = aliases.length; for(int var6 = 0; var6 \u003c var5; ++var6) { String alias = var4[var6]; registry.registerAlias(beanName, alias); } } } 拿到beanName\n用beanName和bd去registry里注册.\nregistry是个接口,具体的实现在4.3.7版本中看到两种,一种是SimpleBeanDefinitionRegistry里,和它名字一样非常简单,就是塞进map, 另外一种就复杂了,稍后我们再来看\n用beanName和alias去registry里注册\n注册aliases也是接口 ,BeanDefinitionRegistry还是继承自AliasRegistry的, 4.3.7只看到SimpleAliasRegistry一种实现\n注册alias就简单多了, SimpleAliasRegistry里有\nprivate final Map\u003cString, String\u003e aliasMap = new ConcurrentHashMap(16); 稍后我再另开一文把SimpleAliasRegistry来读一遍\n注册BeanDefinitionHolder 除了之前的SimpleBeanDefinitionRegistry 直接往map里面塞值的注册方式之外,我们还有DefaultListableBeanFactory 这个类来实现注册功能,我们主要来了解一下这种注册方式\n校验空参数\n如果bdh是AbstractBeanDefinition ,那就要执行它的validate() 校验\nbdh的methodOverride和它的工厂不能同时存在 如果它beanClass有值,那就要为方法覆盖做准备 prepareMethodOverrides() ,遍历它的overrides,找这个Bean的Class里面有几个叫这个名字的方法, 如果0个,就抛错,如果1个,就设置重载属性为false表示没重载. 从这个工厂里面beanDefinitionMap 拿原来的叫这个beanName的bd出来,如果不为空,进行下列校验及操作\n书中源码spring 3.2 采用sychronized , 而4.3版本的beanDefinitionMap已经用上了ConcurrentHashMap,并且map的value用了BD,而不是3.2里面的Object\n如果工厂不允许bean覆盖,那么抛错 如果旧bean的role值小于新的,或者新旧bd完全相等,或者不相等,各打印一下日志 把新的bd放入beanDefinitionMap 第一次注册这个bean, 如果本工厂的alreadyCreated 也是空的话,那就不用加锁,直接\n//map里塞入bd this.beanDefinitionMap.put(beanName, beanDefinition); //已注册名字里加入beanName this.beanDefinitionNames.add(beanName); //唯一名册里移出beanName(啥时候加入了???) this.manualSingletonNames.remove(beanName); 如果本工程已经有创建过bean了,那么接下来一段代码就要加synchronized了\nMap var4 = this.beanDefinitionMap; synchronized(this.beanDefinitionMap) { //map里塞入bd this.beanDefinitionMap.put(beanName, beanDefinition); //注意到后面这段操作其实是新建个数组,加上这次注册beanName,然后替换之前的数组.... //为什么这么复杂呢??? List\u003cString\u003e updatedDefinitions = new ArrayList(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); this.beanDefinitionNames = updatedDefinitions; //如果唯一名册里包含beanName if (this.manualSingletonNames.contains(beanName)) { //就移出去,但是这里也和上面一样,搞替换.... Set\u003cString\u003e updatedSingletons = new LinkedHashSet(this.manualSingletonNames); updatedSingletons.remove(beanName); this.manualSingletonNames = updatedSingletons; } } 疑问: 这里都用了替换,明明beanDefinitionNames 和manualSingletonNames 都是volatile声明的,每次读都从主内存取,每次写都都将值写到主内存, 这里为什么还要这么麻烦得去开新的list和set,替换旧的呢?\n答:从网上搜到,volatile修饰的变量如果是对象或数组之类的，其含义是对象或数组的地址具有可见性，但是数组或对象内部的成员改变不具备可见性,那等于就是说非得整个地址替换才行咯.\n很爽,从这本书要跳到我正在读的并发编程相关的内容了,这几天再去研究一波volatile,可以再开一文. 准备参考地址\n然后this.frozenBeanDefinitionNames = null; 这个冻结/取消冻结bdNames的功能暂时也不知道干啥的,在注册和删除bd的地方看到了这样的置为null,\n​ 只在freezeConfiguration() 方法内看到把它置为bdNames转的String[] .\n​ 另外在getBeanDefinitionNames() 方法里有判断这个\n然后\n//如果有老bd或者 这个bean是单例对象? if (oldBeanDefinition != null || this.containsSingleton(beanName)) { //重置bean this.resetBeanDefinition(beanName); } 重置的主要内容有\n清除mergedBD 销毁单例 遍历之前的bean,看新注册的这个bean是谁的爹(parent),那些儿子也都要调用这个方法进行重置 不得不说这个DefaultListableBeanFactory 的成员变量实在太多了,搞不清楚一个个都是要干啥的,后面再次遇到的时候再慢慢看吧\n注册Alias 4.3.7版本的实现在SimpleAliasRegistry 里, 详情见 这一篇博文\n注册完成 其实没有操作了, 但是作者留了个位置在这\nthis.getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); 如果程序开发人员需要对注册BeanDefinition时间进行监听时,可以通过注册监听器的方式来做.Spring并没有再此做任何逻辑处理\n告一段落 至此,我们的解析注册Bean标签可算是告一段落啦,虽然里面还留下了很多疑问待后续阅读中弄清.\n先想想之前是在哪分叉出去的吧.\nprivate void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) { if (delegate.nodeNameEquals(ele, \"import\")) { this.importBeanDefinitionResource(ele); } else if (delegate.nodeNameEquals(ele, \"alias\")) { this.processAliasRegistration(ele); } else if (delegate.nodeNameEquals(ele, \"bean\")) { //就是这里啦,我们先去阅读最复杂的bean的 this.processBeanDefinition(ele, delegate); } else if (delegate.nodeNameEquals(ele, \"beans\")) { //这个地方我还记得,beans标签是绕回去解析的,不用看了 this.doRegisterBeanDefinitions(ele); } } 再之前呢,\nprotected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) { if (delegate.isDefaultNamespace(root)) { NodeList nl = root.getChildNodes(); for(int i = 0; i \u003c nl.getLength(); ++i) { Node node = nl.item(i); if (node instanceof Element) { Element ele = (Element)node; if (delegate.isDefaultNamespace(ele)) { //就是这个地方,差不多想起来了,beans标签里面的子元素, 如果是默认命名空间,就按默认方式去解析 this.parseDefaultElement(ele, delegate); } else { //这里是个分叉,解析自定义元素,以后再看 delegate.parseCustomElement(ele); } } } } else { //这和上面一样的分叉,解析自定义元素 delegate.parseCustomElement(root); } } 再之前呢\nprotected void doRegisterBeanDefinitions(Element root) { BeanDefinitionParserDelegate parent = this.delegate; this.delegate = this.createDelegate(this.getReaderContext(), root, parent); if (this.delegate.isDefaultNamespace(root)) { String profileSpec = root.getAttribute(\"profile\"); if (StringUtils.hasText(profileSpec)) { String[] specifiedProfiles = StringUtils.tokenizeToStringArray(profileSpec, \",; \"); if (!this.getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) { if (this.logger.isInfoEnabled()) { this.logger.info(\"Skipped XML bean definition file due to specified profiles [\" + profileSpec + \"] not matching: \" + this.getReaderContext().getResource()); } return; } } } this.preProcessXml(root); //从这里走出去的 this.parseBeanDefinitions(root, this.delegate); this.postProcessXml(root); this.delegate = parent; } 到这还要温习一遍的话,可以去看Spring的第一篇笔记了\n哈哈,这么点东西,读了一个礼拜,读了后面的忘了前面的,还是在读读记记的情况下,\n要是没有这个笔记,这时候估计已经迷路得要放弃了,不容易啊\n不说了 SimpleAliasRegistry 和volatile 两篇文章的坑还留着呢,继续…\n","wordCount":"375","inLanguage":"en","datePublished":"2017-09-15T21:26:00Z","dateModified":"2017-09-15T21:26:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://heeexy.com/posts/spring-note-6-registerbeandefinition/"},"publisher":{"@type":"Organization","name":"网站标题","logo":{"@type":"ImageObject","url":"https://heeexy.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://heeexy.com/ accesskey=h title="网站标题 (Alt + H)">网站标题</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Spring源码笔记-1.4 获取bean流程之注册BeanDefinition</h1><div class=post-meta><span title='2017-09-15 21:26:00 +0000 UTC'>September 15, 2017</span></div></header><div class=post-content><h3 id=本文要看啥>本文要看啥<a hidden class=anchor aria-hidden=true href=#本文要看啥>#</a></h3><hr><p>这个bean总算是解析完了,也装饰完了,等于是说信息我们都提取好了,现在该做的就是去注册啦.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span> BeanDefinitionReaderUtils.<span style=color:#a6e22e>registerBeanDefinition</span>(bdHolder, <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>getReaderContext</span>().<span style=color:#a6e22e>getRegistry</span>());
</span></span></code></pre></div><p>就是这个方法了</p><h3 id=开始进入方法吧>开始进入方法吧<a hidden class=anchor aria-hidden=true href=#开始进入方法吧>#</a></h3><hr><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>registerBeanDefinition</span>(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) <span style=color:#66d9ef>throws</span> BeanDefinitionStoreException {
</span></span><span style=display:flex><span>    String beanName <span style=color:#f92672>=</span> definitionHolder.<span style=color:#a6e22e>getBeanName</span>();
</span></span><span style=display:flex><span>    registry.<span style=color:#a6e22e>registerBeanDefinition</span>(beanName, definitionHolder.<span style=color:#a6e22e>getBeanDefinition</span>());
</span></span><span style=display:flex><span>    String<span style=color:#f92672>[]</span> aliases <span style=color:#f92672>=</span> definitionHolder.<span style=color:#a6e22e>getAliases</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (aliases <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        String<span style=color:#f92672>[]</span> var4 <span style=color:#f92672>=</span> aliases;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> var5 <span style=color:#f92672>=</span> aliases.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> var6 <span style=color:#f92672>=</span> 0; var6 <span style=color:#f92672>&lt;</span> var5; <span style=color:#f92672>++</span>var6) {
</span></span><span style=display:flex><span>            String alias <span style=color:#f92672>=</span> var4<span style=color:#f92672>[</span>var6<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>            registry.<span style=color:#a6e22e>registerAlias</span>(beanName, alias);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol><li><p>拿到beanName</p></li><li><p>用beanName和bd去registry里注册.</p><blockquote><p>registry是个接口,具体的实现在4.3.7版本中看到两种,一种是SimpleBeanDefinitionRegistry里,和它名字一样非常简单,就是塞进map, 另外一种就复杂了,稍后我们再来看</p></blockquote></li><li><p>用beanName和alias去registry里注册</p><blockquote><p>注册aliases也是接口 ,BeanDefinitionRegistry还是继承自AliasRegistry的, 4.3.7只看到SimpleAliasRegistry一种实现</p></blockquote><p>注册alias就简单多了, SimpleAliasRegistry里有</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Map<span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;</span> aliasMap <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ConcurrentHashMap(16);
</span></span></code></pre></div><p>稍后我再另开一文把SimpleAliasRegistry来读一遍</p></li></ol><h3 id=注册beandefinitionholder>注册BeanDefinitionHolder<a hidden class=anchor aria-hidden=true href=#注册beandefinitionholder>#</a></h3><hr><p>除了之前的<code>SimpleBeanDefinitionRegistry</code> 直接往map里面塞值的注册方式之外,我们还有DefaultListableBeanFactory 这个类来实现注册功能,我们主要来了解一下这种注册方式</p><ol><li><p>校验空参数</p></li><li><p>如果bdh是<code>AbstractBeanDefinition</code> ,那就要执行它的<code>validate()</code> 校验</p><ol><li>bdh的methodOverride和它的工厂<strong>不能同时存在</strong></li><li>如果它beanClass有值,那就要为方法覆盖做准备 <code>prepareMethodOverrides()</code> ,遍历它的overrides,找这个Bean的Class里面有几个叫这个名字的方法, <strong>如果0个,就抛错</strong>,如果1个,就设置重载属性为false表示没重载.</li></ol></li><li><p>从这个工厂里面<code>beanDefinitionMap</code> 拿原来的叫这个beanName的bd出来,如果不为空,进行下列校验及操作</p><blockquote><p>书中源码spring 3.2 采用sychronized , 而4.3版本的beanDefinitionMap已经用上了ConcurrentHashMap,并且map的value用了BD,而不是3.2里面的Object</p></blockquote><ol><li>如果工厂不允许bean覆盖,那么抛错</li><li>如果旧bean的role值小于新的,或者新旧bd完全相等,或者不相等,各打印一下日志</li><li>把新的bd放入<code>beanDefinitionMap</code></li></ol></li><li><p>第一次注册这个bean, 如果本工厂的<code>alreadyCreated</code> 也是空的话,那就不用加锁,直接</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span> <span style=color:#75715e>//map里塞入bd                </span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>beanDefinitionMap</span>.<span style=color:#a6e22e>put</span>(beanName, beanDefinition);
</span></span><span style=display:flex><span> <span style=color:#75715e>//已注册名字里加入beanName              </span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>beanDefinitionNames</span>.<span style=color:#a6e22e>add</span>(beanName);
</span></span><span style=display:flex><span> <span style=color:#75715e>//唯一名册里移出beanName(啥时候加入了???)              </span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>manualSingletonNames</span>.<span style=color:#a6e22e>remove</span>(beanName);
</span></span></code></pre></div><p>如果本工程已经有创建过bean了,那么接下来一段代码就要加synchronized了</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Map var4 <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>beanDefinitionMap</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>synchronized</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>beanDefinitionMap</span>) {
</span></span><span style=display:flex><span>   <span style=color:#75715e>//map里塞入bd        </span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>beanDefinitionMap</span>.<span style=color:#a6e22e>put</span>(beanName, beanDefinition);
</span></span><span style=display:flex><span>  <span style=color:#75715e>//注意到后面这段操作其实是新建个数组,加上这次注册beanName,然后替换之前的数组....</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//为什么这么复杂呢???</span>
</span></span><span style=display:flex><span>    List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> updatedDefinitions <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>beanDefinitionNames</span>.<span style=color:#a6e22e>size</span>() <span style=color:#f92672>+</span> 1);
</span></span><span style=display:flex><span>    updatedDefinitions.<span style=color:#a6e22e>addAll</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>beanDefinitionNames</span>);
</span></span><span style=display:flex><span>    updatedDefinitions.<span style=color:#a6e22e>add</span>(beanName);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>beanDefinitionNames</span> <span style=color:#f92672>=</span> updatedDefinitions;
</span></span><span style=display:flex><span>  <span style=color:#75715e>//如果唯一名册里包含beanName</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>manualSingletonNames</span>.<span style=color:#a6e22e>contains</span>(beanName)) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>//就移出去,但是这里也和上面一样,搞替换....</span>
</span></span><span style=display:flex><span>        Set<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> updatedSingletons <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LinkedHashSet(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>manualSingletonNames</span>);
</span></span><span style=display:flex><span>        updatedSingletons.<span style=color:#a6e22e>remove</span>(beanName);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>manualSingletonNames</span> <span style=color:#f92672>=</span> updatedSingletons;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>疑问: 这里都用了替换,明明<code>beanDefinitionNames</code> 和<code>manualSingletonNames</code> 都是volatile声明的,每次读都从主内存取,每次写都都将值写到主内存, 这里为什么还要这么麻烦得去开新的list和set,替换旧的呢?</p><p>答:从网上搜到,volatile修饰的变量如果是对象或数组之类的，其含义是对象或数组的<strong>地址具有可见性</strong>，但是数组或对象<strong>内部的成员改变不具备可见性</strong>,那等于就是说非得整个地址替换才行咯.</p><p>很爽,从这本书要跳到我正在读的并发编程相关的内容了,这几天再去研究一波volatile,可以再开一文. <a href=http://blog.csdn.net/u014108122/article/details/38173201>准备参考地址</a></p></blockquote></li></ol><p>然后<code>this.frozenBeanDefinitionNames = null;</code> 这个冻结/取消冻结bdNames的功能暂时也不知道干啥的,在注册和删除bd的地方看到了这样的置为null,</p><p>​ 只在<code>freezeConfiguration()</code> 方法内看到把它置为bdNames转的String[] .</p><p>​ 另外在<code>getBeanDefinitionNames()</code> 方法里有判断这个</p><p>然后</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>//如果有老bd或者 这个bean是单例对象?</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (oldBeanDefinition <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>containsSingleton</span>(beanName)) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>//重置bean</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>resetBeanDefinition</span>(beanName);
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p>重置的主要内容有</p><ul><li>清除mergedBD</li><li>销毁单例</li><li>遍历之前的bean,看新注册的这个bean是谁的爹(parent),那些儿子也都要调用这个方法进行重置</li></ul><blockquote><p>不得不说这个<code>DefaultListableBeanFactory</code> 的成员变量实在太多了,搞不清楚一个个都是要干啥的,后面再次遇到的时候再慢慢看吧</p></blockquote><h3 id=注册alias>注册Alias<a hidden class=anchor aria-hidden=true href=#注册alias>#</a></h3><hr><p>4.3.7版本的实现在<code>SimpleAliasRegistry</code> 里, 详情见 <a href=/2017/09/15/spring_SimpleAliasRegistry/>这一篇博文</a></p><h3 id=注册完成>注册完成<a hidden class=anchor aria-hidden=true href=#注册完成>#</a></h3><hr><p>其实没有操作了, 但是作者留了个位置在这</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>  <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>getReaderContext</span>().<span style=color:#a6e22e>fireComponentRegistered</span>(<span style=color:#66d9ef>new</span> BeanComponentDefinition(bdHolder));
</span></span></code></pre></div><p>如果程序开发人员需要对注册BeanDefinition时间进行监听时,可以通过注册监听器的方式来做.Spring并没有再此做任何逻辑处理</p><h3 id=告一段落>告一段落<a hidden class=anchor aria-hidden=true href=#告一段落>#</a></h3><hr><p>至此,我们的解析注册Bean标签可算是告一段落啦,虽然里面还留下了很多疑问待后续阅读中弄清.</p><p>先想想之前是在哪分叉出去的吧.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span> <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>parseDefaultElement</span>(Element ele, BeanDefinitionParserDelegate delegate) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (delegate.<span style=color:#a6e22e>nodeNameEquals</span>(ele, <span style=color:#e6db74>&#34;import&#34;</span>)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>importBeanDefinitionResource</span>(ele);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (delegate.<span style=color:#a6e22e>nodeNameEquals</span>(ele, <span style=color:#e6db74>&#34;alias&#34;</span>)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>processAliasRegistration</span>(ele);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (delegate.<span style=color:#a6e22e>nodeNameEquals</span>(ele, <span style=color:#e6db74>&#34;bean&#34;</span>)) {
</span></span><span style=display:flex><span>          <span style=color:#75715e>//就是这里啦,我们先去阅读最复杂的bean的</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>processBeanDefinition</span>(ele, delegate);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (delegate.<span style=color:#a6e22e>nodeNameEquals</span>(ele, <span style=color:#e6db74>&#34;beans&#34;</span>)) {
</span></span><span style=display:flex><span>          <span style=color:#75715e>//这个地方我还记得,beans标签是绕回去解析的,不用看了</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>doRegisterBeanDefinitions</span>(ele);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>再之前呢,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>parseBeanDefinitions</span>(Element root, BeanDefinitionParserDelegate delegate) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (delegate.<span style=color:#a6e22e>isDefaultNamespace</span>(root)) {
</span></span><span style=display:flex><span>            NodeList nl <span style=color:#f92672>=</span> root.<span style=color:#a6e22e>getChildNodes</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> nl.<span style=color:#a6e22e>getLength</span>(); <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>                Node node <span style=color:#f92672>=</span> nl.<span style=color:#a6e22e>item</span>(i);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (node <span style=color:#66d9ef>instanceof</span> Element) {
</span></span><span style=display:flex><span>                    Element ele <span style=color:#f92672>=</span> (Element)node;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (delegate.<span style=color:#a6e22e>isDefaultNamespace</span>(ele)) {
</span></span><span style=display:flex><span>                      <span style=color:#75715e>//就是这个地方,差不多想起来了,beans标签里面的子元素, 如果是默认命名空间,就按默认方式去解析</span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>parseDefaultElement</span>(ele, delegate);
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                      <span style=color:#75715e>//这里是个分叉,解析自定义元素,以后再看</span>
</span></span><span style=display:flex><span>                        delegate.<span style=color:#a6e22e>parseCustomElement</span>(ele);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    		<span style=color:#75715e>//这和上面一样的分叉,解析自定义元素</span>
</span></span><span style=display:flex><span>            delegate.<span style=color:#a6e22e>parseCustomElement</span>(root);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>再之前呢</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>doRegisterBeanDefinitions</span>(Element root) {
</span></span><span style=display:flex><span>    BeanDefinitionParserDelegate parent <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>delegate</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>delegate</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>createDelegate</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>getReaderContext</span>(), root, parent);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>delegate</span>.<span style=color:#a6e22e>isDefaultNamespace</span>(root)) {
</span></span><span style=display:flex><span>        String profileSpec <span style=color:#f92672>=</span> root.<span style=color:#a6e22e>getAttribute</span>(<span style=color:#e6db74>&#34;profile&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (StringUtils.<span style=color:#a6e22e>hasText</span>(profileSpec)) {
</span></span><span style=display:flex><span>            String<span style=color:#f92672>[]</span> specifiedProfiles <span style=color:#f92672>=</span> StringUtils.<span style=color:#a6e22e>tokenizeToStringArray</span>(profileSpec, <span style=color:#e6db74>&#34;,; &#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>getReaderContext</span>().<span style=color:#a6e22e>getEnvironment</span>().<span style=color:#a6e22e>acceptsProfiles</span>(specifiedProfiles)) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>logger</span>.<span style=color:#a6e22e>isInfoEnabled</span>()) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>logger</span>.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;Skipped XML bean definition file due to specified profiles [&#34;</span> <span style=color:#f92672>+</span> profileSpec <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;] not matching: &#34;</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>getReaderContext</span>().<span style=color:#a6e22e>getResource</span>());
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>preProcessXml</span>(root);
</span></span><span style=display:flex><span>    <span style=color:#75715e>//从这里走出去的</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>parseBeanDefinitions</span>(root, <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>delegate</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>postProcessXml</span>(root);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>delegate</span> <span style=color:#f92672>=</span> parent;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>到这还要温习一遍的话,可以去看Spring的<a href=/2017/09/11/spring_note_1/>第一篇笔记</a>了</p><p>哈哈,这么点东西,读了一个礼拜,读了后面的忘了前面的,还是在读读记记的情况下,</p><p>要是没有这个笔记,这时候估计已经迷路得要放弃了,不容易啊</p><p>不说了 <a href=/2017/09/15/spring_SimpleAliasRegistry/>SimpleAliasRegistry</a> 和<code>volatile</code> 两篇文章的坑还留着呢,继续&mldr;</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://heeexy.com/tags/java/>Java</a></li><li><a href=https://heeexy.com/tags/spring/>Spring</a></li><li><a href=https://heeexy.com/tags/%E7%AC%94%E8%AE%B0/>笔记</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://heeexy.com/>网站标题</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>