<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MyBatis 中使用 JSONObject 替代 JavaBean | 网站标题</title>
<meta name=keywords content="MyBatis,JSONObject"><meta name=description content='问题背景 项目后端与前端全部使用 JSON 进行数据交互，比如查询用户列表，通常后端从数据库查出的数据放入实体类再转为 JSON 返回给前端，但是前端的小伙伴表示明明只需要 nickname,avatar,userId 三个字段，为什么传过来的数据多出 phone,address ,profile 之类十几个字段，里面都 null,0 等值？
其实是因为 User 实体类定义了太多字段，转为 JSON 的时候都被包括进去了。稍微多几个还能忍，但通常 User/Order 这些实体类字段特别多，对调试开发实在非常不友好。
因此本次任务就是：确保每个接口返回字段都与接口文档上一模一样，去除冗余字段。
解决过程就省略了，直接抛出我最后的解决方案吧：就是 MyBatis 的返回值几乎完全抛弃实体类，全部使用com.alibaba.fastjson.JSONObject 。
使用 JSONObject 先最简化直观的看一下 JSONObject 的使用吧。
Controller:
@GetMapping("/list") public JSONObject listUser(@RequestBody JSONObject requestJson){ return userService.listUser(requestJson); } Service:
JSONObject listUser(JSONObject jsonObject); ServiceImpl:
@Override public JSONObject listUser(JSONObject jsonObject) { //fillPageParam是自定义的封装分页参数 CommonUtil.fillPageParam(jsonObject); int count = userDao.countUser(jsonObject); List<JSONObject> list = userDao.listUser(jsonObject); //自定义successPage封装分页结果 return CommonUtil.successPage(jsonObject, list, count); } Dao:
public interface UserDao { int countUser(JSONObject jsonObject); List<JSONObject> listUser(JSONObject jsonObject); } UserMapper.'><meta name=author content><link rel=canonical href=https://heeexy.com/posts/mybatis%E4%B8%AD%E4%BD%BF%E7%94%A8jsonobject%E6%9B%BF%E4%BB%A3javabean/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://heeexy.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://heeexy.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://heeexy.com/favicon-32x32.png><link rel=apple-touch-icon href=https://heeexy.com/apple-touch-icon.png><link rel=mask-icon href=https://heeexy.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://heeexy.com/posts/mybatis%E4%B8%AD%E4%BD%BF%E7%94%A8jsonobject%E6%9B%BF%E4%BB%A3javabean/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="MyBatis 中使用 JSONObject 替代 JavaBean"><meta property="og:description" content='问题背景 项目后端与前端全部使用 JSON 进行数据交互，比如查询用户列表，通常后端从数据库查出的数据放入实体类再转为 JSON 返回给前端，但是前端的小伙伴表示明明只需要 nickname,avatar,userId 三个字段，为什么传过来的数据多出 phone,address ,profile 之类十几个字段，里面都 null,0 等值？
其实是因为 User 实体类定义了太多字段，转为 JSON 的时候都被包括进去了。稍微多几个还能忍，但通常 User/Order 这些实体类字段特别多，对调试开发实在非常不友好。
因此本次任务就是：确保每个接口返回字段都与接口文档上一模一样，去除冗余字段。
解决过程就省略了，直接抛出我最后的解决方案吧：就是 MyBatis 的返回值几乎完全抛弃实体类，全部使用com.alibaba.fastjson.JSONObject 。
使用 JSONObject 先最简化直观的看一下 JSONObject 的使用吧。
Controller:
@GetMapping("/list") public JSONObject listUser(@RequestBody JSONObject requestJson){ return userService.listUser(requestJson); } Service:
JSONObject listUser(JSONObject jsonObject); ServiceImpl:
@Override public JSONObject listUser(JSONObject jsonObject) { //fillPageParam是自定义的封装分页参数 CommonUtil.fillPageParam(jsonObject); int count = userDao.countUser(jsonObject); List<JSONObject> list = userDao.listUser(jsonObject); //自定义successPage封装分页结果 return CommonUtil.successPage(jsonObject, list, count); } Dao:
public interface UserDao { int countUser(JSONObject jsonObject); List<JSONObject> listUser(JSONObject jsonObject); } UserMapper.'><meta property="og:type" content="article"><meta property="og:url" content="https://heeexy.com/posts/mybatis%E4%B8%AD%E4%BD%BF%E7%94%A8jsonobject%E6%9B%BF%E4%BB%A3javabean/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-12-30T21:51:55+00:00"><meta property="article:modified_time" content="2017-12-30T21:51:55+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="MyBatis 中使用 JSONObject 替代 JavaBean"><meta name=twitter:description content='问题背景 项目后端与前端全部使用 JSON 进行数据交互，比如查询用户列表，通常后端从数据库查出的数据放入实体类再转为 JSON 返回给前端，但是前端的小伙伴表示明明只需要 nickname,avatar,userId 三个字段，为什么传过来的数据多出 phone,address ,profile 之类十几个字段，里面都 null,0 等值？
其实是因为 User 实体类定义了太多字段，转为 JSON 的时候都被包括进去了。稍微多几个还能忍，但通常 User/Order 这些实体类字段特别多，对调试开发实在非常不友好。
因此本次任务就是：确保每个接口返回字段都与接口文档上一模一样，去除冗余字段。
解决过程就省略了，直接抛出我最后的解决方案吧：就是 MyBatis 的返回值几乎完全抛弃实体类，全部使用com.alibaba.fastjson.JSONObject 。
使用 JSONObject 先最简化直观的看一下 JSONObject 的使用吧。
Controller:
@GetMapping("/list") public JSONObject listUser(@RequestBody JSONObject requestJson){ return userService.listUser(requestJson); } Service:
JSONObject listUser(JSONObject jsonObject); ServiceImpl:
@Override public JSONObject listUser(JSONObject jsonObject) { //fillPageParam是自定义的封装分页参数 CommonUtil.fillPageParam(jsonObject); int count = userDao.countUser(jsonObject); List<JSONObject> list = userDao.listUser(jsonObject); //自定义successPage封装分页结果 return CommonUtil.successPage(jsonObject, list, count); } Dao:
public interface UserDao { int countUser(JSONObject jsonObject); List<JSONObject> listUser(JSONObject jsonObject); } UserMapper.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://heeexy.com/posts/"},{"@type":"ListItem","position":2,"name":"MyBatis 中使用 JSONObject 替代 JavaBean","item":"https://heeexy.com/posts/mybatis%E4%B8%AD%E4%BD%BF%E7%94%A8jsonobject%E6%9B%BF%E4%BB%A3javabean/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MyBatis 中使用 JSONObject 替代 JavaBean","name":"MyBatis 中使用 JSONObject 替代 JavaBean","description":"问题背景 项目后端与前端全部使用 JSON 进行数据交互，比如查询用户列表，通常后端从数据库查出的数据放入实体类再转为 JSON 返回给前端，但是前端的小伙伴表示明明只需要 nickname,avatar,userId 三个字段，为什么传过来的数据多出 phone,address ,profile 之类十几个字段，里面都 null,0 等值？\n其实是因为 User 实体类定义了太多字段，转为 JSON 的时候都被包括进去了。稍微多几个还能忍，但通常 User/Order 这些实体类字段特别多，对调试开发实在非常不友好。\n因此本次任务就是：确保每个接口返回字段都与接口文档上一模一样，去除冗余字段。\n解决过程就省略了，直接抛出我最后的解决方案吧：就是 MyBatis 的返回值几乎完全抛弃实体类，全部使用com.alibaba.fastjson.JSONObject 。\n使用 JSONObject 先最简化直观的看一下 JSONObject 的使用吧。\nController:\n@GetMapping(\u0026#34;/list\u0026#34;) public JSONObject listUser(@RequestBody JSONObject requestJson){ return userService.listUser(requestJson); } Service:\nJSONObject listUser(JSONObject jsonObject); ServiceImpl:\n@Override public JSONObject listUser(JSONObject jsonObject) { //fillPageParam是自定义的封装分页参数 CommonUtil.fillPageParam(jsonObject); int count = userDao.countUser(jsonObject); List\u0026lt;JSONObject\u0026gt; list = userDao.listUser(jsonObject); //自定义successPage封装分页结果 return CommonUtil.successPage(jsonObject, list, count); } Dao:\npublic interface UserDao { int countUser(JSONObject jsonObject); List\u0026lt;JSONObject\u0026gt; listUser(JSONObject jsonObject); } UserMapper.","keywords":["MyBatis","JSONObject"],"articleBody":"问题背景 项目后端与前端全部使用 JSON 进行数据交互，比如查询用户列表，通常后端从数据库查出的数据放入实体类再转为 JSON 返回给前端，但是前端的小伙伴表示明明只需要 nickname,avatar,userId 三个字段，为什么传过来的数据多出 phone,address ,profile 之类十几个字段，里面都 null,0 等值？\n其实是因为 User 实体类定义了太多字段，转为 JSON 的时候都被包括进去了。稍微多几个还能忍，但通常 User/Order 这些实体类字段特别多，对调试开发实在非常不友好。\n因此本次任务就是：确保每个接口返回字段都与接口文档上一模一样，去除冗余字段。\n解决过程就省略了，直接抛出我最后的解决方案吧：就是 MyBatis 的返回值几乎完全抛弃实体类，全部使用com.alibaba.fastjson.JSONObject 。\n使用 JSONObject 先最简化直观的看一下 JSONObject 的使用吧。\nController:\n@GetMapping(\"/list\") public JSONObject listUser(@RequestBody JSONObject requestJson){ return userService.listUser(requestJson); } Service:\nJSONObject listUser(JSONObject jsonObject); ServiceImpl:\n@Override public JSONObject listUser(JSONObject jsonObject) { //fillPageParam是自定义的封装分页参数 CommonUtil.fillPageParam(jsonObject); int count = userDao.countUser(jsonObject); List\u003cJSONObject\u003e list = userDao.listUser(jsonObject); //自定义successPage封装分页结果 return CommonUtil.successPage(jsonObject, list, count); } Dao:\npublic interface UserDao { int countUser(JSONObject jsonObject); List\u003cJSONObject\u003e listUser(JSONObject jsonObject); } UserMapper.xml , 这里的 resultType 直接就是 JSONObject ,如果是一对多的情况，就要多加一步，请移步看这篇文章。\n","wordCount":"248","inLanguage":"en","datePublished":"2017-12-30T21:51:55Z","dateModified":"2017-12-30T21:51:55Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://heeexy.com/posts/mybatis%E4%B8%AD%E4%BD%BF%E7%94%A8jsonobject%E6%9B%BF%E4%BB%A3javabean/"},"publisher":{"@type":"Organization","name":"网站标题","logo":{"@type":"ImageObject","url":"https://heeexy.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://heeexy.com/ accesskey=h title="网站标题 (Alt + H)">网站标题</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">MyBatis 中使用 JSONObject 替代 JavaBean</h1><div class=post-meta><span title='2017-12-30 21:51:55 +0000 UTC'>December 30, 2017</span></div></header><div class=post-content><h1 id=问题背景>问题背景<a hidden class=anchor aria-hidden=true href=#问题背景>#</a></h1><p>项目后端与前端全部使用 JSON 进行数据交互，比如查询用户列表，通常后端从数据库查出的数据放入实体类再转为 JSON 返回给前端，但是前端的小伙伴表示明明只需要 nickname,avatar,userId 三个字段，为什么传过来的数据多出 phone,address ,profile 之类十几个字段，里面都 null,0 等值？</p><p>其实是因为 User 实体类定义了太多字段，转为 JSON 的时候都被包括进去了。稍微多几个还能忍，但通常 User/Order 这些实体类字段特别多，对调试开发实在非常不友好。</p><p>因此本次任务就是：确保每个接口返回字段都与接口文档上一模一样，去除冗余字段。</p><p>解决过程就省略了，直接抛出我最后的解决方案吧：就是 MyBatis 的返回值几乎完全抛弃实体类，全部使用<code>com.alibaba.fastjson.JSONObject</code> 。</p><h1 id=使用-jsonobject>使用 JSONObject<a hidden class=anchor aria-hidden=true href=#使用-jsonobject>#</a></h1><p>先最简化直观的看一下 JSONObject 的使用吧。</p><p>Controller:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@GetMapping</span>(<span style=color:#e6db74>&#34;/list&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> JSONObject <span style=color:#a6e22e>listUser</span>(<span style=color:#a6e22e>@RequestBody</span> JSONObject requestJson){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> userService.<span style=color:#a6e22e>listUser</span>(requestJson);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Service:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>JSONObject <span style=color:#a6e22e>listUser</span>(JSONObject jsonObject);
</span></span></code></pre></div><p>ServiceImpl:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> JSONObject <span style=color:#a6e22e>listUser</span>(JSONObject jsonObject) {
</span></span><span style=display:flex><span>  	<span style=color:#75715e>//fillPageParam是自定义的封装分页参数</span>
</span></span><span style=display:flex><span>    CommonUtil.<span style=color:#a6e22e>fillPageParam</span>(jsonObject);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> count <span style=color:#f92672>=</span> userDao.<span style=color:#a6e22e>countUser</span>(jsonObject);
</span></span><span style=display:flex><span>    List<span style=color:#f92672>&lt;</span>JSONObject<span style=color:#f92672>&gt;</span> list <span style=color:#f92672>=</span> userDao.<span style=color:#a6e22e>listUser</span>(jsonObject);
</span></span><span style=display:flex><span>    <span style=color:#75715e>//自定义successPage封装分页结果</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> CommonUtil.<span style=color:#a6e22e>successPage</span>(jsonObject, list, count);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Dao:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>UserDao</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>countUser</span>(JSONObject jsonObject);
</span></span><span style=display:flex><span>    List<span style=color:#f92672>&lt;</span>JSONObject<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>listUser</span>(JSONObject jsonObject);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>UserMapper.xml , 这里的 resultType 直接就是 JSONObject ,如果是一对多的情况，就要多加一步，请移步看<a href=/2017/12/31/One2Many>这篇文章</a>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;select</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;countUser&#34;</span> <span style=color:#a6e22e>resultType=</span><span style=color:#e6db74>&#34;Integer&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    SELECT count(0)
</span></span><span style=display:flex><span>    FROM sys_user u
</span></span><span style=display:flex><span>  	WHERE age=#{age}
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/select&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;select</span> <span style=color:#a6e22e>id=</span><span style=color:#e6db74>&#34;users&#34;</span> <span style=color:#a6e22e>resultType=</span><span style=color:#e6db74>&#34;com.alibaba.fastjson.JSONObject&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>     SELECT
</span></span><span style=display:flex><span>   		id  		userId,
</span></span><span style=display:flex><span>   		nickname     	nickname,
</span></span><span style=display:flex><span>   		avatar       	avatar
</span></span><span style=display:flex><span>     FROM sys_user
</span></span><span style=display:flex><span>  	 WHERE age=#{age}
</span></span><span style=display:flex><span>     LIMIT #{offSet}, #{pageRow}
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/select&gt;</span>
</span></span></code></pre></div><h1 id=为什么可以使用jsonobject>为什么可以使用JSONObject<a hidden class=anchor aria-hidden=true href=#为什么可以使用jsonobject>#</a></h1><p>因为 JSONObject 实现了 <code>Map&lt;String,Object></code> , MyBatis 那边完全是把它当成 <code>Map&lt;String,Object></code> 处理的，相信不少人都直接用过 map 来接收MyBatis 返回结果。</p><blockquote><p>fastjson 是这样的，Gson 并不是，所以 Gson 的 JsonObject 是不可以的。</p></blockquote><p>有兴趣了解更深入的原理的话，请参考我此系列的其它文章。</p><h1 id=优劣对比>优劣对比<a hidden class=anchor aria-hidden=true href=#优劣对比>#</a></h1><h4 id=便捷性>便捷性<a hidden class=anchor aria-hidden=true href=#便捷性>#</a></h4><p>JSONObject 便捷到可以说是无脑，接收参数、 sql 传参、封装 sql 结果、返回到前端，全程使用。</p><p>JavaBean 则接口层接收参数转为实体类，返回给前端再转为 json，新增一个业务通常还需要多建一个实体类。</p><h4 id=工具方法拓展>工具方法拓展<a hidden class=anchor aria-hidden=true href=#工具方法拓展>#</a></h4><p>JSONObject 可以方便地封装出通用的工具方法，比如封装分页信息，比如封装处理结果的成功和失败信息，特别是校验参数字段非空，不同的接口通常需要校验的字段不同，如下面这个简单的方法就可以校验各字段是否都非空。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>hasAllRequired</span>(<span style=color:#66d9ef>final</span> JSONObject jsonObject, String requiredColumns) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>StringTools.<span style=color:#a6e22e>isNullOrEmpty</span>(requiredColumns)) {
</span></span><span style=display:flex><span>        String<span style=color:#f92672>[]</span> columns <span style=color:#f92672>=</span> requiredColumns.<span style=color:#a6e22e>split</span>(<span style=color:#e6db74>&#34;,&#34;</span>);
</span></span><span style=display:flex><span>        String missCol <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (String column : columns) {
</span></span><span style=display:flex><span>            Object val <span style=color:#f92672>=</span> jsonObject.<span style=color:#a6e22e>get</span>(column.<span style=color:#a6e22e>trim</span>());
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (StringTools.<span style=color:#a6e22e>isNullOrEmpty</span>(val)) {
</span></span><span style=display:flex><span>                missCol <span style=color:#f92672>+=</span> column <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;  &#34;</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>StringTools.<span style=color:#a6e22e>isNullOrEmpty</span>(missCol)) {
</span></span><span style=display:flex><span>            jsonObject.<span style=color:#a6e22e>clear</span>();
</span></span><span style=display:flex><span>            jsonObject.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;returnCode&#34;</span>, ErrorEnum.<span style=color:#a6e22e>E_90003</span>.<span style=color:#a6e22e>getErrorCode</span>());
</span></span><span style=display:flex><span>            jsonObject.<span style=color:#a6e22e>put</span>(<span style=color:#e6db74>&#34;returnMsg&#34;</span>, <span style=color:#e6db74>&#34;缺少必填参数:&#34;</span> <span style=color:#f92672>+</span> missCol.<span style=color:#a6e22e>trim</span>());
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> CommonJsonException(jsonObject);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>JavaBean 在处理分页上通常要引各自写的 PageBean 工具类 , 使用过程通常不会比上面ServiceImpl里的分页简单。</p><p>JavaBean 的参数校验都不用说，更头痛更复杂了，不知道有没有人有用起来很爽的方法。</p><h4 id=返回字段>返回字段<a hidden class=anchor aria-hidden=true href=#返回字段>#</a></h4><p>JSONObject 想返回几个字段就几个字段，而 JavaBean 如果只想返回某几个字段的话，就需要单独建个实体类。</p><p>字段有改动的话，JSONObject 灵活性就更强了，直接在 mapper.xml 里改下就完事。</p><h4 id=业务层>业务层<a hidden class=anchor aria-hidden=true href=#业务层>#</a></h4><p>不可否认的是，JSONObject 在业务层进行处理时，失去了 JavaBean 的编译提示，也失去了 IDE 的快捷补全，更有可能出现取错值的情况。</p><p>比如 jsonObject.getString(&ldquo;pasword&rdquo;) ,输入错了单词都可能没注意，最终取出来 null 。</p><h4 id=可读性>可读性<a hidden class=anchor aria-hidden=true href=#可读性>#</a></h4><p>通常大家可能认为 JavaBean 有更好的可读性，我觉得只要变量名取得好，JSONObject 也是没有什么问题的。毕竟类名是固定死的，变量名和参数名才能更好地反映此处业务的处理。</p><p>尤其是如今前后端分离的项目，前后端开发人员一般对照着文档确认字段含义。</p><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>JSONObject 开发非常方便，具有更强的灵活性，适用于中小型项目，简单业务的开发，也适用于<strong>文档至上</strong>的前后端分离开发与微服务项目。</p><p>更具体的用法，可以参考 <a href=https://github.com/Heeexy/SpringBoot-Shiro-Vue>Github 项目</a>。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://heeexy.com/tags/mybatis/>MyBatis</a></li><li><a href=https://heeexy.com/tags/jsonobject/>JSONObject</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://heeexy.com/>网站标题</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>