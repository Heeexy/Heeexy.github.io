<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Spring源码笔记-1.6 自定义标签的解析 | 网站标题</title>
<meta name=keywords content="java,spring,笔记"><meta name=description content='自定义标签的使用 主要内容都在书上,p80
关键的部分为
创建XSD文件 创建类 继承AbstractSingleBeanDefinitionParser , 其继承关系最主要是实现了BeanDefinitionParser 接口,顾名思义,可以用来解析bean. 创建Handler文件, 继承自 NamespaceHandlerSupport ,目的是将上面的组件注册到Spring容器内 编写Spring.handlers 和 Spring.schemas文件. 这样,自定义的配置就结束了.
Spring加载自定义bean的流程主要就是遇到自定义标签后就去Spring.handlers和Spring.schemas中取找对应的handler 和 XSD .从而可以拿到parser
而代码里的主要步骤为
拿到标签对应的命名空间 根据命名空间找到对应的handler 调用handler的parse方法 获取标签的命名空间 调用org.w3c.dom.Node中的getNamespaceURI()
提取自定义标签处理器 NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); 这个resolve方法是接口,由DefaultNamespaceHandlerResolver 默认命名空间解析器来实现,其实现里面的第一步便是
Map<String, Object> handlerMappings = this.getHandlerMappings(); 原来handlerMappings 是个map,想必是在注册时肯定把解析器添加到这个map里面来,用namespaceUri做key,这样找的时候就很好找了.
取出结果如果是NamespaceHandler 便可以返回,往下读我们发现,之所以这么爽取出来就是handler,是因为已经做过这个解析,把找出的handler塞入了map,相当于是缓存了.
否则就是类名 className, 我们需要把它转为handler
//使用反射,将类路径转化为类 Class<?> handlerClass = ClassUtils.forName(className, this.classLoader); if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) { throw new FatalBeanException("Class [" + className + "] for namespace [" + namespaceUri + "] does not implement the [" + NamespaceHandler.'><meta name=author content><link rel=canonical href=https://heeexy.com/posts/spring-note-8-custom-element/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://heeexy.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://heeexy.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://heeexy.com/favicon-32x32.png><link rel=apple-touch-icon href=https://heeexy.com/apple-touch-icon.png><link rel=mask-icon href=https://heeexy.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://heeexy.com/posts/spring-note-8-custom-element/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Spring源码笔记-1.6 自定义标签的解析"><meta property="og:description" content='自定义标签的使用 主要内容都在书上,p80
关键的部分为
创建XSD文件 创建类 继承AbstractSingleBeanDefinitionParser , 其继承关系最主要是实现了BeanDefinitionParser 接口,顾名思义,可以用来解析bean. 创建Handler文件, 继承自 NamespaceHandlerSupport ,目的是将上面的组件注册到Spring容器内 编写Spring.handlers 和 Spring.schemas文件. 这样,自定义的配置就结束了.
Spring加载自定义bean的流程主要就是遇到自定义标签后就去Spring.handlers和Spring.schemas中取找对应的handler 和 XSD .从而可以拿到parser
而代码里的主要步骤为
拿到标签对应的命名空间 根据命名空间找到对应的handler 调用handler的parse方法 获取标签的命名空间 调用org.w3c.dom.Node中的getNamespaceURI()
提取自定义标签处理器 NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); 这个resolve方法是接口,由DefaultNamespaceHandlerResolver 默认命名空间解析器来实现,其实现里面的第一步便是
Map<String, Object> handlerMappings = this.getHandlerMappings(); 原来handlerMappings 是个map,想必是在注册时肯定把解析器添加到这个map里面来,用namespaceUri做key,这样找的时候就很好找了.
取出结果如果是NamespaceHandler 便可以返回,往下读我们发现,之所以这么爽取出来就是handler,是因为已经做过这个解析,把找出的handler塞入了map,相当于是缓存了.
否则就是类名 className, 我们需要把它转为handler
//使用反射,将类路径转化为类 Class<?> handlerClass = ClassUtils.forName(className, this.classLoader); if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) { throw new FatalBeanException("Class [" + className + "] for namespace [" + namespaceUri + "] does not implement the [" + NamespaceHandler.'><meta property="og:type" content="article"><meta property="og:url" content="https://heeexy.com/posts/spring-note-8-custom-element/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-09-19T19:33:23+00:00"><meta property="article:modified_time" content="2017-09-19T19:33:23+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Spring源码笔记-1.6 自定义标签的解析"><meta name=twitter:description content='自定义标签的使用 主要内容都在书上,p80
关键的部分为
创建XSD文件 创建类 继承AbstractSingleBeanDefinitionParser , 其继承关系最主要是实现了BeanDefinitionParser 接口,顾名思义,可以用来解析bean. 创建Handler文件, 继承自 NamespaceHandlerSupport ,目的是将上面的组件注册到Spring容器内 编写Spring.handlers 和 Spring.schemas文件. 这样,自定义的配置就结束了.
Spring加载自定义bean的流程主要就是遇到自定义标签后就去Spring.handlers和Spring.schemas中取找对应的handler 和 XSD .从而可以拿到parser
而代码里的主要步骤为
拿到标签对应的命名空间 根据命名空间找到对应的handler 调用handler的parse方法 获取标签的命名空间 调用org.w3c.dom.Node中的getNamespaceURI()
提取自定义标签处理器 NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); 这个resolve方法是接口,由DefaultNamespaceHandlerResolver 默认命名空间解析器来实现,其实现里面的第一步便是
Map<String, Object> handlerMappings = this.getHandlerMappings(); 原来handlerMappings 是个map,想必是在注册时肯定把解析器添加到这个map里面来,用namespaceUri做key,这样找的时候就很好找了.
取出结果如果是NamespaceHandler 便可以返回,往下读我们发现,之所以这么爽取出来就是handler,是因为已经做过这个解析,把找出的handler塞入了map,相当于是缓存了.
否则就是类名 className, 我们需要把它转为handler
//使用反射,将类路径转化为类 Class<?> handlerClass = ClassUtils.forName(className, this.classLoader); if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) { throw new FatalBeanException("Class [" + className + "] for namespace [" + namespaceUri + "] does not implement the [" + NamespaceHandler.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://heeexy.com/posts/"},{"@type":"ListItem","position":2,"name":"Spring源码笔记-1.6 自定义标签的解析","item":"https://heeexy.com/posts/spring-note-8-custom-element/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Spring源码笔记-1.6 自定义标签的解析","name":"Spring源码笔记-1.6 自定义标签的解析","description":"自定义标签的使用 主要内容都在书上,p80\n关键的部分为\n创建XSD文件 创建类 继承AbstractSingleBeanDefinitionParser , 其继承关系最主要是实现了BeanDefinitionParser 接口,顾名思义,可以用来解析bean. 创建Handler文件, 继承自 NamespaceHandlerSupport ,目的是将上面的组件注册到Spring容器内 编写Spring.handlers 和 Spring.schemas文件. 这样,自定义的配置就结束了.\nSpring加载自定义bean的流程主要就是遇到自定义标签后就去Spring.handlers和Spring.schemas中取找对应的handler 和 XSD .从而可以拿到parser\n而代码里的主要步骤为\n拿到标签对应的命名空间 根据命名空间找到对应的handler 调用handler的parse方法 获取标签的命名空间 调用org.w3c.dom.Node中的getNamespaceURI()\n提取自定义标签处理器 NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); 这个resolve方法是接口,由DefaultNamespaceHandlerResolver 默认命名空间解析器来实现,其实现里面的第一步便是\nMap\u0026lt;String, Object\u0026gt; handlerMappings = this.getHandlerMappings(); 原来handlerMappings 是个map,想必是在注册时肯定把解析器添加到这个map里面来,用namespaceUri做key,这样找的时候就很好找了.\n取出结果如果是NamespaceHandler 便可以返回,往下读我们发现,之所以这么爽取出来就是handler,是因为已经做过这个解析,把找出的handler塞入了map,相当于是缓存了.\n否则就是类名 className, 我们需要把它转为handler\n//使用反射,将类路径转化为类 Class\u0026lt;?\u0026gt; handlerClass = ClassUtils.forName(className, this.classLoader); if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) { throw new FatalBeanException(\u0026#34;Class [\u0026#34; + className + \u0026#34;] for namespace [\u0026#34; + namespaceUri + \u0026#34;] does not implement the [\u0026#34; + NamespaceHandler.","keywords":["java","spring","笔记"],"articleBody":"自定义标签的使用 主要内容都在书上,p80\n关键的部分为\n创建XSD文件 创建类 继承AbstractSingleBeanDefinitionParser , 其继承关系最主要是实现了BeanDefinitionParser 接口,顾名思义,可以用来解析bean. 创建Handler文件, 继承自 NamespaceHandlerSupport ,目的是将上面的组件注册到Spring容器内 编写Spring.handlers 和 Spring.schemas文件. 这样,自定义的配置就结束了.\nSpring加载自定义bean的流程主要就是遇到自定义标签后就去Spring.handlers和Spring.schemas中取找对应的handler 和 XSD .从而可以拿到parser\n而代码里的主要步骤为\n拿到标签对应的命名空间 根据命名空间找到对应的handler 调用handler的parse方法 获取标签的命名空间 调用org.w3c.dom.Node中的getNamespaceURI()\n提取自定义标签处理器 NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); 这个resolve方法是接口,由DefaultNamespaceHandlerResolver 默认命名空间解析器来实现,其实现里面的第一步便是\nMap\u003cString, Object\u003e handlerMappings = this.getHandlerMappings(); 原来handlerMappings 是个map,想必是在注册时肯定把解析器添加到这个map里面来,用namespaceUri做key,这样找的时候就很好找了.\n取出结果如果是NamespaceHandler 便可以返回,往下读我们发现,之所以这么爽取出来就是handler,是因为已经做过这个解析,把找出的handler塞入了map,相当于是缓存了.\n否则就是类名 className, 我们需要把它转为handler\n//使用反射,将类路径转化为类 Class\u003c?\u003e handlerClass = ClassUtils.forName(className, this.classLoader); if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) { throw new FatalBeanException(\"Class [\" + className + \"] for namespace [\" + namespaceUri + \"] does not implement the [\" + NamespaceHandler.class.getName() + \"] interface\"); } else { //初始化类 NamespaceHandler namespaceHandler = (NamespaceHandler)BeanUtils.instantiateClass(handlerClass); //调用类自定义的init()方法,这是所有handler都必须实现的方法 namespaceHandler.init(); //塞入缓存 handlerMappings.put(namespaceUri, namespaceHandler); return namespaceHandler; } 设计模式–单例模式 this.getHandlerMappings(); 获取handlerMapping处使用了单例模式\n声明为volatile\nprivate volatile Map\u003cString, Object\u003e handlerMappings; 获取单例时使用双重检查锁定\nprivate Map\u003cString, Object\u003e getHandlerMappings() { if (this.handlerMappings == null) { synchronized(this) { if (this.handlerMappings == null) { try { //读取\"META-INF/spring.handlers\" 转为map Properties mappings = PropertiesLoaderUtils.loadAllProperties(this.handlerMappingsLocation, this.classLoader); if (this.logger.isDebugEnabled()) { this.logger.debug(\"Loaded NamespaceHandler mappings: \" + mappings); } Map\u003cString, Object\u003e handlerMappings = new ConcurrentHashMap(mappings.size()); CollectionUtils.mergePropertiesIntoMap(mappings, handlerMappings); this.handlerMappings = handlerMappings; } catch (IOException var5) { throw new IllegalStateException(\"Unable to load NamespaceHandler mappings from location [\" + this.handlerMappingsLocation + \"]\", var5); } } } } return this.handlerMappings; } 上面的volatile非常关键,如果没有的话,在初始化对象 和 设置handlerMapping指向内存空间 中间可能发生重排序,导致另外的线程拿到了handlerMapping的空间地址,但是其实还没有初始化完成.\n标签解析 拿到解析器之后,就调用解析的parse方法,返回BeanDefinition\n我们的自定义handler里面无需实现parse方法,在父类NamespaceHandlerSupport 中自有实现,\npublic BeanDefinition parse(Element element, ParserContext parserContext) { return this.findParserForElement(element, parserContext).parse(element, parserContext); } 而parse方法主要步骤就是调用自己实现类的parseInternal 方法,parseInternal 方法除了调用我们实现的doParse方法之外,首先会进行一系列的数据准备,包括对beanClass.scope.lazyInit等属性的准备\n","wordCount":"203","inLanguage":"en","datePublished":"2017-09-19T19:33:23Z","dateModified":"2017-09-19T19:33:23Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://heeexy.com/posts/spring-note-8-custom-element/"},"publisher":{"@type":"Organization","name":"网站标题","logo":{"@type":"ImageObject","url":"https://heeexy.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://heeexy.com/ accesskey=h title="网站标题 (Alt + H)">网站标题</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Spring源码笔记-1.6 自定义标签的解析</h1><div class=post-meta><span title='2017-09-19 19:33:23 +0000 UTC'>September 19, 2017</span></div></header><div class=post-content><h2 id=自定义标签的使用>自定义标签的使用<a hidden class=anchor aria-hidden=true href=#自定义标签的使用>#</a></h2><p>主要内容都在书上,p80</p><p>关键的部分为</p><ul><li>创建XSD文件</li><li>创建类 继承AbstractSingleBeanDefinitionParser , 其继承关系最主要是实现了<code>BeanDefinitionParser</code> 接口,顾名思义,可以用来解析bean.</li><li>创建Handler文件, 继承自 NamespaceHandlerSupport ,目的是将上面的组件注册到Spring容器内</li><li>编写Spring.handlers 和 Spring.schemas文件.</li></ul><p>这样,自定义的配置就结束了.</p><p>Spring加载自定义bean的流程主要就是遇到自定义标签后就去Spring.handlers和Spring.schemas中取找对应的handler 和 XSD .从而可以拿到parser</p><p>而代码里的主要步骤为</p><ol><li>拿到标签对应的命名空间</li><li>根据命名空间找到对应的handler</li><li>调用handler的parse方法</li></ol><h2 id=获取标签的命名空间>获取标签的命名空间<a hidden class=anchor aria-hidden=true href=#获取标签的命名空间>#</a></h2><p>调用org.w3c.dom.Node中的getNamespaceURI()</p><h2 id=提取自定义标签处理器>提取自定义标签处理器<a hidden class=anchor aria-hidden=true href=#提取自定义标签处理器>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>NamespaceHandler handler <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>readerContext</span>.<span style=color:#a6e22e>getNamespaceHandlerResolver</span>().<span style=color:#a6e22e>resolve</span>(namespaceUri);
</span></span></code></pre></div><p>这个resolve方法是接口,由DefaultNamespaceHandlerResolver 默认命名空间解析器来实现,其实现里面的第一步便是</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Map<span style=color:#f92672>&lt;</span>String, Object<span style=color:#f92672>&gt;</span> handlerMappings <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>getHandlerMappings</span>();
</span></span></code></pre></div><p>原来<code>handlerMappings</code> 是个map,想必是在注册时肯定把解析器添加到这个map里面来,用namespaceUri做key,这样找的时候就很好找了.</p><p>取出结果如果是NamespaceHandler 便可以返回,往下读我们发现,之所以这么爽取出来就是handler,是因为已经做过这个解析,把找出的handler塞入了map,相当于是缓存了.</p><p>否则就是类名 className, 我们需要把它转为handler</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>			 <span style=color:#75715e>//使用反射,将类路径转化为类</span>
</span></span><span style=display:flex><span>				Class<span style=color:#f92672>&lt;?&gt;</span> handlerClass <span style=color:#f92672>=</span> ClassUtils.<span style=color:#a6e22e>forName</span>(className, <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>classLoader</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>NamespaceHandler.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>isAssignableFrom</span>(handlerClass)) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> FatalBeanException(<span style=color:#e6db74>&#34;Class [&#34;</span> <span style=color:#f92672>+</span> className <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;] for namespace [&#34;</span> <span style=color:#f92672>+</span> namespaceUri <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;] does not implement the [&#34;</span> <span style=color:#f92672>+</span> NamespaceHandler.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>getName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;] interface&#34;</span>);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                  <span style=color:#75715e>//初始化类</span>
</span></span><span style=display:flex><span>                    NamespaceHandler namespaceHandler <span style=color:#f92672>=</span> (NamespaceHandler)BeanUtils.<span style=color:#a6e22e>instantiateClass</span>(handlerClass);
</span></span><span style=display:flex><span>                  <span style=color:#75715e>//调用类自定义的init()方法,这是所有handler都必须实现的方法</span>
</span></span><span style=display:flex><span>                    namespaceHandler.<span style=color:#a6e22e>init</span>();
</span></span><span style=display:flex><span>                  <span style=color:#75715e>//塞入缓存</span>
</span></span><span style=display:flex><span>                    handlerMappings.<span style=color:#a6e22e>put</span>(namespaceUri, namespaceHandler);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> namespaceHandler;
</span></span><span style=display:flex><span>                }
</span></span></code></pre></div><h3 id=设计模式--单例模式>设计模式&ndash;单例模式<a hidden class=anchor aria-hidden=true href=#设计模式--单例模式>#</a></h3><p>this.getHandlerMappings(); 获取handlerMapping处使用了单例模式</p><p>声明为volatile</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> Map<span style=color:#f92672>&lt;</span>String, Object<span style=color:#f92672>&gt;</span> handlerMappings;
</span></span></code></pre></div><p>获取单例时使用双重检查锁定</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> Map<span style=color:#f92672>&lt;</span>String, Object<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>getHandlerMappings</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>handlerMappings</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>synchronized</span>(<span style=color:#66d9ef>this</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>handlerMappings</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                  <span style=color:#75715e>//读取&#34;META-INF/spring.handlers&#34; 转为map</span>
</span></span><span style=display:flex><span>                    Properties mappings <span style=color:#f92672>=</span> PropertiesLoaderUtils.<span style=color:#a6e22e>loadAllProperties</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>handlerMappingsLocation</span>, <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>classLoader</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>logger</span>.<span style=color:#a6e22e>isDebugEnabled</span>()) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>logger</span>.<span style=color:#a6e22e>debug</span>(<span style=color:#e6db74>&#34;Loaded NamespaceHandler mappings: &#34;</span> <span style=color:#f92672>+</span> mappings);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    Map<span style=color:#f92672>&lt;</span>String, Object<span style=color:#f92672>&gt;</span> handlerMappings <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ConcurrentHashMap(mappings.<span style=color:#a6e22e>size</span>());
</span></span><span style=display:flex><span>                    CollectionUtils.<span style=color:#a6e22e>mergePropertiesIntoMap</span>(mappings, handlerMappings);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>handlerMappings</span> <span style=color:#f92672>=</span> handlerMappings;
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (IOException var5) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalStateException(<span style=color:#e6db74>&#34;Unable to load NamespaceHandler mappings from location [&#34;</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>handlerMappingsLocation</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;]&#34;</span>, var5);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>handlerMappings</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的volatile非常关键,如果没有的话,在<strong>初始化对象</strong> 和 <strong>设置handlerMapping指向内存空间</strong> 中间可能发生<strong>重排序</strong>,导致另外的线程拿到了handlerMapping的空间地址,但是其实还没有初始化完成.</p><h2 id=标签解析>标签解析<a hidden class=anchor aria-hidden=true href=#标签解析>#</a></h2><p>拿到解析器之后,就调用解析的parse方法,返回BeanDefinition</p><p>我们的自定义handler里面无需实现parse方法,在父类<code>NamespaceHandlerSupport</code> 中自有实现,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> BeanDefinition <span style=color:#a6e22e>parse</span>(Element element, ParserContext parserContext) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>findParserForElement</span>(element, parserContext).<span style=color:#a6e22e>parse</span>(element, parserContext);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img loading=lazy src=http://ots7yt7am.bkt.clouddn.com/blog/findParserForElement.png alt></p><p>而parse方法主要步骤就是调用自己实现类的<code>parseInternal</code> 方法,<code>parseInternal</code> 方法除了调用我们实现的doParse方法之外,首先会进行一系列的数据准备,包括对beanClass.scope.lazyInit等属性的准备</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://heeexy.com/tags/java/>Java</a></li><li><a href=https://heeexy.com/tags/spring/>Spring</a></li><li><a href=https://heeexy.com/tags/%E7%AC%94%E8%AE%B0/>笔记</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://heeexy.com/>网站标题</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>