<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>JDBC为什么不需要Class.forName() | 网站标题</title>
<meta name=keywords content="java,ClassLoader,DriverManger"><meta name=description content='DriverManager 在初学JDBC时，总是记得开头就要来这么一句
Class.forName("com.mysql.jdbc.Driver"); 然而今天学习类加载机制时偶然知道不需要这句也同样可以正常运行，测试的确如此，看了一眼源码，看似原因很简单，因为无论写不写那段Class.forName，在触发加载DriverManager时，会运行
/** * Load the initial JDBC drivers by checking the System property * jdbc.properties and then use the {@code ServiceLoader} mechanism */ static { loadInitialDrivers(); println("JDBC DriverManager initialized"); } 都会扫描到这个Driver，注册到registeredDrivers中。
如果只要回答这个问题，可能上面的答案就已经足够了。
然而兴趣来了，总想把源码继续看下去到底扫描了啥，咋扫描的，明明
ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class); 这里是 java.sql.Driver 接口，上哪找出来的实现类？
我们就一层层的往下看吧。
ServiceLoader 主要做了两点
设置ClassLoader为当前线程的。（破坏双亲委派，让它rt.jar包中的类可以通过AppClassLoader获取到外部的类，很多讲双亲委派机制的文章已经大书特书过了） 初始化了一个懒加载的迭代器 lookupIterator = new LazyIterator(service, loader);。正是这个迭代器中最终帮我们找到了各种driver注册进去。 LazyIterator 既然是迭代器，最重要的当然是hasNext()和next()方法。
在next()方法中，已经拿到了nextName完整的"com.mysql.cj.jdbc.Driver"类名，说明还是hasNext()方法干了真正的扫描工作。
hasNext()方法的主要工作也都放在了hasNextService()中
private boolean hasNextService() { if (nextName != null) { return true; } if (configs == null) { try { //此处拼出了全名为 META-INF/services/java.'><meta name=author content><link rel=canonical href=https://heeexy.com/posts/drivermaneger/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://heeexy.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://heeexy.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://heeexy.com/favicon-32x32.png><link rel=apple-touch-icon href=https://heeexy.com/apple-touch-icon.png><link rel=mask-icon href=https://heeexy.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://heeexy.com/posts/drivermaneger/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="JDBC为什么不需要Class.forName()"><meta property="og:description" content='DriverManager 在初学JDBC时，总是记得开头就要来这么一句
Class.forName("com.mysql.jdbc.Driver"); 然而今天学习类加载机制时偶然知道不需要这句也同样可以正常运行，测试的确如此，看了一眼源码，看似原因很简单，因为无论写不写那段Class.forName，在触发加载DriverManager时，会运行
/** * Load the initial JDBC drivers by checking the System property * jdbc.properties and then use the {@code ServiceLoader} mechanism */ static { loadInitialDrivers(); println("JDBC DriverManager initialized"); } 都会扫描到这个Driver，注册到registeredDrivers中。
如果只要回答这个问题，可能上面的答案就已经足够了。
然而兴趣来了，总想把源码继续看下去到底扫描了啥，咋扫描的，明明
ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class); 这里是 java.sql.Driver 接口，上哪找出来的实现类？
我们就一层层的往下看吧。
ServiceLoader 主要做了两点
设置ClassLoader为当前线程的。（破坏双亲委派，让它rt.jar包中的类可以通过AppClassLoader获取到外部的类，很多讲双亲委派机制的文章已经大书特书过了） 初始化了一个懒加载的迭代器 lookupIterator = new LazyIterator(service, loader);。正是这个迭代器中最终帮我们找到了各种driver注册进去。 LazyIterator 既然是迭代器，最重要的当然是hasNext()和next()方法。
在next()方法中，已经拿到了nextName完整的"com.mysql.cj.jdbc.Driver"类名，说明还是hasNext()方法干了真正的扫描工作。
hasNext()方法的主要工作也都放在了hasNextService()中
private boolean hasNextService() { if (nextName != null) { return true; } if (configs == null) { try { //此处拼出了全名为 META-INF/services/java.'><meta property="og:type" content="article"><meta property="og:url" content="https://heeexy.com/posts/drivermaneger/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-02-03T19:57:00+00:00"><meta property="article:modified_time" content="2020-02-03T19:57:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="JDBC为什么不需要Class.forName()"><meta name=twitter:description content='DriverManager 在初学JDBC时，总是记得开头就要来这么一句
Class.forName("com.mysql.jdbc.Driver"); 然而今天学习类加载机制时偶然知道不需要这句也同样可以正常运行，测试的确如此，看了一眼源码，看似原因很简单，因为无论写不写那段Class.forName，在触发加载DriverManager时，会运行
/** * Load the initial JDBC drivers by checking the System property * jdbc.properties and then use the {@code ServiceLoader} mechanism */ static { loadInitialDrivers(); println("JDBC DriverManager initialized"); } 都会扫描到这个Driver，注册到registeredDrivers中。
如果只要回答这个问题，可能上面的答案就已经足够了。
然而兴趣来了，总想把源码继续看下去到底扫描了啥，咋扫描的，明明
ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class); 这里是 java.sql.Driver 接口，上哪找出来的实现类？
我们就一层层的往下看吧。
ServiceLoader 主要做了两点
设置ClassLoader为当前线程的。（破坏双亲委派，让它rt.jar包中的类可以通过AppClassLoader获取到外部的类，很多讲双亲委派机制的文章已经大书特书过了） 初始化了一个懒加载的迭代器 lookupIterator = new LazyIterator(service, loader);。正是这个迭代器中最终帮我们找到了各种driver注册进去。 LazyIterator 既然是迭代器，最重要的当然是hasNext()和next()方法。
在next()方法中，已经拿到了nextName完整的"com.mysql.cj.jdbc.Driver"类名，说明还是hasNext()方法干了真正的扫描工作。
hasNext()方法的主要工作也都放在了hasNextService()中
private boolean hasNextService() { if (nextName != null) { return true; } if (configs == null) { try { //此处拼出了全名为 META-INF/services/java.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://heeexy.com/posts/"},{"@type":"ListItem","position":2,"name":"JDBC为什么不需要Class.forName()","item":"https://heeexy.com/posts/drivermaneger/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"JDBC为什么不需要Class.forName()","name":"JDBC为什么不需要Class.forName()","description":"DriverManager 在初学JDBC时，总是记得开头就要来这么一句\nClass.forName(\u0026#34;com.mysql.jdbc.Driver\u0026#34;); 然而今天学习类加载机制时偶然知道不需要这句也同样可以正常运行，测试的确如此，看了一眼源码，看似原因很简单，因为无论写不写那段Class.forName，在触发加载DriverManager时，会运行\n/** * Load the initial JDBC drivers by checking the System property * jdbc.properties and then use the {@code ServiceLoader} mechanism */ static { loadInitialDrivers(); println(\u0026#34;JDBC DriverManager initialized\u0026#34;); } 都会扫描到这个Driver，注册到registeredDrivers中。\n如果只要回答这个问题，可能上面的答案就已经足够了。\n然而兴趣来了，总想把源码继续看下去到底扫描了啥，咋扫描的，明明\nServiceLoader\u0026lt;Driver\u0026gt; loadedDrivers = ServiceLoader.load(Driver.class); 这里是 java.sql.Driver 接口，上哪找出来的实现类？\n我们就一层层的往下看吧。\nServiceLoader 主要做了两点\n设置ClassLoader为当前线程的。（破坏双亲委派，让它rt.jar包中的类可以通过AppClassLoader获取到外部的类，很多讲双亲委派机制的文章已经大书特书过了） 初始化了一个懒加载的迭代器 lookupIterator = new LazyIterator(service, loader);。正是这个迭代器中最终帮我们找到了各种driver注册进去。 LazyIterator 既然是迭代器，最重要的当然是hasNext()和next()方法。\n在next()方法中，已经拿到了nextName完整的\u0026quot;com.mysql.cj.jdbc.Driver\u0026quot;类名，说明还是hasNext()方法干了真正的扫描工作。\nhasNext()方法的主要工作也都放在了hasNextService()中\nprivate boolean hasNextService() { if (nextName != null) { return true; } if (configs == null) { try { //此处拼出了全名为 META-INF/services/java.","keywords":["java","ClassLoader","DriverManger"],"articleBody":"DriverManager 在初学JDBC时，总是记得开头就要来这么一句\nClass.forName(\"com.mysql.jdbc.Driver\"); 然而今天学习类加载机制时偶然知道不需要这句也同样可以正常运行，测试的确如此，看了一眼源码，看似原因很简单，因为无论写不写那段Class.forName，在触发加载DriverManager时，会运行\n/** * Load the initial JDBC drivers by checking the System property * jdbc.properties and then use the {@code ServiceLoader} mechanism */ static { loadInitialDrivers(); println(\"JDBC DriverManager initialized\"); } 都会扫描到这个Driver，注册到registeredDrivers中。\n如果只要回答这个问题，可能上面的答案就已经足够了。\n然而兴趣来了，总想把源码继续看下去到底扫描了啥，咋扫描的，明明\nServiceLoader\u003cDriver\u003e loadedDrivers = ServiceLoader.load(Driver.class); 这里是 java.sql.Driver 接口，上哪找出来的实现类？\n我们就一层层的往下看吧。\nServiceLoader 主要做了两点\n设置ClassLoader为当前线程的。（破坏双亲委派，让它rt.jar包中的类可以通过AppClassLoader获取到外部的类，很多讲双亲委派机制的文章已经大书特书过了） 初始化了一个懒加载的迭代器 lookupIterator = new LazyIterator(service, loader);。正是这个迭代器中最终帮我们找到了各种driver注册进去。 LazyIterator 既然是迭代器，最重要的当然是hasNext()和next()方法。\n在next()方法中，已经拿到了nextName完整的\"com.mysql.cj.jdbc.Driver\"类名，说明还是hasNext()方法干了真正的扫描工作。\nhasNext()方法的主要工作也都放在了hasNextService()中\nprivate boolean hasNextService() { if (nextName != null) { return true; } if (configs == null) { try { //此处拼出了全名为 META-INF/services/java.sql.Driver String fullName = PREFIX + service.getName(); if (loader == null) configs = ClassLoader.getSystemResources(fullName); else configs = loader.getResources(fullName); } catch (IOException x) { fail(service, \"Error locating configuration files\", x); } } while ((pending == null) || !pending.hasNext()) { if (!configs.hasMoreElements()) { return false; } pending = parse(service, configs.nextElement()); } nextName = pending.next(); return true; } 看起来不算复杂，我们拿着\"META-INF/services/java.sql.Driver\"去AppClassLoader找个configs。\n但是debug的时候并不直观，因为debug的时候看到config似乎包含了各层类加载器扫出来的几十个jar包，然而到configs.nextElement()时突然就直接拿到了jar:file:/C:/Users/dell/.m2/repository/mysql/mysql-connector-java/8.0.13/mysql-connector-java-8.0.13.jar!/META-INF/services/java.sql.Driver的完整路径。最后发现实在是源码作者太喜欢实现hasNext()和next()方法（hasMoreElements和nextElement）了，一层又一层的把人看晕了。\n我们先跟进这段代码 configs = loader.getResources(fullName);，看configs是如何拿到的吧。\nClassLoader public Enumeration\u003cURL\u003e getResources(String name) throws IOException { @SuppressWarnings(\"unchecked\") Enumeration\u003cURL\u003e[] tmp = (Enumeration\u003cURL\u003e[]) new Enumeration\u003c?\u003e[2]; if (parent != null) { tmp[0] = parent.getResources(name); } else { tmp[0] = getBootstrapResources(name); } //AppClassLoader和ExtClassLoader都是调用父类URLClassLoader的findResources方法 tmp[1] = findResources(name); return new CompoundEnumeration\u003c\u003e(tmp); } 遵循了双亲委派机制，先向上找parent，一直找到顶部的Bootstrap启动类加载器。再向下一直找到自身类加载器。 当然此处由于可以返回多层结果，因此返回的最终是CompoundEnumeration 组合的结果，而不是单条数据。\n后面我们会看到，不同的实现的Enumeration的hasMoreElements和nextElement真是花里胡哨。用Enumeration 这个看似最简单的只有两个方法的Interface作为返回类型，真是给作者玩出花来了。\n三层找的结果如下图。\ndebug看完三层扫描的结果，三层类加载器一共扫了一百多个jar包出来，貌似没毛病，但是明明我传了name进去找resource的啊，如果你要返回全部jar包，还要我传name干啥？要是遍历一百多个jar包的话，pending = parse(service, configs.nextElement());这要遍历一百多次去找java.sql.Driver的实现类？\n但是debug到configs.nextElement()时突然就直接拿到了jar:file:/C:/Users/dell/.m2/repository/mysql/mysql-connector-java/8.0.13/mysql-connector-java-8.0.13.jar!/META-INF/services/java.sql.Driver的完整路径。我们先看一眼这个jar包中的内容，\n的确这就是我们要找的jar包和配置文件，里面写明了我们要注册的Driver的实现类就是\"com.mysql.cj.jdbc.Driver\"。\n那这到底是什么时候遍历出来的呢？看来返回的这个configs中间大有玄机，我们继续跟进它的迭代的方法。\nURLClassLoader AppClassLoader和ExtClassLoader都是继承于URLClassLoader，且它们的findResources方法都是使用父类的。\n而URLClassLoader的这个方法的核心又是调用URLClassPath的findResources方法\npublic Enumeration\u003cURL\u003e findResources(final String name) throws IOException { final Enumeration\u003cURL\u003e e = ucp.findResources(name, true); //这里还是在URLClassPath返回的Enumeration上再包了一次，又实现了一遍Enumeration return new Enumeration\u003cURL\u003e() { private URL url = null; private boolean next() { ... //这里额外加上的checkURL方法，连name都没带，肯定也不是校验我们java.sql.Driver的，只是简单校验下路径合法或者存在。 url = ucp.checkURL(u); ... } ... } } URLClassPath public Enumeration\u003cURL\u003e findResources(final String var1, final boolean var2) { return new Enumeration\u003cURL\u003e() { private int index = 0; private int[] cache = URLClassPath.this.getLookupCache(var1); private URL url = null; private boolean next() { if (this.url != null) { return true; } else { do { URLClassPath.Loader var1x; //终于找到遍历jar包的地方，此处的var1x就是每个jar包 if ((var1x = URLClassPath.this.getNextLoader(this.cache, this.index++)) == null) { return false; } //findResource就是从这个jar包中找出我们要的META-INF/services/java.sql.Driver this.url = var1x.findResource(var1, var2); } while(this.url == null); return true; } } ... } 在一个jar包中，又有很多的配置文件路径，如何找到我们要的那个的呢？\n这里var1x就是JarLoader，用了其中的getResource方法。\nJarLoader Resource getResource(String var1, boolean var2) { //关键就在这个metaIndex中，mayContain方法去查了jar包中是否包含我们要找的目标文件 if (this.metaIndex != null \u0026\u0026 !this.metaIndex.mayContain(var1)) { return null; } else { try { this.ensureOpen(); } catch (IOException var5) { throw new InternalError(var5); } JarEntry var3 = this.jar.getJarEntry(var1); if (var3 != null) { return this.checkResource(var1, var2, var3); } else if (this.index == null) { return null; } else { HashSet var4 = new HashSet(); return this.getResource(var1, var2, var4); } } } 至此，我们已经找到了全部遍历的地方，URLClassLoader加载了全部jar包之后，在开始迭代时，URLClassPath 遍历每个jar包，JarLoader查找每个jar包中是否有目标文件META-INF/services/java.sql.Driver。\n","wordCount":"377","inLanguage":"en","datePublished":"2020-02-03T19:57:00Z","dateModified":"2020-02-03T19:57:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://heeexy.com/posts/drivermaneger/"},"publisher":{"@type":"Organization","name":"网站标题","logo":{"@type":"ImageObject","url":"https://heeexy.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://heeexy.com/ accesskey=h title="网站标题 (Alt + H)">网站标题</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">JDBC为什么不需要Class.forName()</h1><div class=post-meta><span title='2020-02-03 19:57:00 +0000 UTC'>February 3, 2020</span></div></header><div class=post-content><h3 id=drivermanager>DriverManager<a hidden class=anchor aria-hidden=true href=#drivermanager>#</a></h3><p>在初学JDBC时，总是记得开头就要来这么一句</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Class.<span style=color:#a6e22e>forName</span>(<span style=color:#e6db74>&#34;com.mysql.jdbc.Driver&#34;</span>);
</span></span></code></pre></div><p>然而今天学习类加载机制时偶然知道不需要这句也同样可以正常运行，测试的确如此，看了一眼源码，看似原因很简单，因为无论写不写那段<code>Class.forName</code>，在触发加载DriverManager时，会运行</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * Load the initial JDBC drivers by checking the System property
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * jdbc.properties and then use the {@code ServiceLoader} mechanism
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> {
</span></span><span style=display:flex><span>        loadInitialDrivers();
</span></span><span style=display:flex><span>        println(<span style=color:#e6db74>&#34;JDBC DriverManager initialized&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>都会扫描到这个Driver，注册到<code>registeredDrivers</code>中。</p><hr><p>如果只要回答这个问题，可能上面的答案就已经足够了。</p><p>然而兴趣来了，总想把源码继续看下去到底扫描了啥，咋扫描的，明明</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>ServiceLoader<span style=color:#f92672>&lt;</span>Driver<span style=color:#f92672>&gt;</span> loadedDrivers <span style=color:#f92672>=</span> ServiceLoader.<span style=color:#a6e22e>load</span>(Driver.<span style=color:#a6e22e>class</span>);
</span></span></code></pre></div><p>这里是 <code>java.sql.Driver</code> 接口，上哪找出来的实现类？</p><p>我们就一层层的往下看吧。</p><h3 id=serviceloader>ServiceLoader<a hidden class=anchor aria-hidden=true href=#serviceloader>#</a></h3><p>主要做了两点</p><ol><li>设置ClassLoader为当前线程的。（破坏双亲委派，让它rt.jar包中的类可以通过AppClassLoader获取到外部的类，很多讲双亲委派机制的文章已经大书特书过了）</li><li>初始化了一个懒加载的迭代器 <code>lookupIterator = new LazyIterator(service, loader);</code>。正是这个迭代器中最终帮我们找到了各种driver注册进去。</li></ol><h3 id=lazyiterator>LazyIterator<a hidden class=anchor aria-hidden=true href=#lazyiterator>#</a></h3><p>既然是迭代器，最重要的当然是hasNext()和next()方法。</p><p>在next()方法中，已经拿到了nextName完整的"com.mysql.cj.jdbc.Driver"类名，说明还是hasNext()方法干了真正的扫描工作。</p><p>hasNext()方法的主要工作也都放在了hasNextService()中</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>hasNextService</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (nextName <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (configs <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//此处拼出了全名为 META-INF/services/java.sql.Driver</span>
</span></span><span style=display:flex><span>                    String fullName <span style=color:#f92672>=</span> PREFIX <span style=color:#f92672>+</span> service.<span style=color:#a6e22e>getName</span>();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (loader <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                        configs <span style=color:#f92672>=</span> ClassLoader.<span style=color:#a6e22e>getSystemResources</span>(fullName);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                        configs <span style=color:#f92672>=</span> loader.<span style=color:#a6e22e>getResources</span>(fullName);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (IOException x) {
</span></span><span style=display:flex><span>                    fail(service, <span style=color:#e6db74>&#34;Error locating configuration files&#34;</span>, x);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> ((pending <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>pending.<span style=color:#a6e22e>hasNext</span>()) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>configs.<span style=color:#a6e22e>hasMoreElements</span>()) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                pending <span style=color:#f92672>=</span> parse(service, configs.<span style=color:#a6e22e>nextElement</span>());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            nextName <span style=color:#f92672>=</span> pending.<span style=color:#a6e22e>next</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p>看起来不算复杂，我们拿着"META-INF/services/java.sql.Driver"去AppClassLoader找个configs。</p><p>但是debug的时候并不直观，因为debug的时候看到config似乎包含了各层类加载器扫出来的几十个jar包，然而到configs.nextElement()时突然就直接拿到了<code>jar:file:/C:/Users/dell/.m2/repository/mysql/mysql-connector-java/8.0.13/mysql-connector-java-8.0.13.jar!/META-INF/services/java.sql.Driver</code>的完整路径。最后发现实在是源码作者太喜欢实现hasNext()和next()方法（<code>hasMoreElements</code>和<code>nextElement</code>）了，一层又一层的把人看晕了。</p><p>我们先跟进这段代码<code> configs = loader.getResources(fullName);</code>，看configs是如何拿到的吧。</p><h3 id=classloader>ClassLoader<a hidden class=anchor aria-hidden=true href=#classloader>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> Enumeration<span style=color:#f92672>&lt;</span>URL<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>getResources</span>(String name) <span style=color:#66d9ef>throws</span> IOException {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SuppressWarnings</span>(<span style=color:#e6db74>&#34;unchecked&#34;</span>)
</span></span><span style=display:flex><span>    Enumeration<span style=color:#f92672>&lt;</span>URL<span style=color:#f92672>&gt;[]</span> tmp <span style=color:#f92672>=</span> (Enumeration<span style=color:#f92672>&lt;</span>URL<span style=color:#f92672>&gt;[]</span>) <span style=color:#66d9ef>new</span> Enumeration<span style=color:#f92672>&lt;?&gt;[</span>2<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (parent <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        tmp<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> parent.<span style=color:#a6e22e>getResources</span>(name);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        tmp<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> getBootstrapResources(name);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//AppClassLoader和ExtClassLoader都是调用父类URLClassLoader的findResources方法</span>
</span></span><span style=display:flex><span>    tmp<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> findResources(name);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> CompoundEnumeration<span style=color:#f92672>&lt;&gt;</span>(tmp);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>遵循了双亲委派机制，先向上找parent，一直找到顶部的Bootstrap启动类加载器。再向下一直找到自身类加载器。 当然此处由于可以返回多层结果，因此返回的最终是<code>CompoundEnumeration</code> 组合的结果，而不是单条数据。</p><p>后面我们会看到，不同的实现的Enumeration的<code>hasMoreElements</code>和<code>nextElement</code>真是花里胡哨。用<code>Enumeration&lt;URL></code> 这个看似最简单的只有两个方法的<code>Interface</code>作为返回类型，真是给作者玩出花来了。</p><p>三层找的结果如下图。</p><p><img loading=lazy src=http://img.heeexy.com/BootstrapResouces.png alt></p><p><img loading=lazy src=http://img.heeexy.com/ExtResouces.png alt></p><p><img loading=lazy src=http://img.heeexy.com/AppResources.png alt></p><p>debug看完三层扫描的结果，三层类加载器一共扫了一百多个jar包出来，貌似没毛病，但是明明我传了name进去找resource的啊，如果你要返回全部jar包，还要我传name干啥？要是遍历一百多个jar包的话，<code>pending = parse(service, configs.nextElement());</code>这要遍历一百多次去找<code>java.sql.Driver</code>的实现类？</p><p>但是debug到<code>configs.nextElement()</code>时突然就直接拿到了<code>jar:file:/C:/Users/dell/.m2/repository/mysql/mysql-connector-java/8.0.13/mysql-connector-java-8.0.13.jar!/META-INF/services/java.sql.Driver</code>的完整路径。我们先看一眼这个jar包中的内容，</p><p><img loading=lazy src=http://img.heeexy.com/TargetDriverMetaInf.png alt></p><p>的确这就是我们要找的jar包和配置文件，里面写明了我们要注册的Driver的实现类就是"com.mysql.cj.jdbc.Driver"。</p><p>那这到底是什么时候遍历出来的呢？看来返回的这个<code>configs</code>中间大有玄机，我们继续跟进它的<strong>迭代</strong>的方法。</p><h3 id=urlclassloader>URLClassLoader<a hidden class=anchor aria-hidden=true href=#urlclassloader>#</a></h3><p>AppClassLoader和ExtClassLoader都是继承于URLClassLoader，且它们的<code>findResources</code>方法都是使用父类的。</p><p>而URLClassLoader的这个方法的核心又是调用URLClassPath的<code>findResources</code>方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>   <span style=color:#66d9ef>public</span> Enumeration<span style=color:#f92672>&lt;</span>URL<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>findResources</span>(<span style=color:#66d9ef>final</span> String name)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throws</span> IOException
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> Enumeration<span style=color:#f92672>&lt;</span>URL<span style=color:#f92672>&gt;</span> e <span style=color:#f92672>=</span> ucp.<span style=color:#a6e22e>findResources</span>(name, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>//这里还是在URLClassPath返回的Enumeration上再包了一次，又实现了一遍Enumeration</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Enumeration<span style=color:#f92672>&lt;</span>URL<span style=color:#f92672>&gt;</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>private</span> URL url <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>next</span>() {
</span></span><span style=display:flex><span>            ...
</span></span><span style=display:flex><span>                <span style=color:#75715e>//这里额外加上的checkURL方法，连name都没带，肯定也不是校验我们java.sql.Driver的，只是简单校验下路径合法或者存在。</span>
</span></span><span style=display:flex><span>                url <span style=color:#f92672>=</span> ucp.<span style=color:#a6e22e>checkURL</span>(u);
</span></span><span style=display:flex><span>            ...
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            ...
</span></span><span style=display:flex><span>         }
</span></span><span style=display:flex><span>   }
</span></span></code></pre></div><h3 id=urlclasspath>URLClassPath<a hidden class=anchor aria-hidden=true href=#urlclasspath>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> Enumeration<span style=color:#f92672>&lt;</span>URL<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>findResources</span>(<span style=color:#66d9ef>final</span> String var1, <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>boolean</span> var2) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Enumeration<span style=color:#f92672>&lt;</span>URL<span style=color:#f92672>&gt;</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> index <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> cache <span style=color:#f92672>=</span> URLClassPath.<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>getLookupCache</span>(var1);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> URL url <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>next</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>url</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>                    URLClassPath.<span style=color:#a6e22e>Loader</span> var1x;
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//终于找到遍历jar包的地方，此处的var1x就是每个jar包</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> ((var1x <span style=color:#f92672>=</span> URLClassPath.<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>getNextLoader</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>cache</span>, <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>index</span><span style=color:#f92672>++</span>)) <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//findResource就是从这个jar包中找出我们要的META-INF/services/java.sql.Driver</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>url</span> <span style=color:#f92672>=</span> var1x.<span style=color:#a6e22e>findResource</span>(var1, var2);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>while</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>url</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p><img loading=lazy src=http://img.heeexy.com/URLClassPath.png alt></p><p>在一个jar包中，又有很多的配置文件路径，如何找到我们要的那个的呢？</p><p>这里var1x就是JarLoader，用了其中的getResource方法。</p><h3 id=jarloader>JarLoader<a hidden class=anchor aria-hidden=true href=#jarloader>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Resource <span style=color:#a6e22e>getResource</span>(String var1, <span style=color:#66d9ef>boolean</span> var2) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//关键就在这个metaIndex中，mayContain方法去查了jar包中是否包含我们要找的目标文件</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>metaIndex</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>metaIndex</span>.<span style=color:#a6e22e>mayContain</span>(var1)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>ensureOpen</span>();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (IOException var5) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> InternalError(var5);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        JarEntry var3 <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>jar</span>.<span style=color:#a6e22e>getJarEntry</span>(var1);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (var3 <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>checkResource</span>(var1, var2, var3);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>index</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            HashSet var4 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashSet();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>getResource</span>(var1, var2, var4);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img loading=lazy src=http://img.heeexy.com/JarLoader.png alt></p><p>至此，我们已经找到了全部遍历的地方，URLClassLoader加载了全部jar包之后，在开始迭代时，URLClassPath 遍历每个jar包，JarLoader查找每个jar包中是否有目标文件META-INF/services/java.sql.Driver。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://heeexy.com/tags/java/>Java</a></li><li><a href=https://heeexy.com/tags/classloader/>ClassLoader</a></li><li><a href=https://heeexy.com/tags/drivermanger/>DriverManger</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://heeexy.com/>网站标题</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>