<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content='# DriverManager 在初学JDBC时，总是记得开头就要来这么一句 Class.forName("com.mysql.jdbc.Driver"); 然而今天学习类加载机制时偶然知道不需要这句也同样可以正常运行，测试的确如此，看了一眼源码，看似原因很简单，因为无论写不写那段Class.forName，在触发加载DriverManager时，会运行 /** * Load the initial JDBC drivers by checking the System property * jdbc.properties and then use the {@code ServiceLoader} mechanism */ static { loadInitialDrivers(); println("JDBC DriverManager initialized"); } 都会扫描到这个Driver，注册到registeredDrivers中。 如果只要回答这个问题，可能上面的答案就已经足够了。 然而兴趣来了，总想把源码继续看下去到底扫描了啥，咋扫描的，明明 ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class); 这里是 java.sql.Driver 接口，上哪找出来的实现类？ 我们就一层层的往下看吧。 # ServiceLoader 主要做了两点 设置ClassLoader为当前线程的。（破坏双亲委派，让它rt.jar包中的类可以通过AppClassLoader获取到外部的类，很多讲双亲委派机制的文章已经大书特书过了） 初始化了一个懒加载的迭代器 lookupIterator = new LazyIterator(service, loader);。正是这个迭代器中最终帮我们找到了各种driver注册进去。 # LazyIterator 既然是迭代器，最重要的当然是hasNext()和next()方法。 在next()方法中，已经拿到了nextName完整的"com.mysql.cj.jdbc.Driver"类名，说明还是hasNext()方法干了真正的扫描工作。 hasNext()方法的主要工作也都放在了hasNextService()中 private boolean hasNextService() { if (nextName != null) { return true; } if (configs == null) { try { //此处拼出了全名为 META-INF/services/java.'><title>JDBC为什么不需要Class.forName()</title>
<link rel=canonical href=https://heeexy.com/posts/drivermaneger/><link rel=stylesheet href=/scss/style.min.760e3dabc1e140d2e6abd27a8ca0aabb60e568829b29f67d2df12024136eff37.css><meta property='og:title' content="JDBC为什么不需要Class.forName()"><meta property='og:description' content='# DriverManager 在初学JDBC时，总是记得开头就要来这么一句 Class.forName("com.mysql.jdbc.Driver"); 然而今天学习类加载机制时偶然知道不需要这句也同样可以正常运行，测试的确如此，看了一眼源码，看似原因很简单，因为无论写不写那段Class.forName，在触发加载DriverManager时，会运行 /** * Load the initial JDBC drivers by checking the System property * jdbc.properties and then use the {@code ServiceLoader} mechanism */ static { loadInitialDrivers(); println("JDBC DriverManager initialized"); } 都会扫描到这个Driver，注册到registeredDrivers中。 如果只要回答这个问题，可能上面的答案就已经足够了。 然而兴趣来了，总想把源码继续看下去到底扫描了啥，咋扫描的，明明 ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class); 这里是 java.sql.Driver 接口，上哪找出来的实现类？ 我们就一层层的往下看吧。 # ServiceLoader 主要做了两点 设置ClassLoader为当前线程的。（破坏双亲委派，让它rt.jar包中的类可以通过AppClassLoader获取到外部的类，很多讲双亲委派机制的文章已经大书特书过了） 初始化了一个懒加载的迭代器 lookupIterator = new LazyIterator(service, loader);。正是这个迭代器中最终帮我们找到了各种driver注册进去。 # LazyIterator 既然是迭代器，最重要的当然是hasNext()和next()方法。 在next()方法中，已经拿到了nextName完整的"com.mysql.cj.jdbc.Driver"类名，说明还是hasNext()方法干了真正的扫描工作。 hasNext()方法的主要工作也都放在了hasNextService()中 private boolean hasNextService() { if (nextName != null) { return true; } if (configs == null) { try { //此处拼出了全名为 META-INF/services/java.'><meta property='og:url' content='https://heeexy.com/posts/drivermaneger/'><meta property='og:site_name' content='网站标题'><meta property='og:type' content='article'><meta property='article:section' content='Posts'><meta property='article:tag' content='java'><meta property='article:tag' content='ClassLoader'><meta property='article:tag' content='DriverManger'><meta property='article:published_time' content='2020-02-03T19:57:00+00:00'><meta property='article:modified_time' content='2020-02-03T19:57:00+00:00'><meta name=twitter:title content="JDBC为什么不需要Class.forName()"><meta name=twitter:description content='# DriverManager 在初学JDBC时，总是记得开头就要来这么一句 Class.forName("com.mysql.jdbc.Driver"); 然而今天学习类加载机制时偶然知道不需要这句也同样可以正常运行，测试的确如此，看了一眼源码，看似原因很简单，因为无论写不写那段Class.forName，在触发加载DriverManager时，会运行 /** * Load the initial JDBC drivers by checking the System property * jdbc.properties and then use the {@code ServiceLoader} mechanism */ static { loadInitialDrivers(); println("JDBC DriverManager initialized"); } 都会扫描到这个Driver，注册到registeredDrivers中。 如果只要回答这个问题，可能上面的答案就已经足够了。 然而兴趣来了，总想把源码继续看下去到底扫描了啥，咋扫描的，明明 ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class); 这里是 java.sql.Driver 接口，上哪找出来的实现类？ 我们就一层层的往下看吧。 # ServiceLoader 主要做了两点 设置ClassLoader为当前线程的。（破坏双亲委派，让它rt.jar包中的类可以通过AppClassLoader获取到外部的类，很多讲双亲委派机制的文章已经大书特书过了） 初始化了一个懒加载的迭代器 lookupIterator = new LazyIterator(service, loader);。正是这个迭代器中最终帮我们找到了各种driver注册进去。 # LazyIterator 既然是迭代器，最重要的当然是hasNext()和next()方法。 在next()方法中，已经拿到了nextName完整的"com.mysql.cj.jdbc.Driver"类名，说明还是hasNext()方法干了真正的扫描工作。 hasNext()方法的主要工作也都放在了hasNextService()中 private boolean hasNextService() { if (nextName != null) { return true; } if (configs == null) { try { //此处拼出了全名为 META-INF/services/java.'></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column compact"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_huda2458f72ce188392d75c5d51cd8e24e_373_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>网站标题</a></h1><h2 class=site-description></h2></div></header><ol class=menu id=main-menu><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/posts/drivermaneger/>JDBC为什么不需要Class.forName()</a></h2></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Feb 03, 2020</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>2 minute read</time></div></footer></div></header><section class=article-content><h3 id=drivermanager><a href=#drivermanager class=header-anchor>#</a>
DriverManager</h3><p>在初学JDBC时，总是记得开头就要来这么一句</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Class.<span style=color:#a6e22e>forName</span>(<span style=color:#e6db74>&#34;com.mysql.jdbc.Driver&#34;</span>);
</span></span></code></pre></div><p>然而今天学习类加载机制时偶然知道不需要这句也同样可以正常运行，测试的确如此，看了一眼源码，看似原因很简单，因为无论写不写那段<code>Class.forName</code>，在触发加载DriverManager时，会运行</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * Load the initial JDBC drivers by checking the System property
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * jdbc.properties and then use the {@code ServiceLoader} mechanism
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> {
</span></span><span style=display:flex><span>        loadInitialDrivers();
</span></span><span style=display:flex><span>        println(<span style=color:#e6db74>&#34;JDBC DriverManager initialized&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>都会扫描到这个Driver，注册到<code>registeredDrivers</code>中。</p><hr><p>如果只要回答这个问题，可能上面的答案就已经足够了。</p><p>然而兴趣来了，总想把源码继续看下去到底扫描了啥，咋扫描的，明明</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>ServiceLoader<span style=color:#f92672>&lt;</span>Driver<span style=color:#f92672>&gt;</span> loadedDrivers <span style=color:#f92672>=</span> ServiceLoader.<span style=color:#a6e22e>load</span>(Driver.<span style=color:#a6e22e>class</span>);
</span></span></code></pre></div><p>这里是 <code>java.sql.Driver</code> 接口，上哪找出来的实现类？</p><p>我们就一层层的往下看吧。</p><h3 id=serviceloader><a href=#serviceloader class=header-anchor>#</a>
ServiceLoader</h3><p>主要做了两点</p><ol><li>设置ClassLoader为当前线程的。（破坏双亲委派，让它rt.jar包中的类可以通过AppClassLoader获取到外部的类，很多讲双亲委派机制的文章已经大书特书过了）</li><li>初始化了一个懒加载的迭代器 <code>lookupIterator = new LazyIterator(service, loader);</code>。正是这个迭代器中最终帮我们找到了各种driver注册进去。</li></ol><h3 id=lazyiterator><a href=#lazyiterator class=header-anchor>#</a>
LazyIterator</h3><p>既然是迭代器，最重要的当然是hasNext()和next()方法。</p><p>在next()方法中，已经拿到了nextName完整的"com.mysql.cj.jdbc.Driver"类名，说明还是hasNext()方法干了真正的扫描工作。</p><p>hasNext()方法的主要工作也都放在了hasNextService()中</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>hasNextService</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (nextName <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (configs <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//此处拼出了全名为 META-INF/services/java.sql.Driver</span>
</span></span><span style=display:flex><span>                    String fullName <span style=color:#f92672>=</span> PREFIX <span style=color:#f92672>+</span> service.<span style=color:#a6e22e>getName</span>();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (loader <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                        configs <span style=color:#f92672>=</span> ClassLoader.<span style=color:#a6e22e>getSystemResources</span>(fullName);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                        configs <span style=color:#f92672>=</span> loader.<span style=color:#a6e22e>getResources</span>(fullName);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (IOException x) {
</span></span><span style=display:flex><span>                    fail(service, <span style=color:#e6db74>&#34;Error locating configuration files&#34;</span>, x);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> ((pending <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>pending.<span style=color:#a6e22e>hasNext</span>()) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>configs.<span style=color:#a6e22e>hasMoreElements</span>()) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                pending <span style=color:#f92672>=</span> parse(service, configs.<span style=color:#a6e22e>nextElement</span>());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            nextName <span style=color:#f92672>=</span> pending.<span style=color:#a6e22e>next</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p>看起来不算复杂，我们拿着"META-INF/services/java.sql.Driver"去AppClassLoader找个configs。</p><p>但是debug的时候并不直观，因为debug的时候看到config似乎包含了各层类加载器扫出来的几十个jar包，然而到configs.nextElement()时突然就直接拿到了<code>jar:file:/C:/Users/dell/.m2/repository/mysql/mysql-connector-java/8.0.13/mysql-connector-java-8.0.13.jar!/META-INF/services/java.sql.Driver</code>的完整路径。最后发现实在是源码作者太喜欢实现hasNext()和next()方法（<code>hasMoreElements</code>和<code>nextElement</code>）了，一层又一层的把人看晕了。</p><p>我们先跟进这段代码<code> configs = loader.getResources(fullName);</code>，看configs是如何拿到的吧。</p><h3 id=classloader><a href=#classloader class=header-anchor>#</a>
ClassLoader</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> Enumeration<span style=color:#f92672>&lt;</span>URL<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>getResources</span>(String name) <span style=color:#66d9ef>throws</span> IOException {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SuppressWarnings</span>(<span style=color:#e6db74>&#34;unchecked&#34;</span>)
</span></span><span style=display:flex><span>    Enumeration<span style=color:#f92672>&lt;</span>URL<span style=color:#f92672>&gt;[]</span> tmp <span style=color:#f92672>=</span> (Enumeration<span style=color:#f92672>&lt;</span>URL<span style=color:#f92672>&gt;[]</span>) <span style=color:#66d9ef>new</span> Enumeration<span style=color:#f92672>&lt;?&gt;[</span>2<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (parent <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        tmp<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> parent.<span style=color:#a6e22e>getResources</span>(name);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        tmp<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> getBootstrapResources(name);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//AppClassLoader和ExtClassLoader都是调用父类URLClassLoader的findResources方法</span>
</span></span><span style=display:flex><span>    tmp<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> findResources(name);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> CompoundEnumeration<span style=color:#f92672>&lt;&gt;</span>(tmp);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>遵循了双亲委派机制，先向上找parent，一直找到顶部的Bootstrap启动类加载器。再向下一直找到自身类加载器。 当然此处由于可以返回多层结果，因此返回的最终是<code>CompoundEnumeration</code> 组合的结果，而不是单条数据。</p><p>后面我们会看到，不同的实现的Enumeration的<code>hasMoreElements</code>和<code>nextElement</code>真是花里胡哨。用<code>Enumeration&lt;URL></code> 这个看似最简单的只有两个方法的<code>Interface</code>作为返回类型，真是给作者玩出花来了。</p><p>三层找的结果如下图。</p><p><img src=http://img.heeexy.com/BootstrapResouces.png loading=lazy></p><p><img src=http://img.heeexy.com/ExtResouces.png loading=lazy></p><p><img src=http://img.heeexy.com/AppResources.png loading=lazy></p><p>debug看完三层扫描的结果，三层类加载器一共扫了一百多个jar包出来，貌似没毛病，但是明明我传了name进去找resource的啊，如果你要返回全部jar包，还要我传name干啥？要是遍历一百多个jar包的话，<code>pending = parse(service, configs.nextElement());</code>这要遍历一百多次去找<code>java.sql.Driver</code>的实现类？</p><p>但是debug到<code>configs.nextElement()</code>时突然就直接拿到了<code>jar:file:/C:/Users/dell/.m2/repository/mysql/mysql-connector-java/8.0.13/mysql-connector-java-8.0.13.jar!/META-INF/services/java.sql.Driver</code>的完整路径。我们先看一眼这个jar包中的内容，</p><p><img src=http://img.heeexy.com/TargetDriverMetaInf.png loading=lazy></p><p>的确这就是我们要找的jar包和配置文件，里面写明了我们要注册的Driver的实现类就是"com.mysql.cj.jdbc.Driver"。</p><p>那这到底是什么时候遍历出来的呢？看来返回的这个<code>configs</code>中间大有玄机，我们继续跟进它的<strong>迭代</strong>的方法。</p><h3 id=urlclassloader><a href=#urlclassloader class=header-anchor>#</a>
URLClassLoader</h3><p>AppClassLoader和ExtClassLoader都是继承于URLClassLoader，且它们的<code>findResources</code>方法都是使用父类的。</p><p>而URLClassLoader的这个方法的核心又是调用URLClassPath的<code>findResources</code>方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>   <span style=color:#66d9ef>public</span> Enumeration<span style=color:#f92672>&lt;</span>URL<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>findResources</span>(<span style=color:#66d9ef>final</span> String name)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throws</span> IOException
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> Enumeration<span style=color:#f92672>&lt;</span>URL<span style=color:#f92672>&gt;</span> e <span style=color:#f92672>=</span> ucp.<span style=color:#a6e22e>findResources</span>(name, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>//这里还是在URLClassPath返回的Enumeration上再包了一次，又实现了一遍Enumeration</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Enumeration<span style=color:#f92672>&lt;</span>URL<span style=color:#f92672>&gt;</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>private</span> URL url <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>next</span>() {
</span></span><span style=display:flex><span>            ...
</span></span><span style=display:flex><span>                <span style=color:#75715e>//这里额外加上的checkURL方法，连name都没带，肯定也不是校验我们java.sql.Driver的，只是简单校验下路径合法或者存在。</span>
</span></span><span style=display:flex><span>                url <span style=color:#f92672>=</span> ucp.<span style=color:#a6e22e>checkURL</span>(u);
</span></span><span style=display:flex><span>            ...
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            ...
</span></span><span style=display:flex><span>         }
</span></span><span style=display:flex><span>   }
</span></span></code></pre></div><h3 id=urlclasspath><a href=#urlclasspath class=header-anchor>#</a>
URLClassPath</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> Enumeration<span style=color:#f92672>&lt;</span>URL<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>findResources</span>(<span style=color:#66d9ef>final</span> String var1, <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>boolean</span> var2) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Enumeration<span style=color:#f92672>&lt;</span>URL<span style=color:#f92672>&gt;</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> index <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> cache <span style=color:#f92672>=</span> URLClassPath.<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>getLookupCache</span>(var1);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> URL url <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>next</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>url</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>                    URLClassPath.<span style=color:#a6e22e>Loader</span> var1x;
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//终于找到遍历jar包的地方，此处的var1x就是每个jar包</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> ((var1x <span style=color:#f92672>=</span> URLClassPath.<span style=color:#a6e22e>this</span>.<span style=color:#a6e22e>getNextLoader</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>cache</span>, <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>index</span><span style=color:#f92672>++</span>)) <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//findResource就是从这个jar包中找出我们要的META-INF/services/java.sql.Driver</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>url</span> <span style=color:#f92672>=</span> var1x.<span style=color:#a6e22e>findResource</span>(var1, var2);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>while</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>url</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p><img src=http://img.heeexy.com/URLClassPath.png loading=lazy></p><p>在一个jar包中，又有很多的配置文件路径，如何找到我们要的那个的呢？</p><p>这里var1x就是JarLoader，用了其中的getResource方法。</p><h3 id=jarloader><a href=#jarloader class=header-anchor>#</a>
JarLoader</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Resource <span style=color:#a6e22e>getResource</span>(String var1, <span style=color:#66d9ef>boolean</span> var2) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//关键就在这个metaIndex中，mayContain方法去查了jar包中是否包含我们要找的目标文件</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>metaIndex</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>metaIndex</span>.<span style=color:#a6e22e>mayContain</span>(var1)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>ensureOpen</span>();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (IOException var5) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> InternalError(var5);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        JarEntry var3 <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>jar</span>.<span style=color:#a6e22e>getJarEntry</span>(var1);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (var3 <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>checkResource</span>(var1, var2, var3);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>index</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            HashSet var4 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashSet();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>getResource</span>(var1, var2, var4);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img src=http://img.heeexy.com/JarLoader.png loading=lazy></p><p>至此，我们已经找到了全部遍历的地方，URLClassLoader加载了全部jar包之后，在开始迭代时，URLClassPath 遍历每个jar包，JarLoader查找每个jar包中是否有目标文件META-INF/services/java.sql.Driver。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/java/>Java</a>
<a href=/tags/classloader/>ClassLoader</a>
<a href=/tags/drivermanger/>DriverManger</a></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/posts/%E4%BD%BF%E7%94%A8mybatis%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88dao%E5%B1%82%E4%B8%8D%E9%9C%80%E8%A6%81-repository/><div class=article-details><h2 class=article-title>使用MyBatis时为什么Dao层不需要@Repository</h2></div></a></article><article><a href=/posts/spring-note-18-ioc/><div class=article-details><h2 class=article-title>极简 Spring 框架 -- 浅析循环依赖</h2></div></a></article><article><a href=/posts/spring-note-16-beannamesfortypeincludingancestors/><div class=article-details><h2 class=article-title>Spring 源码笔记-2.8 根据类型寻找 bean--找出所有匹配类型的 beanName</h2></div></a></article><article><a href=/posts/spring-note-15-findautowirecandidates/><div class=article-details><h2 class=article-title>Spring 源码笔记-2.7 根据类型寻找 bean</h2></div></a></article><article><a href=/posts/spring-note-14-beanwrapper/><div class=article-details><h2 class=article-title>Spring 源码笔记-2.6 BeanWrapper 对比 MyBatis</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2024 网站标题</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.25.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>