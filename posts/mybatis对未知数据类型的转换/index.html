<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>MyBatis 对未知数据类型的转换(一)TypeHandler | 网站标题</title>
<meta name=keywords content="MyBatis,JSONObject"><meta name=description content="问题 前面说到，我们可以用 JSONObject 替代习惯使用的 JavaBean ，而之所以能用 JSONObject 主要就是因为它实现了 Map<String,Object> 。
实际使用我们就会发现，MyBatis 使用JSONObject 封装返回结果的时候很“智能”，数据库里字段是 varchar 类型，JSONObject 中返回值就是 String 类型，数据库字段是 int/float 类型，JSONObject 中返回值就是对应的数值类型。甚至通过 debug 发现数据库中保存了datetime 类型的数据，JSONObject 中保存的是 java.sql.timestamp 类型，而timestamp 类型继承了常见的 java.util.Date 。
为什么 MyBatis 可以用得这么爽呢？我们实现可完全没声明需要此字段的 javaType 呢。而且用得爽了，类型转换会不会导致程序性能大打折扣呢？
今天我们就从深入源码，探究一番 MyBatis 到底是怎样做到对未明确声明的字段处理返回类型的。
TypeHandler MyBatis 类型转换的核心就是这个接口，定义的方法可以看做就两种 setParameter 和 getResult ,很好理解，我们传参和接收 sql 结果时就调用这个。
public interface TypeHandler<T> { void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException; T getResult(ResultSet rs, String columnName) throws SQLException; T getResult(ResultSet rs, int columnIndex) throws SQLException; T getResult(CallableStatement cs, int columnIndex) throws SQLException; } 抽象类 BaseTypeHandler 部分实现了 TypeHandler ,主要完成了对空值的处理。 非空值的处理全部交给了子类完成。"><meta name=author content><link rel=canonical href=https://heeexy.com/posts/mybatis%E5%AF%B9%E6%9C%AA%E7%9F%A5%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://heeexy.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://heeexy.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://heeexy.com/favicon-32x32.png><link rel=apple-touch-icon href=https://heeexy.com/apple-touch-icon.png><link rel=mask-icon href=https://heeexy.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://heeexy.com/posts/mybatis%E5%AF%B9%E6%9C%AA%E7%9F%A5%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="MyBatis 对未知数据类型的转换(一)TypeHandler"><meta property="og:description" content="问题 前面说到，我们可以用 JSONObject 替代习惯使用的 JavaBean ，而之所以能用 JSONObject 主要就是因为它实现了 Map<String,Object> 。
实际使用我们就会发现，MyBatis 使用JSONObject 封装返回结果的时候很“智能”，数据库里字段是 varchar 类型，JSONObject 中返回值就是 String 类型，数据库字段是 int/float 类型，JSONObject 中返回值就是对应的数值类型。甚至通过 debug 发现数据库中保存了datetime 类型的数据，JSONObject 中保存的是 java.sql.timestamp 类型，而timestamp 类型继承了常见的 java.util.Date 。
为什么 MyBatis 可以用得这么爽呢？我们实现可完全没声明需要此字段的 javaType 呢。而且用得爽了，类型转换会不会导致程序性能大打折扣呢？
今天我们就从深入源码，探究一番 MyBatis 到底是怎样做到对未明确声明的字段处理返回类型的。
TypeHandler MyBatis 类型转换的核心就是这个接口，定义的方法可以看做就两种 setParameter 和 getResult ,很好理解，我们传参和接收 sql 结果时就调用这个。
public interface TypeHandler<T> { void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException; T getResult(ResultSet rs, String columnName) throws SQLException; T getResult(ResultSet rs, int columnIndex) throws SQLException; T getResult(CallableStatement cs, int columnIndex) throws SQLException; } 抽象类 BaseTypeHandler 部分实现了 TypeHandler ,主要完成了对空值的处理。 非空值的处理全部交给了子类完成。"><meta property="og:type" content="article"><meta property="og:url" content="https://heeexy.com/posts/mybatis%E5%AF%B9%E6%9C%AA%E7%9F%A5%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-01-02T22:35:52+00:00"><meta property="article:modified_time" content="2018-01-02T22:35:52+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="MyBatis 对未知数据类型的转换(一)TypeHandler"><meta name=twitter:description content="问题 前面说到，我们可以用 JSONObject 替代习惯使用的 JavaBean ，而之所以能用 JSONObject 主要就是因为它实现了 Map<String,Object> 。
实际使用我们就会发现，MyBatis 使用JSONObject 封装返回结果的时候很“智能”，数据库里字段是 varchar 类型，JSONObject 中返回值就是 String 类型，数据库字段是 int/float 类型，JSONObject 中返回值就是对应的数值类型。甚至通过 debug 发现数据库中保存了datetime 类型的数据，JSONObject 中保存的是 java.sql.timestamp 类型，而timestamp 类型继承了常见的 java.util.Date 。
为什么 MyBatis 可以用得这么爽呢？我们实现可完全没声明需要此字段的 javaType 呢。而且用得爽了，类型转换会不会导致程序性能大打折扣呢？
今天我们就从深入源码，探究一番 MyBatis 到底是怎样做到对未明确声明的字段处理返回类型的。
TypeHandler MyBatis 类型转换的核心就是这个接口，定义的方法可以看做就两种 setParameter 和 getResult ,很好理解，我们传参和接收 sql 结果时就调用这个。
public interface TypeHandler<T> { void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException; T getResult(ResultSet rs, String columnName) throws SQLException; T getResult(ResultSet rs, int columnIndex) throws SQLException; T getResult(CallableStatement cs, int columnIndex) throws SQLException; } 抽象类 BaseTypeHandler 部分实现了 TypeHandler ,主要完成了对空值的处理。 非空值的处理全部交给了子类完成。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://heeexy.com/posts/"},{"@type":"ListItem","position":2,"name":"MyBatis 对未知数据类型的转换(一)TypeHandler","item":"https://heeexy.com/posts/mybatis%E5%AF%B9%E6%9C%AA%E7%9F%A5%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"MyBatis 对未知数据类型的转换(一)TypeHandler","name":"MyBatis 对未知数据类型的转换(一)TypeHandler","description":"问题 前面说到，我们可以用 JSONObject 替代习惯使用的 JavaBean ，而之所以能用 JSONObject 主要就是因为它实现了 Map\u0026lt;String,Object\u0026gt; 。\n实际使用我们就会发现，MyBatis 使用JSONObject 封装返回结果的时候很“智能”，数据库里字段是 varchar 类型，JSONObject 中返回值就是 String 类型，数据库字段是 int/float 类型，JSONObject 中返回值就是对应的数值类型。甚至通过 debug 发现数据库中保存了datetime 类型的数据，JSONObject 中保存的是 java.sql.timestamp 类型，而timestamp 类型继承了常见的 java.util.Date 。\n为什么 MyBatis 可以用得这么爽呢？我们实现可完全没声明需要此字段的 javaType 呢。而且用得爽了，类型转换会不会导致程序性能大打折扣呢？\n今天我们就从深入源码，探究一番 MyBatis 到底是怎样做到对未明确声明的字段处理返回类型的。\nTypeHandler MyBatis 类型转换的核心就是这个接口，定义的方法可以看做就两种 setParameter 和 getResult ,很好理解，我们传参和接收 sql 结果时就调用这个。\npublic interface TypeHandler\u0026lt;T\u0026gt; { void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException; T getResult(ResultSet rs, String columnName) throws SQLException; T getResult(ResultSet rs, int columnIndex) throws SQLException; T getResult(CallableStatement cs, int columnIndex) throws SQLException; } 抽象类 BaseTypeHandler 部分实现了 TypeHandler ,主要完成了对空值的处理。 非空值的处理全部交给了子类完成。","keywords":["MyBatis","JSONObject"],"articleBody":"问题 前面说到，我们可以用 JSONObject 替代习惯使用的 JavaBean ，而之所以能用 JSONObject 主要就是因为它实现了 Map 。\n实际使用我们就会发现，MyBatis 使用JSONObject 封装返回结果的时候很“智能”，数据库里字段是 varchar 类型，JSONObject 中返回值就是 String 类型，数据库字段是 int/float 类型，JSONObject 中返回值就是对应的数值类型。甚至通过 debug 发现数据库中保存了datetime 类型的数据，JSONObject 中保存的是 java.sql.timestamp 类型，而timestamp 类型继承了常见的 java.util.Date 。\n为什么 MyBatis 可以用得这么爽呢？我们实现可完全没声明需要此字段的 javaType 呢。而且用得爽了，类型转换会不会导致程序性能大打折扣呢？\n今天我们就从深入源码，探究一番 MyBatis 到底是怎样做到对未明确声明的字段处理返回类型的。\nTypeHandler MyBatis 类型转换的核心就是这个接口，定义的方法可以看做就两种 setParameter 和 getResult ,很好理解，我们传参和接收 sql 结果时就调用这个。\npublic interface TypeHandler\u003cT\u003e { void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException; T getResult(ResultSet rs, String columnName) throws SQLException; T getResult(ResultSet rs, int columnIndex) throws SQLException; T getResult(CallableStatement cs, int columnIndex) throws SQLException; } 抽象类 BaseTypeHandler 部分实现了 TypeHandler ,主要完成了对空值的处理。 非空值的处理全部交给了子类完成。\nBaseTypeHandler 子类非常多，对应了数据库的各种数据类型，实现都很简单，比如SqlTimestampTypeHandler 处理 Timestamp 类型。\n@Override public void setNonNullParameter(PreparedStatement ps, int i, Timestamp parameter, JdbcType jdbcType) throws SQLException { ps.setTimestamp(i, parameter); } @Override public Timestamp getNullableResult(ResultSet rs, String columnName) throws SQLException { return rs.getTimestamp(columnName); } 都是直接调用了 PreparedStatement 和 ResultSet 处理相应类型字段的方法。\n很明显，一旦指明了我们需要 MyBatis 给我们返回的此字段类型，MyBatis 肯定就去找到对应的 TypeHandler 实现类去处理。而我们没有指定返回类型的是怎么处理的呢？或者说，对于 Object 类型是怎么处理的呢？\nObjectTypeHandler 我们先来看看这个类，看名字就会猜可能估计未知类型全靠它了吧。提前预告下，并不是哦，getNullableResult 还算经常使用，入参赋值就没见用了，毕竟入参的 JavaType 我们通过反射还是可以找到的。\n@Override public void setNonNullParameter(PreparedStatement ps, int i, Object parameter, JdbcType jdbcType) throws SQLException { ps.setObject(i, parameter); } @Override public Object getNullableResult(ResultSet rs, String columnName) throws SQLException { return rs.getObject(columnName); } 一看这实现，居然还是调用的 JDBC 底层的对应方法。事实上 com.mysql.jdbc 在处理Object 类型是也是通过大量的 if-else 或 switch-case 来找到本数据真正的类型的。入参绑定依据 parameterObj instanceof 各种类型，返回结果类型依据 field.getSQLType 的各种类型。\nUnknownTypeHandler 事实上，MyBatis 在很多我们没有指明参数类型的情况下，都是使用 UnknownTypeHandler 来解决类型转换的。UnknownTypeHandler 中的核心resolveTypeHandler 方法，就是查找对应数据的类型解析器（TypeHandler) ， 再用这个合适的 typeHandler 进行解析。\nresolveTypeHandler 方法的重载有3种，主要的两种就是一种处理入参的，一种处理返回结果的。\n入参类型解析 private TypeHandler\u003c? extends Object\u003e resolveTypeHandler(Object parameter, JdbcType jdbcType) { TypeHandler\u003c? extends Object\u003e handler; if (parameter == null) { handler = OBJECT_TYPE_HANDLER; } else { handler = typeHandlerRegistry.getTypeHandler(parameter.getClass(), jdbcType); // check if handler is null (issue #270) if (handler == null || handler instanceof UnknownTypeHandler) { handler = OBJECT_TYPE_HANDLER; } } return handler; } 在入参为 null 或者实在找不到解析器的情况下，就会返回我们上面讲的 ObjectTypeHandler 。\n而这里面关键的方法就是\ntypeHandlerRegistry.getTypeHandler(parameter.getClass(), jdbcType); typeHandlerRegistry 可以理解为全局共用的各种类型与解析器关系的注册表，后面的文章还会继续深入讲解，我们首先注意这个方法的入参，第一个参数拿到了参数的 class , 第二个参数拿到了 jdbcType 。这不就相当于javaType 和 jdbcType 都有了吗？那即使还没研究 typeHandlerRegistry 到底干了啥，但是条件给的这么充分了，注册表的任务也太轻松了吧！\n等等，我们的 DAO 层给入参是 JSONObject 类型,里面 username 字段是 String 类型，money 字段是 float 类型，这些都能通过 getClass() 获取到确实没毛病。但是 jdbcType 是哪来的呢？我们现在可是在处理 PreparedStatement 呢！\n通过 debug 我们发现，这里的 jdbcType 我们没有指明的情况下，确实都是 null 。说明 typeHandlerRegistry 里仅仅是通过 javaType 来寻找解析器的。所以 typeHandlerRegistry 还是有很多门道等着我们去探索哦。\n返回结果类型解析 对 ResultSet 的解析有两种方式，首先查看此结果字段–比如nickname–在 field 中的序号，如果没序号，则直接返回 ObjectTypeHandler 。如果有序号，则进入下面的方法。\nprivate TypeHandler\u003c?\u003e resolveTypeHandler(ResultSetMetaData rsmd, Integer columnIndex) throws SQLException { TypeHandler\u003c?\u003e handler = null; //通过下面两个方法获取到jdbcType和javaType JdbcType jdbcType = safeGetJdbcTypeForColumn(rsmd, columnIndex); Class\u003c?\u003e javaType = safeGetClassForColumn(rsmd, columnIndex); //后面的任务就还是交给了typeHandlerRegistry if (javaType != null \u0026\u0026 jdbcType != null) { handler = typeHandlerRegistry.getTypeHandler(javaType, jdbcType); } else if (javaType != null) { handler = typeHandlerRegistry.getTypeHandler(javaType); } else if (jdbcType != null) { handler = typeHandlerRegistry.getTypeHandler(jdbcType); } return handler; } 其中的关键方法还是从 rsmd 中获取 jdbcType 和 javaType ，然后再通过 typeHandlerRegistry 去查找对应的 handler 。\ndebug 发现几乎每次从 rsmd 中获取 jdbcType 和 javaType 都获取到了，看来玄机都在safeGetJdbcTypeForColumn 和 safeGetClassForColumn 中了。\n两个方法的关键代码分别如下\nreturn JdbcType.forCode(rsmd.getColumnType(columnIndex)); return Resources.classForName(rsmd.getColumnClassName(columnIndex)); JdbcType com.mysql.jdbc.ResultSetMetaData 实现了 java.sql.ResultSetMetaData 接口，此处我们调用了其中的\npublic int getColumnType(int column) throws SQLException { return getField(column).getSQLType(); } 序号的作用就体现出来了，根据序号找到此 field ,再找其 SQLType ，根据 SQLType 去JdbcType 类 (enum类型) 内查找对应的 jdbcType。\nJdbcType 类内维护了一个 map 类型静态变量 codeLookup ，类加载时为 codeLookup 添加了39个元素，key 值其实就是 SQLType ， int 类型，value 就是本 jdbcType 。\n因此根据 SQLType 在此处就直接能毫不费力地找出对应的 jdbcType。\nstatic { for (JdbcType type : JdbcType.values()) { codeLookup.put(type.TYPE_CODE, type); } } javaType 同样需要先找到 SQLType ，以及field 内的另外几个属性值，例如 isUnsigned 等一起进入 getClassNameForJavaType 方法找到对应类名。\nstatic String getClassNameForJavaType(int javaType, boolean isUnsigned, int mysqlTypeIfKnown, boolean isBinaryOrBlob, boolean isOpaqueBinary, boolean treatYearAsDate) { switch (javaType) { case Types.BIT: case Types.BOOLEAN: return \"java.lang.Boolean\"; case Types.TINYINT: if (isUnsigned) { return \"java.lang.Integer\"; } return \"java.lang.Integer\"; //......大量 case default: return \"java.lang.Object\"; 而这里的大量的 swtich-case 终于算是解除了我们一部分的疑惑了！底层终归还是通过 swtich-case 这种最原始的操作来把 jdbcType 映射到 java 类里去的！\n奇怪的现象 上面说到，如果没序号，则直接返回 ObjectTypeHandler。\n序号是getColumnType(int column) 用于找到到对应的 field 的关键属性。\n那么为什么有可能会没有序号呢？\n通过 debug 我们发现，明明 fields 内有 8 个元素，每个字段的原始名和别名都清清楚楚，到 columnIndexLookup 里居然只剩下 6 个？ 很显然，问题出在了\nString name = rsmd.getColumnName(i); 中间有几次取出了重复的 name 。为什么会有重复的 name 呢，我们进入getColumnName 一探究竟。\npublic String getColumnName(int column) throws SQLException { if (this.useOldAliasBehavior) { //如果设置了使用别名的属性，就获取此field的别名。 return getField(column).getName(); } //获取此field的name属性，而不是别名。 String name = getField(column).getNameNoAliases(); if (name != null \u0026\u0026 name.length() == 0) { //如果连原始字段名都找不到，就还是获取别名 return getField(column).getName(); } return name; } 实际debug发现，我们每次都是通过 getNameNoAliases 找到 name 的。再底层的代码就不需要贴了，看到这里我们就明白了。这里的 name 其实是每个字段的数据库内的字段名，而不是我们定义的别名，所以才会出现重复的情况，比如 user 表有 id 字段，address 表同样会有 id 字段。\n总结 今天我们分析完了类型转换器，发现对于未知的数据类型，有一部分是通过ObjectTypeHandler 解析，其底层的用了com.mysql.jdbc.ResultSetImpl.getObject 内的依据 Field.SQLType 的 swtich-case 。\n另一部分则是通过UnknownTypeHandler 去查找合适的解析器来解析。\n关于查找解析器的步骤，我们将进入下一层级TypeHandlerRegistry 来继续学习。\n","wordCount":"610","inLanguage":"en","datePublished":"2018-01-02T22:35:52Z","dateModified":"2018-01-02T22:35:52Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://heeexy.com/posts/mybatis%E5%AF%B9%E6%9C%AA%E7%9F%A5%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/"},"publisher":{"@type":"Organization","name":"网站标题","logo":{"@type":"ImageObject","url":"https://heeexy.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://heeexy.com/ accesskey=h title="网站标题 (Alt + H)">网站标题</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">MyBatis 对未知数据类型的转换(一)TypeHandler</h1><div class=post-meta><span title='2018-01-02 22:35:52 +0000 UTC'>January 2, 2018</span></div></header><div class=post-content><h1 id=问题>问题<a hidden class=anchor aria-hidden=true href=#问题>#</a></h1><p>前面说到，我们可以用 JSONObject 替代习惯使用的 JavaBean ，而之所以能用 JSONObject 主要就是因为它实现了 <code>Map&lt;String,Object></code> 。</p><p>实际使用我们就会发现，MyBatis 使用JSONObject 封装返回结果的时候很“智能”，数据库里字段是 varchar 类型，JSONObject 中返回值就是 String 类型，数据库字段是 int/float 类型，JSONObject 中返回值就是对应的数值类型。甚至通过 debug 发现数据库中保存了datetime 类型的数据，JSONObject 中保存的是 <code>java.sql.timestamp</code> 类型，而<code>timestamp</code> 类型继承了常见的 <code>java.util.Date</code> 。</p><p><img loading=lazy src=http://img.heeexy.com/DataType.png alt></p><p>为什么 MyBatis 可以用得这么爽呢？我们实现可完全没声明需要此字段的 javaType 呢。而且用得爽了，类型转换会不会导致程序性能大打折扣呢？</p><p>今天我们就从深入源码，探究一番 MyBatis 到底是怎样做到对未明确声明的字段处理返回类型的。</p><h1 id=typehandler>TypeHandler<a hidden class=anchor aria-hidden=true href=#typehandler>#</a></h1><p>MyBatis 类型转换的核心就是这个接口，定义的方法可以看做就两种 setParameter 和 getResult ,很好理解，我们传参和接收 sql 结果时就调用这个。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>TypeHandler</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setParameter</span>(PreparedStatement ps, <span style=color:#66d9ef>int</span> i, T parameter, JdbcType jdbcType) <span style=color:#66d9ef>throws</span> SQLException;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  T <span style=color:#a6e22e>getResult</span>(ResultSet rs, String columnName) <span style=color:#66d9ef>throws</span> SQLException;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  T <span style=color:#a6e22e>getResult</span>(ResultSet rs, <span style=color:#66d9ef>int</span> columnIndex) <span style=color:#66d9ef>throws</span> SQLException;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  T <span style=color:#a6e22e>getResult</span>(CallableStatement cs, <span style=color:#66d9ef>int</span> columnIndex) <span style=color:#66d9ef>throws</span> SQLException;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>抽象类 BaseTypeHandler 部分实现了 TypeHandler ,主要完成了对空值的处理。 非空值的处理全部交给了子类完成。</p><p>BaseTypeHandler 子类非常多，对应了数据库的各种数据类型，实现都很简单，比如<code>SqlTimestampTypeHandler</code> 处理 Timestamp 类型。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setNonNullParameter</span>(PreparedStatement ps, <span style=color:#66d9ef>int</span> i, Timestamp parameter, JdbcType jdbcType)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throws</span> SQLException {
</span></span><span style=display:flex><span>  ps.<span style=color:#a6e22e>setTimestamp</span>(i, parameter);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> Timestamp <span style=color:#a6e22e>getNullableResult</span>(ResultSet rs, String columnName)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throws</span> SQLException {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> rs.<span style=color:#a6e22e>getTimestamp</span>(columnName);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>都是直接调用了 PreparedStatement 和 ResultSet 处理相应类型字段的方法。</p><p>很明显，一旦指明了我们需要 MyBatis 给我们返回的此字段类型，MyBatis 肯定就去找到对应的 TypeHandler 实现类去处理。而我们没有指定返回类型的是怎么处理的呢？或者说，对于 Object 类型是怎么处理的呢？</p><h1 id=objecttypehandler>ObjectTypeHandler<a hidden class=anchor aria-hidden=true href=#objecttypehandler>#</a></h1><p>我们先来看看这个类，看名字就会猜可能估计未知类型全靠它了吧。提前预告下，并不是哦，getNullableResult 还算经常使用，入参赋值就没见用了，毕竟入参的 JavaType 我们通过反射还是可以找到的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setNonNullParameter</span>(PreparedStatement ps, <span style=color:#66d9ef>int</span> i, Object parameter, JdbcType jdbcType)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throws</span> SQLException {
</span></span><span style=display:flex><span>  ps.<span style=color:#a6e22e>setObject</span>(i, parameter);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> Object <span style=color:#a6e22e>getNullableResult</span>(ResultSet rs, String columnName)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throws</span> SQLException {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> rs.<span style=color:#a6e22e>getObject</span>(columnName);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>一看这实现，居然还是调用的 JDBC 底层的对应方法。事实上 <code>com.mysql.jdbc</code> 在处理<code>Object</code> 类型是也是通过大量的 if-else 或 switch-case 来找到本数据真正的类型的。入参绑定依据 parameterObj instanceof 各种类型，返回结果类型依据 field.getSQLType 的各种类型。</p><h1 id=unknowntypehandler>UnknownTypeHandler<a hidden class=anchor aria-hidden=true href=#unknowntypehandler>#</a></h1><p>事实上，MyBatis 在很多我们没有指明参数类型的情况下，都是使用 UnknownTypeHandler 来解决类型转换的。UnknownTypeHandler 中的核心<code>resolveTypeHandler</code> 方法，就是查找对应数据的类型解析器（TypeHandler) ， 再用这个合适的 typeHandler 进行解析。</p><p><code>resolveTypeHandler</code> 方法的重载有3种，主要的两种就是一种处理入参的，一种处理返回结果的。</p><h3 id=入参类型解析>入参类型解析<a hidden class=anchor aria-hidden=true href=#入参类型解析>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> TypeHandler<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> Object<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>resolveTypeHandler</span>(Object parameter, JdbcType jdbcType) {
</span></span><span style=display:flex><span>  TypeHandler<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> Object<span style=color:#f92672>&gt;</span> handler;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (parameter <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    handler <span style=color:#f92672>=</span> OBJECT_TYPE_HANDLER;
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    handler <span style=color:#f92672>=</span> typeHandlerRegistry.<span style=color:#a6e22e>getTypeHandler</span>(parameter.<span style=color:#a6e22e>getClass</span>(), jdbcType);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// check if handler is null (issue #270)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (handler <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> handler <span style=color:#66d9ef>instanceof</span> UnknownTypeHandler) {
</span></span><span style=display:flex><span>      handler <span style=color:#f92672>=</span> OBJECT_TYPE_HANDLER;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> handler;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在入参为 null 或者实在找不到解析器的情况下，就会返回我们上面讲的 ObjectTypeHandler 。</p><p>而这里面关键的方法就是</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>typeHandlerRegistry.<span style=color:#a6e22e>getTypeHandler</span>(parameter.<span style=color:#a6e22e>getClass</span>(), jdbcType);
</span></span></code></pre></div><p>typeHandlerRegistry 可以理解为全局共用的各种类型与解析器关系的注册表，后面的文章还会继续深入讲解，我们首先注意这个方法的入参，第一个参数拿到了参数的 class , 第二个参数拿到了 jdbcType 。这不就相当于javaType 和 jdbcType 都有了吗？那即使还没研究 typeHandlerRegistry 到底干了啥，但是条件给的这么充分了，注册表的任务也太轻松了吧！</p><p>等等，我们的 DAO 层给入参是 JSONObject 类型,里面 username 字段是 String 类型，money 字段是 float 类型，这些都能通过 getClass() 获取到确实没毛病。但是 jdbcType 是哪来的呢？我们现在可是在处理 PreparedStatement 呢！</p><p>通过 debug 我们发现，这里的 jdbcType 我们没有指明的情况下，确实都是 null 。说明 typeHandlerRegistry 里仅仅是通过 javaType 来寻找解析器的。所以 typeHandlerRegistry 还是有很多门道等着我们去探索哦。</p><h3 id=返回结果类型解析>返回结果类型解析<a hidden class=anchor aria-hidden=true href=#返回结果类型解析>#</a></h3><p>对 ResultSet 的解析有两种方式，首先查看此结果字段&ndash;比如nickname&ndash;在 field 中的序号，如果没序号，则直接返回 ObjectTypeHandler 。如果有序号，则进入下面的方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> TypeHandler<span style=color:#f92672>&lt;?&gt;</span> resolveTypeHandler(ResultSetMetaData rsmd, Integer columnIndex) <span style=color:#66d9ef>throws</span> SQLException {
</span></span><span style=display:flex><span>  TypeHandler<span style=color:#f92672>&lt;?&gt;</span> handler <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>  <span style=color:#75715e>//通过下面两个方法获取到jdbcType和javaType</span>
</span></span><span style=display:flex><span>  JdbcType jdbcType <span style=color:#f92672>=</span> safeGetJdbcTypeForColumn(rsmd, columnIndex);
</span></span><span style=display:flex><span>  Class<span style=color:#f92672>&lt;?&gt;</span> javaType <span style=color:#f92672>=</span> safeGetClassForColumn(rsmd, columnIndex);
</span></span><span style=display:flex><span>  <span style=color:#75715e>//后面的任务就还是交给了typeHandlerRegistry</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (javaType <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> jdbcType <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    handler <span style=color:#f92672>=</span> typeHandlerRegistry.<span style=color:#a6e22e>getTypeHandler</span>(javaType, jdbcType);
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (javaType <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    handler <span style=color:#f92672>=</span> typeHandlerRegistry.<span style=color:#a6e22e>getTypeHandler</span>(javaType);
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (jdbcType <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    handler <span style=color:#f92672>=</span> typeHandlerRegistry.<span style=color:#a6e22e>getTypeHandler</span>(jdbcType);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> handler;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>其中的关键方法还是从 rsmd 中获取 jdbcType 和 javaType ，然后再通过 typeHandlerRegistry 去查找对应的 handler 。</p><p>debug 发现几乎每次从 rsmd 中获取 jdbcType 和 javaType 都获取到了，看来玄机都在<code>safeGetJdbcTypeForColumn</code> 和 <code>safeGetClassForColumn</code> 中了。</p><p>两个方法的关键代码分别如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>return</span> JdbcType.<span style=color:#a6e22e>forCode</span>(rsmd.<span style=color:#a6e22e>getColumnType</span>(columnIndex));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> Resources.<span style=color:#a6e22e>classForName</span>(rsmd.<span style=color:#a6e22e>getColumnClassName</span>(columnIndex));
</span></span></code></pre></div><h4 id=jdbctype>JdbcType<a hidden class=anchor aria-hidden=true href=#jdbctype>#</a></h4><p><code>com.mysql.jdbc.ResultSetMetaData</code> 实现了 <code>java.sql.ResultSetMetaData </code>接口，此处我们调用了其中的</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getColumnType</span>(<span style=color:#66d9ef>int</span> column) <span style=color:#66d9ef>throws</span> SQLException {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> getField(column).<span style=color:#a6e22e>getSQLType</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>序号的作用就体现出来了，根据序号找到此 field ,再找其 SQLType ，根据 SQLType 去JdbcType 类 (enum类型) 内查找对应的 jdbcType。</p><p>JdbcType 类内维护了一个 map 类型静态变量 codeLookup ，类加载时为 codeLookup 添加了39个元素，key 值其实就是 SQLType ， int 类型，value 就是本 jdbcType 。</p><p>因此根据 SQLType 在此处就直接能毫不费力地找出对应的 jdbcType。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>static</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (JdbcType type : JdbcType.<span style=color:#a6e22e>values</span>()) {
</span></span><span style=display:flex><span>    codeLookup.<span style=color:#a6e22e>put</span>(type.<span style=color:#a6e22e>TYPE_CODE</span>, type);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=javatype>javaType<a hidden class=anchor aria-hidden=true href=#javatype>#</a></h4><p>同样需要先找到 SQLType ，以及field 内的另外几个属性值，例如 isUnsigned 等一起进入 getClassNameForJavaType 方法找到对应类名。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>static</span> String <span style=color:#a6e22e>getClassNameForJavaType</span>(<span style=color:#66d9ef>int</span> javaType, <span style=color:#66d9ef>boolean</span> isUnsigned, <span style=color:#66d9ef>int</span> mysqlTypeIfKnown, <span style=color:#66d9ef>boolean</span> isBinaryOrBlob, <span style=color:#66d9ef>boolean</span> isOpaqueBinary,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>boolean</span> treatYearAsDate) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> (javaType) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> Types.<span style=color:#a6e22e>BIT</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> Types.<span style=color:#a6e22e>BOOLEAN</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;java.lang.Boolean&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> Types.<span style=color:#a6e22e>TINYINT</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (isUnsigned) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;java.lang.Integer&#34;</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;java.lang.Integer&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>//......大量 case</span>
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;java.lang.Object&#34;</span>;
</span></span></code></pre></div><p>而这里的大量的 swtich-case 终于算是解除了我们一部分的疑惑了！底层终归还是通过 swtich-case 这种最原始的操作来把 jdbcType 映射到 java 类里去的！</p><h4 id=奇怪的现象>奇怪的现象<a hidden class=anchor aria-hidden=true href=#奇怪的现象>#</a></h4><p>上面说到，如果没序号，则直接返回 ObjectTypeHandler。</p><p>序号是<code>getColumnType(int column)</code> 用于找到到对应的 field 的关键属性。</p><p>那么为什么有可能会没有序号呢？</p><p><img loading=lazy src=http://img.heeexy.com/debug-fields.png alt></p><p>通过 debug 我们发现，明明 fields 内有 8 个元素，每个字段的原始名和别名都清清楚楚，到 columnIndexLookup 里居然只剩下 6 个？ 很显然，问题出在了</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>String name <span style=color:#f92672>=</span> rsmd.<span style=color:#a6e22e>getColumnName</span>(i);
</span></span></code></pre></div><p>中间有几次取出了重复的 name 。为什么会有重复的 name 呢，我们进入<code>getColumnName</code> 一探究竟。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>   <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getColumnName</span>(<span style=color:#66d9ef>int</span> column) <span style=color:#66d9ef>throws</span> SQLException {
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>useOldAliasBehavior</span>) {
</span></span><span style=display:flex><span>         <span style=color:#75715e>//如果设置了使用别名的属性，就获取此field的别名。</span>
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>return</span> getField(column).<span style=color:#a6e22e>getName</span>();
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>     <span style=color:#75715e>//获取此field的name属性，而不是别名。</span>
</span></span><span style=display:flex><span>       String name <span style=color:#f92672>=</span> getField(column).<span style=color:#a6e22e>getNameNoAliases</span>();
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>if</span> (name <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> name.<span style=color:#a6e22e>length</span>() <span style=color:#f92672>==</span> 0) {
</span></span><span style=display:flex><span>         <span style=color:#75715e>//如果连原始字段名都找不到，就还是获取别名</span>
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>return</span> getField(column).<span style=color:#a6e22e>getName</span>();
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>return</span> name;
</span></span><span style=display:flex><span>   }
</span></span></code></pre></div><p>实际debug发现，我们每次都是通过 getNameNoAliases 找到 name 的。再底层的代码就不需要贴了，看到这里我们就明白了。这里的 name 其实是每个字段的数据库内的字段名，而不是我们定义的别名，所以才会出现重复的情况，比如 user 表有 id 字段，address 表同样会有 id 字段。</p><h1 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h1><p>今天我们分析完了类型转换器，发现对于未知的数据类型，有一部分是通过ObjectTypeHandler 解析，其底层的用了<code>com.mysql.jdbc.ResultSetImpl.getObject</code> 内的依据 Field.SQLType 的 swtich-case 。</p><p>另一部分则是通过<code>UnknownTypeHandler</code> 去查找合适的解析器来解析。</p><p>关于查找解析器的步骤，我们将进入下一层级<code>TypeHandlerRegistry</code> 来继续学习。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://heeexy.com/tags/mybatis/>MyBatis</a></li><li><a href=https://heeexy.com/tags/jsonobject/>JSONObject</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://heeexy.com/>网站标题</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>