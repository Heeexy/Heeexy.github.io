<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Spring 源码笔记-2.7 根据类型寻找 bean | 网站标题</title>
<meta name=keywords content="java,spring,笔记"><meta name=description content='前言 Spring 装配 bean 有两种类型：autowireByName 和 autowireByType 。
autowireByName 通过名称查找很直接，就是我们一直在学的 getBean() 。
而 autowireByType 根据类型查找相比起来就要复杂一些了，《 Spring 源码深度解析 》 中有介绍过的部分我就不再重复贴了，但是书中遗漏了一处重要的部分&mdash;&mdash; findAutowireCandidates 查找所有合适的 bean，还有一处新版本 Spring 中升级的部分&mdash;&mdash;如果只需要一个但是找出多个 bean 该怎么处理，今天我们先来学习第一部分。
正文 本函数要做什么 @RestController @RequestMapping("/article") public class ArticleController { @Autowired private ArticleService articleService; } 在初始化 ArticleController 的过程中，我们要为其装配 ArticleService 。
忽略掉外面代码一层一层的包裹之后，我们走到 DefaultListableBeanFactory.findAutowireCandidates 这个函数中，要寻找合适的候选 bean 。由于可能会找到多个，因此返回结果是候选 bean 的名称和其对应实例构成的 Map 。
源码解析 //三个参数的含义依次是 // 正在解析的 beanName, 本例中即 "articleController" // 需要装配的 bean 类型, 本例中即 ArticleService.class // 对当前依赖关系的解析类，记录了 ArticleController 和 ArticleService 的依赖关系 protected Map<String, Object> findAutowireCandidates(String beanName, Class<?'><meta name=author content><link rel=canonical href=https://heeexy.com/posts/spring-note-15-findautowirecandidates/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://heeexy.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://heeexy.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://heeexy.com/favicon-32x32.png><link rel=apple-touch-icon href=https://heeexy.com/apple-touch-icon.png><link rel=mask-icon href=https://heeexy.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://heeexy.com/posts/spring-note-15-findautowirecandidates/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Spring 源码笔记-2.7 根据类型寻找 bean"><meta property="og:description" content='前言 Spring 装配 bean 有两种类型：autowireByName 和 autowireByType 。
autowireByName 通过名称查找很直接，就是我们一直在学的 getBean() 。
而 autowireByType 根据类型查找相比起来就要复杂一些了，《 Spring 源码深度解析 》 中有介绍过的部分我就不再重复贴了，但是书中遗漏了一处重要的部分&mdash;&mdash; findAutowireCandidates 查找所有合适的 bean，还有一处新版本 Spring 中升级的部分&mdash;&mdash;如果只需要一个但是找出多个 bean 该怎么处理，今天我们先来学习第一部分。
正文 本函数要做什么 @RestController @RequestMapping("/article") public class ArticleController { @Autowired private ArticleService articleService; } 在初始化 ArticleController 的过程中，我们要为其装配 ArticleService 。
忽略掉外面代码一层一层的包裹之后，我们走到 DefaultListableBeanFactory.findAutowireCandidates 这个函数中，要寻找合适的候选 bean 。由于可能会找到多个，因此返回结果是候选 bean 的名称和其对应实例构成的 Map 。
源码解析 //三个参数的含义依次是 // 正在解析的 beanName, 本例中即 "articleController" // 需要装配的 bean 类型, 本例中即 ArticleService.class // 对当前依赖关系的解析类，记录了 ArticleController 和 ArticleService 的依赖关系 protected Map<String, Object> findAutowireCandidates(String beanName, Class<?'><meta property="og:type" content="article"><meta property="og:url" content="https://heeexy.com/posts/spring-note-15-findautowirecandidates/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-01-23T09:00:22+00:00"><meta property="article:modified_time" content="2018-01-23T09:00:22+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Spring 源码笔记-2.7 根据类型寻找 bean"><meta name=twitter:description content='前言 Spring 装配 bean 有两种类型：autowireByName 和 autowireByType 。
autowireByName 通过名称查找很直接，就是我们一直在学的 getBean() 。
而 autowireByType 根据类型查找相比起来就要复杂一些了，《 Spring 源码深度解析 》 中有介绍过的部分我就不再重复贴了，但是书中遗漏了一处重要的部分&mdash;&mdash; findAutowireCandidates 查找所有合适的 bean，还有一处新版本 Spring 中升级的部分&mdash;&mdash;如果只需要一个但是找出多个 bean 该怎么处理，今天我们先来学习第一部分。
正文 本函数要做什么 @RestController @RequestMapping("/article") public class ArticleController { @Autowired private ArticleService articleService; } 在初始化 ArticleController 的过程中，我们要为其装配 ArticleService 。
忽略掉外面代码一层一层的包裹之后，我们走到 DefaultListableBeanFactory.findAutowireCandidates 这个函数中，要寻找合适的候选 bean 。由于可能会找到多个，因此返回结果是候选 bean 的名称和其对应实例构成的 Map 。
源码解析 //三个参数的含义依次是 // 正在解析的 beanName, 本例中即 "articleController" // 需要装配的 bean 类型, 本例中即 ArticleService.class // 对当前依赖关系的解析类，记录了 ArticleController 和 ArticleService 的依赖关系 protected Map<String, Object> findAutowireCandidates(String beanName, Class<?'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://heeexy.com/posts/"},{"@type":"ListItem","position":2,"name":"Spring 源码笔记-2.7 根据类型寻找 bean","item":"https://heeexy.com/posts/spring-note-15-findautowirecandidates/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Spring 源码笔记-2.7 根据类型寻找 bean","name":"Spring 源码笔记-2.7 根据类型寻找 bean","description":"前言 Spring 装配 bean 有两种类型：autowireByName 和 autowireByType 。\nautowireByName 通过名称查找很直接，就是我们一直在学的 getBean() 。\n而 autowireByType 根据类型查找相比起来就要复杂一些了，《 Spring 源码深度解析 》 中有介绍过的部分我就不再重复贴了，但是书中遗漏了一处重要的部分\u0026mdash;\u0026mdash; findAutowireCandidates 查找所有合适的 bean，还有一处新版本 Spring 中升级的部分\u0026mdash;\u0026mdash;如果只需要一个但是找出多个 bean 该怎么处理，今天我们先来学习第一部分。\n正文 本函数要做什么 @RestController @RequestMapping(\u0026#34;/article\u0026#34;) public class ArticleController { @Autowired private ArticleService articleService; } 在初始化 ArticleController 的过程中，我们要为其装配 ArticleService 。\n忽略掉外面代码一层一层的包裹之后，我们走到 DefaultListableBeanFactory.findAutowireCandidates 这个函数中，要寻找合适的候选 bean 。由于可能会找到多个，因此返回结果是候选 bean 的名称和其对应实例构成的 Map 。\n源码解析 //三个参数的含义依次是 // 正在解析的 beanName, 本例中即 \u0026#34;articleController\u0026#34; // 需要装配的 bean 类型, 本例中即 ArticleService.class // 对当前依赖关系的解析类，记录了 ArticleController 和 ArticleService 的依赖关系 protected Map\u0026lt;String, Object\u0026gt; findAutowireCandidates(String beanName, Class\u0026lt;?","keywords":["java","spring","笔记"],"articleBody":"前言 Spring 装配 bean 有两种类型：autowireByName 和 autowireByType 。\nautowireByName 通过名称查找很直接，就是我们一直在学的 getBean() 。\n而 autowireByType 根据类型查找相比起来就要复杂一些了，《 Spring 源码深度解析 》 中有介绍过的部分我就不再重复贴了，但是书中遗漏了一处重要的部分—— findAutowireCandidates 查找所有合适的 bean，还有一处新版本 Spring 中升级的部分——如果只需要一个但是找出多个 bean 该怎么处理，今天我们先来学习第一部分。\n正文 本函数要做什么 @RestController @RequestMapping(\"/article\") public class ArticleController { @Autowired private ArticleService articleService; } 在初始化 ArticleController 的过程中，我们要为其装配 ArticleService 。\n忽略掉外面代码一层一层的包裹之后，我们走到 DefaultListableBeanFactory.findAutowireCandidates 这个函数中，要寻找合适的候选 bean 。由于可能会找到多个，因此返回结果是候选 bean 的名称和其对应实例构成的 Map 。\n源码解析 //三个参数的含义依次是 // 正在解析的 beanName, 本例中即 \"articleController\" // 需要装配的 bean 类型, 本例中即 ArticleService.class // 对当前依赖关系的解析类，记录了 ArticleController 和 ArticleService 的依赖关系 protected Map\u003cString, Object\u003e findAutowireCandidates(String beanName, Class\u003c?\u003e requiredType, DependencyDescriptor descriptor) { //第一步就是查找出所有符合类型的 beanName 。 //似乎第一句就干完全部逻辑了？？？稍后我们再详细分析这个方法。 String[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors( this, requiredType, true, descriptor.isEager()); Map\u003cString, Object\u003e result = new LinkedHashMap\u003cString, Object\u003e(candidateNames.length); /** *\tresolvableDependencies 记录了 依赖类型--具体装配值 的映射 * 遍历 resolvableDependencies。如果该类型是我们需要的类型（ArticleService）， *\t*/ for (Class\u003c?\u003e autowiringType : this.resolvableDependencies.keySet()) { if (autowiringType.isAssignableFrom(requiredType)) { Object autowiringValue = this.resolvableDependencies.get(autowiringType); //key值是我们需要的类型，但value值未必。 //value可能是ObjectFactory，就得调用它的 getObject() 来获取真正的bean. autowiringValue = AutowireUtils.resolveAutowiringValue(autowiringValue, requiredType); if (requiredType.isInstance(autowiringValue)) { //如果类型匹配，则塞入result result.put(ObjectUtils.identityToString(autowiringValue), autowiringValue); break; } } } for (String candidate : candidateNames) { //如果不是自己依赖自己 ， 并且符合装配候选，就塞入result。 //何为符合装配候选（isAutowireCandidate）呢？稍后我们再详细分析。 if (!isSelfReference(beanName, candidate) \u0026\u0026 isAutowireCandidate(candidate, descriptor)) { addCandidateEntry(result, candidate, descriptor, requiredType); } } if (result.isEmpty() \u0026\u0026 !indicatesMultipleBeans(requiredType)) { // Consider fallback matches if the first pass failed to find anything... //如果之前一轮都没找到，则考虑回退匹配，什么是回退匹配？稍后再分析。 DependencyDescriptor fallbackDescriptor = descriptor.forFallbackMatch(); for (String candidate : candidateNames) { if (!isSelfReference(beanName, candidate) \u0026\u0026 isAutowireCandidate(candidate, fallbackDescriptor)) { //再执行一遍上面的方法。如果不是自己依赖自己，并且符合装配候选，就塞入result。 addCandidateEntry(result, candidate, descriptor, requiredType); } } if (result.isEmpty()) { // Consider self references as a final pass... // but in the case of a dependency collection, not the very same bean itself. // 如果依然没找到结果，那么满足以下条件的也是我们的目标。 // 1.是自引用 // 2.依赖不是多元素依赖 或者 bean名和候选者名字不相等（这里就避免了自引用导致无限循环） // 3.候选者符合回退匹配之后的装配候选 for (String candidate : candidateNames) { if (isSelfReference(beanName, candidate) \u0026\u0026 (!(descriptor instanceof MultiElementDescriptor) || !beanName.equals(candidate)) \u0026\u0026 isAutowireCandidate(candidate, fallbackDescriptor)) { addCandidateEntry(result, candidate, descriptor, requiredType); } } } } return result; } 看完主干自然还是有点迷糊，我们留下了三个问题要继续研究：\n如何查找出所有符合类型的 beanName 什么是符合装配候选 什么是回退匹配 ","wordCount":"279","inLanguage":"en","datePublished":"2018-01-23T09:00:22Z","dateModified":"2018-01-23T09:00:22Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://heeexy.com/posts/spring-note-15-findautowirecandidates/"},"publisher":{"@type":"Organization","name":"网站标题","logo":{"@type":"ImageObject","url":"https://heeexy.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://heeexy.com/ accesskey=h title="网站标题 (Alt + H)">网站标题</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Spring 源码笔记-2.7 根据类型寻找 bean</h1><div class=post-meta><span title='2018-01-23 09:00:22 +0000 UTC'>January 23, 2018</span></div></header><div class=post-content><h2 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><p>Spring 装配 bean 有两种类型：<code>autowireByName</code> 和 <code>autowireByType</code> 。</p><p><code>autowireByName</code> 通过名称查找很直接，就是我们一直在学的 getBean() 。</p><p>而 <code>autowireByType</code> 根据类型查找相比起来就要复杂一些了，《 Spring 源码深度解析 》 中有介绍过的部分我就不再重复贴了，但是书中遗漏了一处重要的部分&mdash;&mdash; <strong>findAutowireCandidates 查找所有合适的 bean</strong>，还有一处新版本 Spring 中升级的部分&mdash;&mdash;<strong>如果只需要一个但是找出多个 bean 该怎么处理</strong>，今天我们先来学习第一部分。</p><h2 id=正文>正文<a hidden class=anchor aria-hidden=true href=#正文>#</a></h2><h3 id=本函数要做什么>本函数要做什么<a hidden class=anchor aria-hidden=true href=#本函数要做什么>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@RestController</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@RequestMapping</span>(<span style=color:#e6db74>&#34;/article&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ArticleController</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> ArticleService articleService;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在初始化 ArticleController 的过程中，我们要为其装配 ArticleService 。</p><p>忽略掉外面代码一层一层的包裹之后，我们走到 <code>DefaultListableBeanFactory.findAutowireCandidates</code> 这个函数中，要寻找合适的候选 bean 。由于可能会找到多个，因此返回结果是候选 bean 的名称和其对应实例构成的 Map 。</p><h3 id=源码解析>源码解析<a hidden class=anchor aria-hidden=true href=#源码解析>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>//三个参数的含义依次是 </span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 正在解析的 beanName, 本例中即 &#34;articleController&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 需要装配的 bean 类型, 本例中即 ArticleService.class</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 对当前依赖关系的解析类，记录了 ArticleController 和 ArticleService 的依赖关系</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> Map<span style=color:#f92672>&lt;</span>String, Object<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>findAutowireCandidates</span>(String beanName,
</span></span><span style=display:flex><span>   Class<span style=color:#f92672>&lt;?&gt;</span> requiredType,
</span></span><span style=display:flex><span> DependencyDescriptor descriptor) {
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>//第一步就是查找出所有符合类型的 beanName 。</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//似乎第一句就干完全部逻辑了？？？稍后我们再详细分析这个方法。</span>
</span></span><span style=display:flex><span>	String<span style=color:#f92672>[]</span> candidateNames <span style=color:#f92672>=</span> BeanFactoryUtils.<span style=color:#a6e22e>beanNamesForTypeIncludingAncestors</span>(
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>this</span>, requiredType, <span style=color:#66d9ef>true</span>, descriptor.<span style=color:#a6e22e>isEager</span>());
</span></span><span style=display:flex><span>		Map<span style=color:#f92672>&lt;</span>String, Object<span style=color:#f92672>&gt;</span> result <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LinkedHashMap<span style=color:#f92672>&lt;</span>String, Object<span style=color:#f92672>&gt;</span>(candidateNames.<span style=color:#a6e22e>length</span>);
</span></span><span style=display:flex><span>  <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>   *	resolvableDependencies 记录了 依赖类型--具体装配值 的映射
</span></span></span><span style=display:flex><span><span style=color:#75715e>   *  	遍历 resolvableDependencies。如果该类型是我们需要的类型（ArticleService），
</span></span></span><span style=display:flex><span><span style=color:#75715e>   *	
</span></span></span><span style=display:flex><span><span style=color:#75715e>   */</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> (Class<span style=color:#f92672>&lt;?&gt;</span> autowiringType : <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>resolvableDependencies</span>.<span style=color:#a6e22e>keySet</span>()) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (autowiringType.<span style=color:#a6e22e>isAssignableFrom</span>(requiredType)) {
</span></span><span style=display:flex><span>				Object autowiringValue <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>resolvableDependencies</span>.<span style=color:#a6e22e>get</span>(autowiringType);
</span></span><span style=display:flex><span>              <span style=color:#75715e>//key值是我们需要的类型，但value值未必。</span>
</span></span><span style=display:flex><span>              <span style=color:#75715e>//value可能是ObjectFactory，就得调用它的 getObject() 来获取真正的bean.</span>
</span></span><span style=display:flex><span>				autowiringValue <span style=color:#f92672>=</span> AutowireUtils.<span style=color:#a6e22e>resolveAutowiringValue</span>(autowiringValue, requiredType);
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> (requiredType.<span style=color:#a6e22e>isInstance</span>(autowiringValue)) {
</span></span><span style=display:flex><span>                  <span style=color:#75715e>//如果类型匹配，则塞入result</span>
</span></span><span style=display:flex><span>					result.<span style=color:#a6e22e>put</span>(ObjectUtils.<span style=color:#a6e22e>identityToString</span>(autowiringValue), autowiringValue);
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> (String candidate : candidateNames) {
</span></span><span style=display:flex><span>          <span style=color:#75715e>//如果不是自己依赖自己 ， 并且符合装配候选，就塞入result。</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>//何为符合装配候选（isAutowireCandidate）呢？稍后我们再详细分析。</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>isSelfReference(beanName, candidate) <span style=color:#f92672>&amp;&amp;</span> isAutowireCandidate(candidate, descriptor)) {
</span></span><span style=display:flex><span>				addCandidateEntry(result, candidate, descriptor, requiredType);
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (result.<span style=color:#a6e22e>isEmpty</span>() <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>indicatesMultipleBeans(requiredType)) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Consider fallback matches if the first pass failed to find anything...</span>
</span></span><span style=display:flex><span>          <span style=color:#75715e>//如果之前一轮都没找到，则考虑回退匹配，什么是回退匹配？稍后再分析。</span>
</span></span><span style=display:flex><span>			DependencyDescriptor fallbackDescriptor <span style=color:#f92672>=</span> descriptor.<span style=color:#a6e22e>forFallbackMatch</span>();
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>for</span> (String candidate : candidateNames) {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>isSelfReference(beanName, candidate) <span style=color:#f92672>&amp;&amp;</span> isAutowireCandidate(candidate, fallbackDescriptor)) {
</span></span><span style=display:flex><span><span style=color:#75715e>//再执行一遍上面的方法。如果不是自己依赖自己，并且符合装配候选，就塞入result。</span>
</span></span><span style=display:flex><span>					addCandidateEntry(result, candidate, descriptor, requiredType);
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (result.<span style=color:#a6e22e>isEmpty</span>()) {
</span></span><span style=display:flex><span><span style=color:#75715e>// Consider self references as a final pass...</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// but in the case of a dependency collection, not the very same bean itself.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 如果依然没找到结果，那么满足以下条件的也是我们的目标。</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 1.是自引用</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 2.依赖不是多元素依赖 或者 bean名和候选者名字不相等（这里就避免了自引用导致无限循环）</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 3.候选者符合回退匹配之后的装配候选</span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>for</span> (String candidate : candidateNames) {
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>if</span> (isSelfReference(beanName, candidate) <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>							(<span style=color:#f92672>!</span>(descriptor <span style=color:#66d9ef>instanceof</span> MultiElementDescriptor) <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>beanName.<span style=color:#a6e22e>equals</span>(candidate)) <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>							isAutowireCandidate(candidate, fallbackDescriptor)) {
</span></span><span style=display:flex><span>						addCandidateEntry(result, candidate, descriptor, requiredType);
</span></span><span style=display:flex><span>					}
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>      }
</span></span></code></pre></div><p>看完主干自然还是有点迷糊，我们留下了三个问题要继续研究：</p><ul><li><a href=/2018/01/24/beanNamesForTypeIncludingAncestors/>如何查找出所有符合类型的 beanName</a></li><li>什么是符合装配候选</li><li>什么是回退匹配</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://heeexy.com/tags/java/>Java</a></li><li><a href=https://heeexy.com/tags/spring/>Spring</a></li><li><a href=https://heeexy.com/tags/%E7%AC%94%E8%AE%B0/>笔记</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://heeexy.com/>网站标题</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>