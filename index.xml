<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>网站标题</title><link>https://heeexy.com/</link><description>Recent content on 网站标题</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 13 Nov 2022 21:17:00 +0000</lastBuildDate><atom:link href="https://heeexy.com/index.xml" rel="self" type="application/rss+xml"/><item><title>数据库如果断电，我们需不需要慌？</title><link>https://heeexy.com/posts/database-crash-safe/</link><pubDate>Sun, 13 Nov 2022 21:17:00 +0000</pubDate><guid>https://heeexy.com/posts/database-crash-safe/</guid><description>序 生产环境我们时时刻刻在向数据库发送着写入、新增、删除数据的请求，不知道各位有没有和我一样的顾虑，如果服务器突然断电或者死机，数据会不会丢失，甚至数据库会不会挂了再也无法恢复？
心大的同学可能会说，我们生产环境的数据有副本，不用慌！
那么正在写入中的数据呢？写入请求发给了数据库，还没收到成功/失败的响应，这时候数据库断电，你慌不慌？
当然，作为数据库，自有它保障数据安全的方式，只要做好了合适的配置，就可以应对断电的情况。
今天我们就以 Elasticsearch 和 MySQL 为例来了解下数据库是如何保障数据安全的。
原理 Elasticsearch 数据在 lucene 中的主要写入流程上如下图所示，
从图上可以看出，只有 segment 落盘了，数据才是真正安全的。但是这会带来一个比较严重的问题：在 refresh 之后，commit 之前，数据已经可以被用户查到，然而断电后数据丢失，重启后这个数据无法被搜到。
因此 es 设计了translog，每次数据的写入，会在分词、加入倒排索引等重逻辑的 lucene 操作之前，数据的原始信息率先写入 translog。这就是 WAL (write-ahead-logging) 机制。
有了 translog 后，即使是没有落盘到 segment 的数据，崩溃想要恢复也有了依据，如下图所示，前2个阶段依靠 translog 恢复。
当然 translog 文件本身也会有 fsync 的问题，可以通过配置选择 translog 文件 fsync 的时机，而这个时机最终决定了数据的可恢复性。
Elasticsearch 比较常见的设置是：
index.translog.durability=async
index.translog.sync_interval=5s
这样配置下，最多可能丢失 5s 的数据。而 Elasticsearch 要保障数据支持崩溃恢复，比较极端的追求崩溃恢复的设置为：
index.translog.durability=request
每个 request 都会进行数据落盘。
MySQL 数据更新操作在 MySQL中的流程如下图所示，
其中崩溃恢复的核心是 redo log，innodb_flush_log_at_trx_commit 参数设置为 1 时，可以保障每次事务 commit 的时候 redo log 刷到磁盘。</description></item><item><title>Redisson分布式锁报错问题排查</title><link>https://heeexy.com/posts/redisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</link><pubDate>Thu, 16 Jul 2020 23:47:00 +0000</pubDate><guid>https://heeexy.com/posts/redisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</guid><description>故障 业务线测试同学反馈压测时，有以下报错日志：
java.lang.IllegalMonitorStateException: attempt to unlock lock, not locked by current thread by node id: def1bd2c-1f49-4802-b635-5ea78543c033 thread-id: 109 at org.redisson.RedissonLock.unlock(RedissonLock.java:366) 先抛结论 建议遇到类似问题的人先检查项目中是否确保了 redissonClient 的单例。（单线程当然也是必须的，不过排查起来很简单，估计看到文章的人首先已经排查过单线程的问题了）
本次报错是因为:
redissonClient 虽然是单例的静态成员变量，但初始化时未加锁，而是简单使用
private static RedissonClient redisson = null; public static RedissonClient getRedisson(){ if(redisson == null){ RedissonManager.init(); //初始化 } return redisson; } 加锁解锁没有同一个 lock，而是每次都使用getRedisson().getLock(key) 。导致解锁时从另一个 redissonClient 并没有获取到锁。 换言之，报错里的not locked by current thread by node id: def1bd2c-1f49-4802-b635-5ea78543c033 thread-id: 109 其实关键问题在于by node id ，而不是线程id。
定位问题依据 不需要改代码、加日志甚至debug，只需要搜索日志里是否有两行
13:58:07.972 [main] INFO org.</description></item><item><title>日志ES集群的潜在性能瓶颈--段合并</title><link>https://heeexy.com/posts/%E6%97%A5%E5%BF%97es%E9%9B%86%E7%BE%A4%E7%9A%84%E6%BD%9C%E5%9C%A8%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88--%E6%AE%B5%E5%90%88%E5%B9%B6/</link><pubDate>Sun, 28 Jun 2020 18:37:00 +0000</pubDate><guid>https://heeexy.com/posts/%E6%97%A5%E5%BF%97es%E9%9B%86%E7%BE%A4%E7%9A%84%E6%BD%9C%E5%9C%A8%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88--%E6%AE%B5%E5%90%88%E5%B9%B6/</guid><description>先抛结论 如果日志型ES集群system load 过高，I/O打满，尤其是在读写低谷时间段 read 异常高，可以考虑排查段合并的问题。
如果的确是遇到了段合并问题，可以考虑两个方向：
机械硬盘升级为SSD。 大索引拆分成小索引。 PS. 再附送一个潜在的查询问题可能导致的IO打满：通配符查询，参见文章。
排查 详细的排查过程就不赘述了，无非是加监控，包括业务层面、ES层面、机器层面，然后横向、纵向的分析各种监控指标。
这里分享几个容易被忽略的指标/api
查看最大的索引的 _stats 中merge部分：
total_stopped_time_in_millis ：通常应该是0
total_size_in_bytes：总共merge了这么多数据，你会发现远大于索引大小。下文会介绍这一指标。
观察线程状况，api详细参数可以查阅官方文档。我在定位问题时还不知道hot_threads这个api，如果提前知道的话可能就省下不少时间了。
GET _cat/thread_pool?v GET /_nodes/hot_threads 原理 段合并的基本原理很简单，两个（多个）已提交的段写入一个新的段。
这种读写除了尚在内存中的部分，就难免需要消耗磁盘IO了。
而从可视化Lucene段合并一文中得知，这种类似于SSD写放大的过程其实是一种浪费（文中称为tax），一个最终1G的索引可能由于merge而需要读写10G磁盘。
段合并算法优化的一个目标就是降低这种浪费，更高效地做段合并。
而减小我们索引的体积就可以轻松的带来显著的提升。</description></item><item><title>QPS从1k到2w，我做了什么</title><link>https://heeexy.com/posts/%E5%88%97%E8%A1%A8%E9%A1%B5%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/</link><pubDate>Mon, 17 Feb 2020 21:15:00 +0000</pubDate><guid>https://heeexy.com/posts/%E5%88%97%E8%A1%A8%E9%A1%B5%E4%BC%98%E5%8C%96%E7%BB%8F%E9%AA%8C/</guid><description>这两年有幸参与了商品列表系统的两次黑五挑战，QPS从最开始的1k都顶不住，到1w，再到2w，加上支持大量的AB实验，排序千人千面，功能越来越复杂，系统越来越庞大，可能这样的机会都不会常有，在此简单记录一下做系统优化的实践心得。
要素 仔细想想，做优化其实并没有很多门道，个人总结起来就三个要素：
业务 工具 人 业务 业务就是你的任务，是优化的目标，业务的复杂性和独特性决定了你的问题只有自己去解决，网上没有答案，即使挖个大神来也不能立马帮到你。
业务不仅仅包括公司对外提供的服务，还包括项目内部的一切细枝末节，比如代码的逻辑、服务器的部署、后台的配置、数据的流转，甚至不同团队间的分工合作等等。
我们要做的其实就是优化这些业务，业务中的任何一个点都可以是优化的方向。
工具 我们能用到的一切手段都是工具，有直接应对线上流量的服务器、代码、JVM、DB，也有间接可以帮助我们做优化的辅助工具，监控(Prometheus/Grafana)、日志(ELK)、压测(Goreplay)、诊断工具(Arthas)等等。
人 只了解业务的人面对问题束手无策，只钻研技术的人能解决的问题往往被技术限制了天花板。
我们需要的是精通业务，善用工具的人，能从监控数据中发现蛛丝马迹，能从复杂的业务关系中抽丝剥茧，能利用手上一切工具，发挥它们最大的作用。
步骤 抛开搭建环境、压测、回归测试等工作，优化步骤最精简的话只有两步：
找系统瓶颈 优化，突破瓶颈 找系统瓶颈 找瓶颈就需要有依据，依据就是监控指标。
监控指标的全面对于一个庞大的系统来说至关重要，不仅包括接口的耗时、JVM的状态、机器的负载等一些常见的指标，更需要细致到收集缓存的命中率、不同逻辑分支的占比、每张表的读写频率等具体业务相关的指标。
如果缺少了业务指标的监控，定位问题很可能定位不到根源，能优化的空间也会受到技术的限制。
优化 找到瓶颈之后，看起来问题很快就能解决了，JVM顶不住就调heap，调GC，DB顶不住就加副本，优化sql，毕竟我们学习的时候学的就是这些，面试的时候考的也是这些。
然而真正漫长而痛苦的优化过程中，这些直接了当的解决方式往往不会带来多少提升，因为简单的方法可能在我们当初开发功能时都已经做过。
通常想要成倍的提高吞吐量，我们需要做更多看似侧面的工作，解决根源上的问题。
几个例子 当我们吞吐量在1k不到时，JVM顶不住，这时候不管是升机器配置，还是JVM调优都没有明显效果。因为我们有很多慢接口，即使只占请求总量的1%不到，在大流量下也是拖垮服务的重要因素。我们采用了使用ES的一些高级特性，同时将数据准备成便于查询的结构（见ElasticSearch在高并发复杂查询业务场景的应用）等一系列措施，消灭了慢查询接口。
当慢接口处理完，吞吐量提升到了一定程度，JVM还是状况不佳，我们就考虑改善缓存。原本使用的JVM内缓存，尝试了调整缓存参数，使用集中式缓存Redis等方案后都没效果。最终通过Nginx层的缓存和一致性哈希大幅减轻了压力。
当接口都很快，DB（Elasticsearch）开始顶不住，我们尝试了加机器、扩副本、调堆内存大小等手段，最终还是通过将商品详情的查询移出ES，由单独的服务通过查Redis来提供，减轻了ES大半的压力。
。。。
以上的手段未必适合其它项目，但系统的优化就是这样，从来就没有标准答案。
我们能做的就只有深入业务，利用好每一种工具，然后充满信心地迎接下一个挑战。</description></item><item><title>JDBC为什么不需要Class.forName()</title><link>https://heeexy.com/posts/drivermaneger/</link><pubDate>Mon, 03 Feb 2020 19:57:00 +0000</pubDate><guid>https://heeexy.com/posts/drivermaneger/</guid><description>DriverManager 在初学JDBC时，总是记得开头就要来这么一句
Class.forName(&amp;#34;com.mysql.jdbc.Driver&amp;#34;); 然而今天学习类加载机制时偶然知道不需要这句也同样可以正常运行，测试的确如此，看了一眼源码，看似原因很简单，因为无论写不写那段Class.forName，在触发加载DriverManager时，会运行
/** * Load the initial JDBC drivers by checking the System property * jdbc.properties and then use the {@code ServiceLoader} mechanism */ static { loadInitialDrivers(); println(&amp;#34;JDBC DriverManager initialized&amp;#34;); } 都会扫描到这个Driver，注册到registeredDrivers中。
如果只要回答这个问题，可能上面的答案就已经足够了。
然而兴趣来了，总想把源码继续看下去到底扫描了啥，咋扫描的，明明
ServiceLoader&amp;lt;Driver&amp;gt; loadedDrivers = ServiceLoader.load(Driver.class); 这里是 java.sql.Driver 接口，上哪找出来的实现类？
我们就一层层的往下看吧。
ServiceLoader 主要做了两点
设置ClassLoader为当前线程的。（破坏双亲委派，让它rt.jar包中的类可以通过AppClassLoader获取到外部的类，很多讲双亲委派机制的文章已经大书特书过了） 初始化了一个懒加载的迭代器 lookupIterator = new LazyIterator(service, loader);。正是这个迭代器中最终帮我们找到了各种driver注册进去。 LazyIterator 既然是迭代器，最重要的当然是hasNext()和next()方法。
在next()方法中，已经拿到了nextName完整的&amp;quot;com.mysql.cj.jdbc.Driver&amp;quot;类名，说明还是hasNext()方法干了真正的扫描工作。
hasNext()方法的主要工作也都放在了hasNextService()中
private boolean hasNextService() { if (nextName != null) { return true; } if (configs == null) { try { //此处拼出了全名为 META-INF/services/java.</description></item><item><title>WIFI里都是自由的香味----软路由</title><link>https://heeexy.com/posts/%E8%BD%AF%E8%B7%AF%E7%94%B1/</link><pubDate>Mon, 23 Dec 2019 22:55:59 +0000</pubDate><guid>https://heeexy.com/posts/%E8%BD%AF%E8%B7%AF%E7%94%B1/</guid><description>教程&amp;amp;踩过的坑 前置条件 科学上网能力。SSR/V2ray等，最好自己搭过服务端，说明有基础能力。 鼠标&amp;amp;键盘&amp;amp;显示器&amp;amp;网线。为什么要单独拎出来，因为需要这些东西，说明你在操作时，可能至少需要有： 笔记本电脑，用来看教程，搜各种问题，远程连工控机 台式机，其实是用来拆鼠标&amp;amp;键盘&amp;amp;显示器给工控机使用 U盘。用于给工控机重新安装ESXi系统 为科学上网花钱的心理准备。因为至少需要购买一台工控机，要求高一点的还可以购买ROS正版授权，机场（For Netflix） 折腾的耐心。如果没有耐心又想要路由器科学上网，其实工控机+OpenWrt已经非常棒了。 选购软路由 https://www.youtube.com/watch?v=rGIUouvATqc
建议预装个LEDE，等玩明白了再折腾虚拟机。
安装EXSi 官网 https://my.vmware.com/en/web/vmware/info/slug/datacenter_cloud_infrastructure/vmware_vsphere/6_7
教程
https://www.cnblogs.com/xiaoyou2018/p/11122144.html
https://www.vediotalk.com/archives/2356
心得：
小白需要记住有这么一个设置静态ip的操作，可能你最终部署的网络环境不是你当前操作安装的网络，这个静态ip地址等改了网络环境就需要改。 按照教程部署端口组。 安装ROS 官网
https://mikrotik.com/download
教程
https://www.youtube.com/watch?v=mkJxDSMPlPU
https://www.youtube.com/watch?v=h6K5FThk-T4
https://www.youtube.com/watch?v=jgSM3vXGJ3c
心得：
官网下载的需要正版授权，否则仅能试用24h 洋葱的教程很好，可惜只有PPPOE拨号的方式，自动获取ip的上网方式可以参考Vedio Talk或其他人的教程 安装调试好记得设置虚拟机开机自启动！！！ ROS是整个系列里最核心也是最复杂的地方，稍微配置错一点，就无法上网。不过回想起整个过程，收获最大的也是这里，非常宝贵的网络实战经验！ 安装OpenWrt 恩山论坛 https://www.right.com.cn/forum/forum.php
安装教程
https://www.youtube.com/watch?v=n0aqV8rbKmE
http://www.oadun.com/2019/01/277.html
心得：
安装调试好记得设置虚拟机开机自启动！！！ 拓展延伸 源码 https://github.com/coolsnowwolf/lede
使用Github Actions 云编译 https://www.youtube.com/watch?v=2Y8DN-ROYIs</description></item><item><title>使用MyBatis时为什么Dao层不需要@Repository</title><link>https://heeexy.com/posts/%E4%BD%BF%E7%94%A8mybatis%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88dao%E5%B1%82%E4%B8%8D%E9%9C%80%E8%A6%81-repository/</link><pubDate>Tue, 03 Apr 2018 17:07:46 +0000</pubDate><guid>https://heeexy.com/posts/%E4%BD%BF%E7%94%A8mybatis%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88dao%E5%B1%82%E4%B8%8D%E9%9C%80%E8%A6%81-repository/</guid><description>问题 Service层注入Dao时， Intellij 总会以红色波浪线提示我们
@Autowired private UserDao userDao; Could not autowire. No beans of &amp;lsquo;UserDao&amp;rsquo; type found. Checks autowiring problems in a bean class.
尽管我们都知道 Dao 层的 Bean 实际上都是有的，并且可以设置关闭这恼人的提示，但是我们有没有想过为什么 Intellij 就找不到这个 Bean 呢？甚至有人有这种做法
@Repository public interface UserDao { } 来避免提示，但是这种做法正确么？
所以今天我们的疑问就是
为什么 Dao 层不需要加 @Repository 注解，源码里到底做了什么？ 加了 @Repository 注解有什么影响？ 答案 关键在于 ClassPathMapperScanner 对指定包的扫描，并且扫描过程对 Spring 原本的扫描 Bean 的步骤 &amp;ldquo;加了料” ，Spring 本身只扫实现类，但 MyBatis 的扫描器扫了接口 。并且扫完接口之后，为接口配了个 BeanDefinition ,并且这个 bd 的 BeanClass 是 MapperFactoryBean 。</description></item><item><title>近期阅读源码的总结与转变</title><link>https://heeexy.com/posts/recent-summary/</link><pubDate>Sun, 28 Jan 2018 19:11:29 +0000</pubDate><guid>https://heeexy.com/posts/recent-summary/</guid><description>阅读源码 初读 Spring 2017年9月开始阅读 Spring 源码，便在博客上记录自己的阅读笔记，阅读的过程真的是恨痛苦，一个月的时间两大章节还没读完，效果上也不明显。
后面几个月公司业务繁忙更是停下了读源码的节奏。
MyBatis 而12月入了一本《MyBatis 技术内幕》，介绍 MyBatis 的书，想从 MyBatis 入手，并且带着自己的小问题去研究 MyBatis 的源码，去探究一下我用 JSONObject 为什么就可以替代 JavaBean 。
花了一个月的时间便读完了第一遍书，也大致解答了自己的疑惑。发现研究起 MyBatis 确实是轻松很多，总结一下有以下方面的原因：
MyBatis 源码量小很多，层次结构清晰，功能明确，确实比 Spring 要简单很多 作者划分章节层次合适 学会了 Debug 源码 拿起了实体书&amp;hellip;比9月看电子书时确实方便很多 一本书走完一遍，感觉清楚了很多，对于 MyBatis 剩下的任务，就是再读一遍，特别是带着问题再读，比如去研究它的缓存、配置、反射。
再读 Spring 1月再回过头继续学习 Spring ，其实最大的转变就是，不再执着于见到一段代码就想一直钻到底弄清楚了，Spring 的层次太深，特别容易钻着钻着就把自己绕得不知道在哪了。因此，还是根据书本介绍，文档注释和函数/变量名称大概了解函数的作用先，待刷完一遍之后再回过头二刷再追求搞明白吧。
转变 博客 关于博客的记录，也要做一做转变了。起初写得东西只是笔记，渐渐加入了自己的理解，但是目前来看质量还是不够，有一个很重要的原因就是自己对一些还没有深刻的认识。
前阵子想独立钻研一波 Spring 的 autowiredByType，就匆匆忙忙开了一文，结果读着读着才发现这坑深不见底，实在不该在第一遍时就去碰&amp;hellip;
因此，计划博客向更有营养的方向发展，尽量让博客能记录、传播一些能提升自己和其他读者认识的东西。像上一文自己动手实现解决循环依赖就是一个很好的主题，虽然文章写得不够好，技术含量也不够高，但是至少方向上来说确实能学到新东西。
学习 博客的更新频率将会降低，一方面是要自己先学透，提示博文质量，另一方面也是其实后面一段时间将会将重心放在找工作上。毕竟对于技术面试和以前的考试差不多，精读源码实在是性价比有点低，全面复习准备面试题效果更好。虽然我是不喜欢准备面试题的，但没有办法，下一份工作很关键，只有找到稳定的，能追求技术的团队，才能提供安心的钻研技术的环境。</description></item><item><title>极简 Spring 框架 -- 浅析循环依赖</title><link>https://heeexy.com/posts/spring-note-18-ioc/</link><pubDate>Sun, 28 Jan 2018 13:37:32 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-18-ioc/</guid><description>从网上看到一篇博文 徒手撸框架&amp;ndash;实现IoC ，写得很棒，作者抛开了 Spring 源码中复杂的校验，拓展等功能，实现了一个极简的 IoC 框架，让 Spring 源码初学者可以清楚的看到 IOC 的实现流程。
本文就借其框架，略加改造，再次介绍一下 Spring 是如何处理循环依赖的。
了解本项目核心代码需要先参考原作者的博文 徒手撸框架&amp;ndash;实现IoC 。
循环依赖 其实很好理解，A 类依赖 B，B 又依赖 A。
说具体点就是 ，我们要 getBean(&amp;ldquo;a&amp;rdquo;)， A 在实例化时需要为类型为 B 的成员变量赋值，因此去 getBean(&amp;ldquo;b&amp;rdquo;)，而 getBean(&amp;ldquo;b&amp;rdquo;) 的时候又需要为其类型为A 的成员变量赋值，此时又会回过头去实例化 A ，导致无限循环。
用代码展示就是
public class A { @AutoWired private B b; } public class B { @AutoWired private A a; } 代码改造 最主要的代码改造在于 BeanFactoryImpl 内， 添加了成员变量
private final Map&amp;lt;String, Object&amp;gt; earlySingletonObjects = new HashMap&amp;lt;String, Object&amp;gt;(16); 用于缓存正在创建中的，提前暴露出来的单例 bean。</description></item><item><title>Spring 源码笔记-2.8 根据类型寻找 bean--找出所有匹配类型的 beanName</title><link>https://heeexy.com/posts/spring-note-16-beannamesfortypeincludingancestors/</link><pubDate>Wed, 24 Jan 2018 09:48:02 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-16-beannamesfortypeincludingancestors/</guid><description>前文
源码解析 入参说明
includeNonSingletons：是否包括非单例的 bean，比如 prototype scope allowEagerInit：为了这个检查（找出所有匹配类型的 beanName），是否初始化 lazy-init 单例和由 FactoryBeans 创建的对象。此处我们传入的值为 true。 public static String[] beanNamesForTypeIncludingAncestors( ListableBeanFactory lbf, Class&amp;lt;?&amp;gt; type, boolean includeNonSingletons, boolean allowEagerInit) { Assert.notNull(lbf, &amp;#34;ListableBeanFactory must not be null&amp;#34;); //方法主干还是在这行 getBeanNamesForType String[] result = lbf.getBeanNamesForType(type, includeNonSingletons, allowEagerInit); //下面的内容就是从 bf 的 parent 中找， if (lbf instanceof HierarchicalBeanFactory) { HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf; if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) { //此处以 parent 再来调此方法，合并结果。 String[] parentResult = beanNamesForTypeIncludingAncestors( (ListableBeanFactory) hbf.</description></item><item><title>Spring 源码笔记-2.7 根据类型寻找 bean</title><link>https://heeexy.com/posts/spring-note-15-findautowirecandidates/</link><pubDate>Tue, 23 Jan 2018 09:00:22 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-15-findautowirecandidates/</guid><description>前言 Spring 装配 bean 有两种类型：autowireByName 和 autowireByType 。
autowireByName 通过名称查找很直接，就是我们一直在学的 getBean() 。
而 autowireByType 根据类型查找相比起来就要复杂一些了，《 Spring 源码深度解析 》 中有介绍过的部分我就不再重复贴了，但是书中遗漏了一处重要的部分&amp;mdash;&amp;mdash; findAutowireCandidates 查找所有合适的 bean，还有一处新版本 Spring 中升级的部分&amp;mdash;&amp;mdash;如果只需要一个但是找出多个 bean 该怎么处理，今天我们先来学习第一部分。
正文 本函数要做什么 @RestController @RequestMapping(&amp;#34;/article&amp;#34;) public class ArticleController { @Autowired private ArticleService articleService; } 在初始化 ArticleController 的过程中，我们要为其装配 ArticleService 。
忽略掉外面代码一层一层的包裹之后，我们走到 DefaultListableBeanFactory.findAutowireCandidates 这个函数中，要寻找合适的候选 bean 。由于可能会找到多个，因此返回结果是候选 bean 的名称和其对应实例构成的 Map 。
源码解析 //三个参数的含义依次是 // 正在解析的 beanName, 本例中即 &amp;#34;articleController&amp;#34; // 需要装配的 bean 类型, 本例中即 ArticleService.class // 对当前依赖关系的解析类，记录了 ArticleController 和 ArticleService 的依赖关系 protected Map&amp;lt;String, Object&amp;gt; findAutowireCandidates(String beanName, Class&amp;lt;?</description></item><item><title>Spring 源码笔记-2.6 BeanWrapper 对比 MyBatis</title><link>https://heeexy.com/posts/spring-note-14-beanwrapper/</link><pubDate>Fri, 19 Jan 2018 15:21:58 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-14-beanwrapper/</guid><description>Spring vs MyBatis Spring 和 MyBatis 中都有 BeanWrapper , Spring 中为接口， 实现类为 BeanWrapperImpl , 为了方便后面区分，本文用 SB 指代 Spring 的 BeanWrapperImpl ，用 MB 指代 MyBatis 中的 BeanWrapper。
功能 BeanWrapper 都属于各自框架的反射工具箱的重要组成部分。都是创建实例并且为其属性赋值的。以 SB 为例，下面的代码应该很容易看明白它的功能。
BeanWrapper company = BeanWrapperImpl(new Company()); // setting the company name.. company.setPropertyValue(&amp;#34;name&amp;#34;, &amp;#34;Some Company Inc.&amp;#34;); // ... can also be done like this: PropertyValue value = new PropertyValue(&amp;#34;name&amp;#34;, &amp;#34;Some Company Inc.&amp;#34;); company.setPropertyValue(value); // ok, let&amp;#39;s create the director and tie it to the company: BeanWrapper jim = BeanWrapperImpl(new Employee()); jim.</description></item><item><title>Spring源码笔记-2.5 createBean</title><link>https://heeexy.com/posts/spring-note-13-createbean/</link><pubDate>Thu, 18 Jan 2018 14:22:06 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-13-createbean/</guid><description>此方法交给了 AbstractBeanFactory 的子类 AbstractAutowireCapableBeanFactory 去实现。
并且不管这个bean是单例还是 prototype 还是其它 scope ,最终都是会走到此处，只是前后的一些验证、处理有区别。比如单例的就要先去缓存中获取，prototype 就不需要。
源码阅读到这里，我们已经习惯了一层一层剥。createBean 依然还是没有直接地把 bean 创建出来（当然我所期望的看到创建 bean 就是看到它的反射源码为止）。
createBean 的大致步骤为:
根据 RootBeanDefinition 来获取要创建 bean 的 class 。这 class 还有可能为 null。 prepareMethodOverrides 。准备 override 方法，对 override 属性进行验证。 给后处理器一个机会来返回代理，替代真正的 bean. doCreateBean 创建真正的 bean 实例。 prepareMethodOverrides 首先去温习一遍 lookup-method 和 replace-method 吧。博文
其实就是通过配置把原本 bean 中的某个方法给替代掉。
此处我们先只是确认一遍指定的替代方法存在于要生成的 bean 中。
顺带看一看这个方法有没有重载overload)，做个标记。
resolveBeforeInstantiation 经过一波预处理器InstantiationAwareBeanPostProcessor ，如果生产出了 bean，再经过一波后处理器。
一旦生产出 bean，则立即将此 bean 返回。
此处就是留下了一个拓展点，经过此方法之后，bean可能已经不是我们认为的 bean 了，而可能已经变成了一个经过处理的代理 bean 。
循环依赖 构造器循环依赖 如果是 prototype，无法解决，只能抛错。</description></item><item><title>MyBatis 对未知数据类型的转换(二)TypeHandlerRegistry</title><link>https://heeexy.com/posts/typehandlerregistry/</link><pubDate>Thu, 04 Jan 2018 21:22:33 +0000</pubDate><guid>https://heeexy.com/posts/typehandlerregistry/</guid><description>问题 上一篇我们讲到，对于未知数据类型的解析，UnknownTypeHandler 把部分任务交给了 TypeHandlerRegistry ,甚至可能仅仅只丢了一个 javaType 过来就要求返回一个合适的解析器回去 。TypeHandlerRegistry 到底里面做了啥可以找到合适的解析器呢？
功能 从类的名字我们就知道这个类的功能大概就是个注册表，而且很可能是全局共用的，记录各种 javaType,jdbcType,TypeHandler 的映射关系。实际这个类的核心也就是维护了几个 map 。
核心字段 JDBC_TYPE_HANDLER_MAP private final Map&amp;lt;JdbcType, TypeHandler&amp;lt;?&amp;gt;&amp;gt; JDBC_TYPE_HANDLER_MAP = new EnumMap&amp;lt;JdbcType, TypeHandler&amp;lt;?&amp;gt;&amp;gt;(JdbcType.class); 这个很直观，就是注册 jdbcType 和解析器的对应关系。
TYPE_HANDLER_MAP private final Map&amp;lt;Type, Map&amp;lt;JdbcType, TypeHandler&amp;lt;?&amp;gt;&amp;gt;&amp;gt; TYPE_HANDLER_MAP = new ConcurrentHashMap&amp;lt;Type, Map&amp;lt;JdbcType, TypeHandler&amp;lt;?&amp;gt;&amp;gt;&amp;gt;(); 书上原文是：“记录了 java 类型向指定的 JdbcType 转换时，需要使用的 TypeHandler 对象。例如：Java 类型中的 String 转换成数据库的 char 、varchar 等多种类型，所以存在一对多关系”。
Type 是 java.lang.reflect 包下的接口，Class 类实现了此接口。所以此 map 的 key 值是 javaType ,比如 String.class 。
UNKNOWN_TYPE_HANDLER 就是上一篇文章学习过的 UnknownTypeHandler 的实例，主要用在 Object.</description></item><item><title>MyBatis 对未知数据类型的转换(一)TypeHandler</title><link>https://heeexy.com/posts/mybatis%E5%AF%B9%E6%9C%AA%E7%9F%A5%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/</link><pubDate>Tue, 02 Jan 2018 22:35:52 +0000</pubDate><guid>https://heeexy.com/posts/mybatis%E5%AF%B9%E6%9C%AA%E7%9F%A5%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/</guid><description>问题 前面说到，我们可以用 JSONObject 替代习惯使用的 JavaBean ，而之所以能用 JSONObject 主要就是因为它实现了 Map&amp;lt;String,Object&amp;gt; 。
实际使用我们就会发现，MyBatis 使用JSONObject 封装返回结果的时候很“智能”，数据库里字段是 varchar 类型，JSONObject 中返回值就是 String 类型，数据库字段是 int/float 类型，JSONObject 中返回值就是对应的数值类型。甚至通过 debug 发现数据库中保存了datetime 类型的数据，JSONObject 中保存的是 java.sql.timestamp 类型，而timestamp 类型继承了常见的 java.util.Date 。
为什么 MyBatis 可以用得这么爽呢？我们实现可完全没声明需要此字段的 javaType 呢。而且用得爽了，类型转换会不会导致程序性能大打折扣呢？
今天我们就从深入源码，探究一番 MyBatis 到底是怎样做到对未明确声明的字段处理返回类型的。
TypeHandler MyBatis 类型转换的核心就是这个接口，定义的方法可以看做就两种 setParameter 和 getResult ,很好理解，我们传参和接收 sql 结果时就调用这个。
public interface TypeHandler&amp;lt;T&amp;gt; { void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException; T getResult(ResultSet rs, String columnName) throws SQLException; T getResult(ResultSet rs, int columnIndex) throws SQLException; T getResult(CallableStatement cs, int columnIndex) throws SQLException; } 抽象类 BaseTypeHandler 部分实现了 TypeHandler ,主要完成了对空值的处理。 非空值的处理全部交给了子类完成。</description></item><item><title>MyBatis 中使用 JSONObject 处理一对多结果</title><link>https://heeexy.com/posts/one2many/</link><pubDate>Sun, 31 Dec 2017 12:11:29 +0000</pubDate><guid>https://heeexy.com/posts/one2many/</guid><description>问题 在上一文介绍了 JSONObject 接受 MyBatis 的结果集的简单用法，但是在处理一对多的情况时，单纯的JSONObject就不好使了。
比如要查询一个角色下的多个用户，resultMap如下定义
&amp;lt;resultMap id=&amp;#34;roleMap&amp;#34; type=&amp;#34;com.alibaba.fastjson.JSONObject&amp;#34;&amp;gt; &amp;lt;id column=&amp;#34;roleId&amp;#34; property=&amp;#34;roleId&amp;#34;/&amp;gt; &amp;lt;result column=&amp;#34;roleName&amp;#34; property=&amp;#34;roleName&amp;#34;/&amp;gt; &amp;lt;collection property=&amp;#34;users&amp;#34; ofType=&amp;#34;com.alibaba.fastjson.JSONObject&amp;#34;&amp;gt; &amp;lt;id column=&amp;#34;userId&amp;#34; property=&amp;#34;userId&amp;#34;/&amp;gt; &amp;lt;result column=&amp;#34;nickname&amp;#34; property=&amp;#34;nickname&amp;#34;/&amp;gt; &amp;lt;/collection&amp;gt; &amp;lt;/resultMap&amp;gt; 期望查出来的users 属性对应着一个数组,
然而实际查出来只是一个对象，只有一条数据。
解决方案 只需要建一个实体类继承 JSONObject ,里面有你要的集合类型的成员变量，就足够了。
比如我建的 One2Many 类：
public class One2Many extends JSONObject { private List&amp;lt;JSONObject&amp;gt; users; } 然后xml改为
&amp;lt;resultMap id=&amp;#34;roleMap&amp;#34; type=&amp;#34;com.heeexy.example.util.model.One2Many&amp;#34;&amp;gt; &amp;lt;id column=&amp;#34;roleId&amp;#34; property=&amp;#34;roleId&amp;#34;/&amp;gt; &amp;lt;result column=&amp;#34;roleName&amp;#34; property=&amp;#34;roleName&amp;#34;/&amp;gt; &amp;lt;collection property=&amp;#34;users&amp;#34; ofType=&amp;#34;com.alibaba.fastjson.JSONObject&amp;#34;&amp;gt; &amp;lt;id column=&amp;#34;userId&amp;#34; property=&amp;#34;userId&amp;#34;/&amp;gt; &amp;lt;result column=&amp;#34;nickname&amp;#34; property=&amp;#34;nickname&amp;#34;/&amp;gt; &amp;lt;/collection&amp;gt; &amp;lt;/resultMap&amp;gt; 是不是非常简单？
更棒的是，这个 One2Many 类是可以复用的，里面再添加其它的成员变量就 OK 了。而且 Dao 层不需要改动，外面正常的还是用 JSONObject 就可以了。</description></item><item><title>MyBatis 中使用 JSONObject 替代 JavaBean</title><link>https://heeexy.com/posts/mybatis%E4%B8%AD%E4%BD%BF%E7%94%A8jsonobject%E6%9B%BF%E4%BB%A3javabean/</link><pubDate>Sat, 30 Dec 2017 21:51:55 +0000</pubDate><guid>https://heeexy.com/posts/mybatis%E4%B8%AD%E4%BD%BF%E7%94%A8jsonobject%E6%9B%BF%E4%BB%A3javabean/</guid><description>问题背景 项目后端与前端全部使用 JSON 进行数据交互，比如查询用户列表，通常后端从数据库查出的数据放入实体类再转为 JSON 返回给前端，但是前端的小伙伴表示明明只需要 nickname,avatar,userId 三个字段，为什么传过来的数据多出 phone,address ,profile 之类十几个字段，里面都 null,0 等值？
其实是因为 User 实体类定义了太多字段，转为 JSON 的时候都被包括进去了。稍微多几个还能忍，但通常 User/Order 这些实体类字段特别多，对调试开发实在非常不友好。
因此本次任务就是：确保每个接口返回字段都与接口文档上一模一样，去除冗余字段。
解决过程就省略了，直接抛出我最后的解决方案吧：就是 MyBatis 的返回值几乎完全抛弃实体类，全部使用com.alibaba.fastjson.JSONObject 。
使用 JSONObject 先最简化直观的看一下 JSONObject 的使用吧。
Controller:
@GetMapping(&amp;#34;/list&amp;#34;) public JSONObject listUser(@RequestBody JSONObject requestJson){ return userService.listUser(requestJson); } Service:
JSONObject listUser(JSONObject jsonObject); ServiceImpl:
@Override public JSONObject listUser(JSONObject jsonObject) { //fillPageParam是自定义的封装分页参数 CommonUtil.fillPageParam(jsonObject); int count = userDao.countUser(jsonObject); List&amp;lt;JSONObject&amp;gt; list = userDao.listUser(jsonObject); //自定义successPage封装分页结果 return CommonUtil.successPage(jsonObject, list, count); } Dao:
public interface UserDao { int countUser(JSONObject jsonObject); List&amp;lt;JSONObject&amp;gt; listUser(JSONObject jsonObject); } UserMapper.</description></item><item><title>MyBatis 的日志设计--适配器模式 &amp; 工厂模式</title><link>https://heeexy.com/posts/mybatis%E6%97%A5%E5%BF%97--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 14 Dec 2017 14:45:47 +0000</pubDate><guid>https://heeexy.com/posts/mybatis%E6%97%A5%E5%BF%97--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid><description>​ MyBatis 想要打印日志，时不时想要来句 log.debug() 、log.error() ，需要个打印机 ，可是自己又不想去实现（而且跟着整个项目用同样的打印系统才是王道啊），需要去用别人家的打印机，要用别人家的产品啊，那问题可就来了。
问题 1 ​ 市面上各家的打印机 slf4j、java.util.logging、log4j 甚至 System.out 都是各种不同的用法，这使用起来就太麻烦了。
思路 ​ 不管市面上打印机有多少型号，我家 MyBatis 包里的类只用自家的统一接口，我家的类只管 log.debug()、log.error()&amp;hellip;
​ 定义好了接口，就需要实现类 impl 来实现这些 debug()、error() 方法了 , 咱假装是自己来实现，其实去调用真正打印机 slf4、log4j 的方法，这样就把别人家的打印机和咱自家的接口关联起来啦。
​ 这就是适配器模式。
​ 我家的每个实现类其实就是一个适配器，每个适配器去适配一种打印机。比如 slf4jLoggerImpl 就完成了对 slf4j 打印机的适配，slf4jLoggerImpl .debug() 调用了slf4j.Logger.debug()。
​ 这样市面上每多一种打印机，比如想用 log4j2 了，我就只需要加一种适配器 log4j2LoggerImpl 去适配它就可以了。
代码 ​ 定义接口
public interface Log { boolean isDebugEnabled(); void debug(String s); ... } ​ 在实现类里完成适配，比如适配 slf4j 的 Slf4jLoggerImpl
import org.apache.ibatis.logging.Log; import org.slf4j.Logger; class Slf4jLoggerImpl implements Log { private final Logger log; //注意这个地方，入参为 org.</description></item><item><title>谷歌云搭建SSR</title><link>https://heeexy.com/posts/%E8%B0%B7%E6%AD%8C%E4%BA%91%E6%90%AD%E5%BB%BAssr/</link><pubDate>Mon, 13 Nov 2017 14:02:44 +0000</pubDate><guid>https://heeexy.com/posts/%E8%B0%B7%E6%AD%8C%E4%BA%91%E6%90%AD%E5%BB%BAssr/</guid><description>在全国喜迎大会胜利召开的时候,墙出不去了,经常看到大家有这么一种想法 : 等会开完就好了&amp;hellip;&amp;hellip;
为什么用GCE 速度快. 有台湾服务器,南京电信ping 稳定在40-60 ,youtube4K无压力. Chrome可以愉快地把Google用作默认浏览器了
免费一年. 只是需要提供一张外币信用卡,但是不会扣款,更不会在一年到期后自动扣款!(被AWS坑了几美元去)
​
如何申请GCE ​ 网上搜到教程很多,就不细述了
​ 有几个可能会卡时间的步骤包括
选用静态IP
和AWS一样, 放开你要分配给SSR的端口 ,如果找不到这个菜单可以搜索Firewall rules
Xshell生成的SSH的私钥可能要在后面加上
google-ssh {&amp;quot;userName&amp;quot;:&amp;quot;xxxxx@gmail.com&amp;quot;,&amp;quot;expireOn&amp;quot;:&amp;quot;2017-11-10T04:39:03+0000&amp;quot;}
​
如何部署SSR 步骤 获取root权限 sudo su 安装SSR wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/shadowsocks_install/master/shadowsocksR.sh &amp;amp;&amp;amp; bash shadowsocksR.sh ​ 安装完成的时候会有一串成功的提示信息, 可以复制记下你的ip/端口/密码/加密方式等信息
安装BBR wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh chmod +x bbr.sh ./bbr.sh 重置VM实例
sudo su
检查是否成功
sysctl net.ipv4.tcp_available_congestion_control 看是不是出现
net.ipv4.tcp_available_congestion_control = bbr cubic reno 类似有 bbr 的字样,有就表示BBR也装好了
常用命令 /etc/init.d/shadowsocks restart 重启SSR</description></item><item><title>前后端分离实践小结</title><link>https://heeexy.com/posts/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%AE%9E%E8%B7%B5/</link><pubDate>Sun, 29 Oct 2017 00:27:05 +0000</pubDate><guid>https://heeexy.com/posts/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%AE%9E%E8%B7%B5/</guid><description>背景 ​ 公司项目转型,要开新的运营管理平台,我提议借此开新项目的机会,进行前后端分离,由我负责带领小组新技术学习/分享,探坑填坑.
分离原因 最关键一点,受不了jsp/freemarker里一塌糊涂的代码,分离之后,代码按规范写,简洁,好管理 原本我们后端就一直在给Android/iOS提供接口,本次分离,可以方便以后H5端的项目重构,实现Android+iOS+H5的统一,一套接口可以供三端同时使用,大量节省工作量,也可以更好地保证公司产品质量的统一性. 方便后端专心处理数据,前端实现页面效果.而不是前端仅仅画页面写css,后端还需要复制粘贴过来,套数据,修改已有页面时,前端更是不方便插手. 技术选型 ​ 组员后端技术都是SSM,前端都只是略接触过AngularJS/Vue.
​ 我之前接触了一下Spring Boot,感觉配置很清爽,搭框架轻松,业务写起来快,可以让组员无缝切过来,无需费时学习,因此后端框架选定Spring Boot.而登录控制与权限管理一直是公司以前几个项目的弱项,因此本次决定引入shiro,而组员无一对shiro熟悉的,研究shiro的任务自然由我承担.
​ 前端框架是本次前后端分离的重点,由于我们组无人熟悉前端的新框架,所以这次势必每个人都需要学习许多新的前端知识.我拿公司的H5项目的几个页面进行过搭建vue框架重构练手,认为vue文档清晰,资料丰富,相关开源方案够多,我们这次可以放心学习,使用.(当然最主要的还是因为坑全都得由我来填,得挑个熟悉的)
目前进展 ​ 后端:Spring Boot框架搭建完成,shiro可以进行权限管理,自定义拦截器,常用工具类完成,对常用的增删改查,返回结果,异常处理都可以快速搞定.
​ 前端:数据交互封装完毕,路由熟悉,前端权限管理初步熟悉,选用饿了么开源的Element框架,常用的增删改查的页面元素及工具方法都已让大家掌握.
​ 本周一开始教组员使用Intellij IDEA,教前端快速铺页面的方法,介绍前后端我封装的各种小轮子.经过一周时间,全部都已熟悉这套新的前后端框架,每个人都可以独立快速地推出常用页面.
接口端小技巧 ​ 因为后端全部返回统一json格式的接口,所以我设计了一些小的工具方法,方便快速推出新接口,节省重复代码.
使用JSONObject而不是实体类
​ 因为后端业务不算复杂,所以舍弃了实体类的语义性,转而使用阿里的fastjson的JSONObject接收MyBatis返回的结果.比如一个简单的查询只需要
&amp;lt;select id=&amp;#34;getSimple&amp;#34; resultType=&amp;#34;com.alibaba.fastjson.JSONObject&amp;#34;&amp;gt; SELECT s.order_id shopOrderId, s.operation operation, date_format(s.create_time, &amp;#39;%Y.%m.%d %H:%i:%s&amp;#39;) createTime FROM shop_order_log s WHERE s.user_delete_status = &amp;#34;1&amp;#34; &amp;lt;/select&amp;gt; 就可以将三个字段shopOrderId,operation,createTime放入json内,字段名称更加灵活,也免去了大量的建实体类,写resultMap的代码.
​ 更好的一点是,不使用实体类,可以在返回结果中避免掉很多空的需不要的字段.
​ 还有,因为所有的接口层都返回JSONObject,所以编写工具方法,快速返回成功/失败结果也很简单,我写了多个工具方法,包括入参转json,入参非空校验,返回成功/失败结果,分页,这里就不一一贴出代码了.
自定义Exception
public class CommonJsonException extends RuntimeException { private JSONObject resultJson; /** * 调用时可以在任何代码处直接throws这个Exception, * 都会统一被拦截,并封装好json返回给前台 * * @param errorEnum 以错误的ErrorEnum做参数 */ public CommonJsonException(ErrorEnum errorEnum) { JSONObject jsonObject = new JSONObject(); CommonUtil.</description></item><item><title>搭建springboot-shiro-vue框架时遇到的坑</title><link>https://heeexy.com/posts/build-springboot-shiro/</link><pubDate>Sun, 22 Oct 2017 11:19:33 +0000</pubDate><guid>https://heeexy.com/posts/build-springboot-shiro/</guid><description>​ 最近在做前后端分离的新框架,选用了后端springboot+shiro,前端vue+elementUI,第一次搭SSM之外的非demo项目,尤其shiro更是之前从未接触,折腾了很多天,遇到很多问题,大部分能百度出来,剩下的非常费时的问题且称之为坑吧.
跨域 ​ 一大部分问题就是跨域造成的,本身vue-cli搭建的项目可以用
// 1. axios的baseURL设置为/api // 2. 如下设置 proxyTable: { &amp;#39;/api&amp;#39;: { target: &amp;#39;http://127.0.0.1:8080/&amp;#39;, changeOrigin: true, pathRewrite: { &amp;#39;^/api&amp;#39;: &amp;#39;/&amp;#39; } } }, 来解决开发环境跨域的问题,生产环境反正可以打包静态文件到springboot项目中直接跑.
而我还是脑抽得选择了强行跨域,假装自己要把静态文件单独放个服务器跑&amp;hellip;为此遇到很多问题,折腾好几天.
因此强力推荐上面的方案,简单快捷地解决跨域!
如果生产环境真的需要跨域的话,再按下面方法设置
大部分跨域的配置都能百度搜出来:
axios要 withCredentials: true
用session而不用啥特殊的token之类的话,就不用 config.headers['X-Token'] = getToken() ,这句是vueAdmin-template 中带的,需要删掉.
后端需要配置允许跨域
@Configuration public class CorsConfig { private CorsConfiguration buildConfig() { CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOrigin(&amp;#34;*&amp;#34;); // 1 设置访问源地址 corsConfiguration.addAllowedHeader(&amp;#34;*&amp;#34;); // 2 设置访问源请求头 corsConfiguration.addAllowedMethod(&amp;#34;*&amp;#34;); // 3 设置访问源请求方法 corsConfiguration.setAllowCredentials(true); return corsConfiguration; } @Bean public CorsFilter corsFilter() { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.</description></item><item><title>Spring源码笔记-2.4 获取单例</title><link>https://heeexy.com/posts/spring-note-12-%E8%8E%B7%E5%8F%96%E5%8D%95%E4%BE%8B/</link><pubDate>Fri, 29 Sep 2017 22:49:00 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-12-%E8%8E%B7%E5%8F%96%E5%8D%95%E4%BE%8B/</guid><description>获取单例bean getSingleton 明明之前一篇已经讲过了获取单例,为什么这里又是获取单例bean呢?
两天不看书,果断又忘了.前面学的是从缓存中获取,这里是真正的获取.
DefaultSingletonBeanRegistry 中重载此方法,第二参数为ObjectFactory
public Object getSingleton(String beanName, ObjectFactory&amp;lt;?&amp;gt; singletonFactory) { Assert.notNull(beanName, &amp;#34;&amp;#39;beanName&amp;#39; must not be null&amp;#34;); //这里再次看到了这个singletonObjects,上篇文章介绍过,是维护了单例对象 //书中说法是:用于保存BeanName和创建bean实例之间的关系 Map var3 = this.singletonObjects; synchronized(this.singletonObjects) { Object singletonObject = this.singletonObjects.get(beanName); //首先获取一遍,如果不存在,才去创建 if (singletonObject == null) { //工厂如果正在销毁,这时候获取bean就会报错 if (this.singletonsCurrentlyInDestruction) { throw new BeanCreationNotAllowedException(beanName, &amp;#34;Singleton bean creation not allowed while the singletons of this factory are in destruction (Do not request a bean from a BeanFactory in a destroy method implementation!</description></item><item><title>Spring源码笔记-2.3 缓存中获取单例bean及获取对象</title><link>https://heeexy.com/posts/spring-note-11-getsingleton/</link><pubDate>Tue, 26 Sep 2017 23:28:00 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-11-getsingleton/</guid><description>缓存中获取单例bean getSingleton DefaultSingletonBeanRegistry 中实现此方法
//这个map维护了单例对象 private final Map&amp;lt;String, Object&amp;gt; singletonObjects = new ConcurrentHashMap(256); //当前正在创建中的单例对象 private final Set&amp;lt;String&amp;gt; singletonsCurrentlyInCreation = Collections.newSetFromMap(new ConcurrentHashMap(16)); //早期单例对象 private final Map&amp;lt;String, Object&amp;gt; earlySingletonObjects = new HashMap(16); //单例工厂? private final Map&amp;lt;String, ObjectFactory&amp;lt;?&amp;gt;&amp;gt; singletonFactories = new HashMap(16); protected Object getSingleton(String beanName, boolean allowEarlyReference) { Object singletonObject = this.singletonObjects.get(beanName); //如果根据这个beanName没取到对象,但发现这个对象还在创建中..... if (singletonObject == null &amp;amp;&amp;amp; this.isSingletonCurrentlyInCreation(beanName)) { Map var4 = this.singletonObjects; synchronized(this.singletonObjects) { singletonObject = this.earlySingletonObjects.get(beanName); //如果早期单例对象中没有此bean,并且允许早期依赖 if (singletonObject == null &amp;amp;&amp;amp; allowEarlyReference) { //当某些方法需要提前初始化的时候则会调用 addSingletonFactory方法将对应的ObjectFactory初始化策略存储在singletonFactories ObjectFactory&amp;lt;?</description></item><item><title>Spring源码笔记-2.2 FactoryBean</title><link>https://heeexy.com/posts/spring-note-10-factorybean/</link><pubDate>Tue, 26 Sep 2017 14:47:00 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-10-factorybean/</guid><description>package org.springframework.beans.factory; public interface FactoryBean&amp;lt;T&amp;gt; { //返回由FactoryBean创建的bean实例,如果isSingleton()返回true,则该实例会放到Spring容器中单实例缓存池中 T getObject() throws Exception; //返回FactoryBean创建的bean类型 Class&amp;lt;?&amp;gt; getObjectType(); //返回bean实例的作用域是singleton还是prototype boolean isSingleton(); } ​ 当配置文件的class属性配置的实现类是FactoryBean 时,通过getBean() 方法返回的不是FactoryBean 本身,而是FactoryBean.getObject() 方法所返回的对象.
​ 相当于FactoryBean.getObject() 代理了getBean() 方法.
​ 例如,如果使用传统方式配置Car的bean,Car的每个属性对应一个 元素标签
public class Car { private int maxSpeed; private String brand; private double price; //get/set } ​ 如果使用FactoryBean的方式就会灵活一些,下面通过逗号分隔符的方式一次性地为Car的所有属性指定配置值:
public class CarFactoryBean implements FactoryBean&amp;lt;Car&amp;gt; { private String carInfo; @Override public Car getObject() throws Exception { Car car = new Car(); String[] infos = carInfo.</description></item><item><title>Spring源码笔记-2.1 bean的加载初探</title><link>https://heeexy.com/posts/spring-note-9-beanload/</link><pubDate>Tue, 26 Sep 2017 11:16:00 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-9-beanload/</guid><description>本文要看啥? ​ 前面已经了解了bean从配置文件到解析成BDHolder到注册的流程,我们已经将bean的信息封装好,塞入了map中,这个map可能在不同的实现里面,前面重点学的就是DefaultListableBeanFactory里的beanDefinitionMap.
​ 我们现在要探索bean的加载,围绕最初的示例代码:
MyTestBean bean =(MyTestBean)bf.getBean(&amp;#34;myTestBean&amp;#34;); ​ BeanFactory是个接口,其下实现关系很复杂, getBean方法的实现主要是在AbstractBeanFactory 这一层.
​ 本文就是先来快速体验一下加载bean的大体流程
进入代码吧 protected &amp;lt;T&amp;gt; T doGetBean(String name, Class&amp;lt;T&amp;gt; requiredType, final Object[] args, boolean typeCheckOnly) throws BeansException { //转换beanName final String beanName = this.transformedBeanName(name); //根据beanName找其单例 Object sharedInstance = this.getSingleton(beanName); Object bean; if (sharedInstance != null &amp;amp;&amp;amp; args == null) { if (this.logger.isDebugEnabled()) { if (this.isSingletonCurrentlyInCreation(beanName)) { this.logger.debug(&amp;#34;Returning eagerly cached instance of singleton bean &amp;#39;&amp;#34; + beanName + &amp;#34;&amp;#39; that is not fully initialized yet - a consequence of a circular reference&amp;#34;); } else { this.</description></item><item><title>Spring源码笔记-1.6 自定义标签的解析</title><link>https://heeexy.com/posts/spring-note-8-custom-element/</link><pubDate>Tue, 19 Sep 2017 19:33:23 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-8-custom-element/</guid><description>自定义标签的使用 主要内容都在书上,p80
关键的部分为
创建XSD文件 创建类 继承AbstractSingleBeanDefinitionParser , 其继承关系最主要是实现了BeanDefinitionParser 接口,顾名思义,可以用来解析bean. 创建Handler文件, 继承自 NamespaceHandlerSupport ,目的是将上面的组件注册到Spring容器内 编写Spring.handlers 和 Spring.schemas文件. 这样,自定义的配置就结束了.
Spring加载自定义bean的流程主要就是遇到自定义标签后就去Spring.handlers和Spring.schemas中取找对应的handler 和 XSD .从而可以拿到parser
而代码里的主要步骤为
拿到标签对应的命名空间 根据命名空间找到对应的handler 调用handler的parse方法 获取标签的命名空间 调用org.w3c.dom.Node中的getNamespaceURI()
提取自定义标签处理器 NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); 这个resolve方法是接口,由DefaultNamespaceHandlerResolver 默认命名空间解析器来实现,其实现里面的第一步便是
Map&amp;lt;String, Object&amp;gt; handlerMappings = this.getHandlerMappings(); 原来handlerMappings 是个map,想必是在注册时肯定把解析器添加到这个map里面来,用namespaceUri做key,这样找的时候就很好找了.
取出结果如果是NamespaceHandler 便可以返回,往下读我们发现,之所以这么爽取出来就是handler,是因为已经做过这个解析,把找出的handler塞入了map,相当于是缓存了.
否则就是类名 className, 我们需要把它转为handler
//使用反射,将类路径转化为类 Class&amp;lt;?&amp;gt; handlerClass = ClassUtils.forName(className, this.classLoader); if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) { throw new FatalBeanException(&amp;#34;Class [&amp;#34; + className + &amp;#34;] for namespace [&amp;#34; + namespaceUri + &amp;#34;] does not implement the [&amp;#34; + NamespaceHandler.</description></item><item><title>Spring源码笔记-1.5 其它标签解析</title><link>https://heeexy.com/posts/spring-note-7-other-default-elements/</link><pubDate>Tue, 19 Sep 2017 19:33:04 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-7-other-default-elements/</guid><description>本文要看啥 之前我们看解析默认标签,从最核心的bean开始看的
private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) { if (delegate.nodeNameEquals(ele, &amp;#34;import&amp;#34;)) { this.importBeanDefinitionResource(ele); } else if (delegate.nodeNameEquals(ele, &amp;#34;alias&amp;#34;)) { this.processAliasRegistration(ele); } else if (delegate.nodeNameEquals(ele, &amp;#34;bean&amp;#34;)) { this.processBeanDefinition(ele, delegate); } else if (delegate.nodeNameEquals(ele, &amp;#34;beans&amp;#34;)) { this.doRegisterBeanDefinitions(ele); } } 现在主要就剩下alias和import啦, beans其实就是迭代解析.
alias标签的解析 为bean定义别名,除了之前我们接触过的
&amp;lt;bean id=&amp;#34;testBean&amp;#34; name=&amp;#34;aliasTestBean&amp;#34; class=&amp;#34;com.test&amp;#34;/&amp;gt; 还可以直接用alias标签
&amp;lt;alias name=&amp;#34;testBean&amp;#34; alias=&amp;#34;aliasTestBean&amp;#34;/&amp;gt; 解析步骤即使不看源码也知道很简单,因为之前我们已经深入研究过了SimpleAliasRegistry
校验 name alias 两个属性不能为空 this.getReaderContext().getRegistry().registerAlias(name, alias); 这个getRegistry() 然后registerAlias() 果然就是我们之前学过的SimpleAliasRegistry 里面的注册别名的方法.
impory标签的解析 import标签和bean标签一样是我们最常见的标签,对于分模块管理配置文件很关键.
解析步骤 取出并校验resource 属性作为地址location
将地址中的系统属性 如 &amp;ldquo;${user.dir}&amp;rdquo;
判断location是绝对路径还是相对路径</description></item><item><title>test_volatile_object</title><link>https://heeexy.com/posts/test-volatile-object/</link><pubDate>Mon, 18 Sep 2017 22:28:29 +0000</pubDate><guid>https://heeexy.com/posts/test-volatile-object/</guid><description>本文要看啥 先不细谈volatile的基本原理,在读(写)这篇文章时,都是假设我们已经粗略了解了一点volatile的原理和作用的,主要就是 &amp;ldquo;读写都走主内存,保证任意线程对这个变量的可见性&amp;rdquo;
在查看spring源码的时候,注意到spring在处理并发的操作List时, 虽然对list使用了volatile, 然而向list里面添加元素时,用的还是新建一个list,复制全部旧值,增加新元素,然后将旧的list地址指向新的list.
List&amp;lt;String&amp;gt; updatedDefinitions = new ArrayList(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); this.beanDefinitionNames = updatedDefinitions; 这么麻烦的操作,第一反应就是,volatile修饰的list, 直接添加元素依然不安全么?
去网上搜了一下相关问题, 参考博文地址 ,发现不止list, 对象也是一样的.
本文就是要来用代码直观地看看volatile 到底有什么效果,怎么用才有效果.
开始代码吧 线程共享对象里的boolean 注意代码要以**-server模式**运行，强制虚拟机开启优化
public class VolatileObjectTest implements Runnable { // 加上volatile 就可以正常结束While循环了 private ObjectA a; public VolatileObjectTest(ObjectA a) { this.a = a; } public void stop() { a.setFlag(false); } @Override public void run() { long i = 0; while (a.isFlag()) { i++; /** 注意这里的sysout,如果有调用的话,即使没有volatile,子线程也经常能拿到a.flag, 结合后面的测试,发现sysout 或者 sysout(a.</description></item><item><title>SimpleAliasRegistry</title><link>https://heeexy.com/posts/spring-note-5-simplealiasregistry/</link><pubDate>Fri, 15 Sep 2017 21:27:09 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-5-simplealiasregistry/</guid><description>功能:注册/存放别名
唯一成员变量为
private final Map&amp;lt;String, String&amp;gt; aliasMap = new ConcurrentHashMap(16); 这Map&amp;lt;String,String&amp;gt; 其实key是alias,value是name. 刚开始没注意可能搞反了呢
注册别名registerAlias() 举例来说 我们要注册的beanName为myTestBean , 别名为mtb
校验name和alias都不为空
如果name和alias一样,那map里删了这条name,结束
依据alias 即 mtb去map里面取已注册的name,如果真的有已注册过的话:
registeredName 和name相等的话,那就不用管,结束. 如果他俩不相等,这个工厂又不允许重写alias,那就抛异常! (allowAliasOverriding() 这个方法在SimpleAliasRegistry的子类里面有的会被重写. 如果前面都通过了,this.checkForAliasCircle(name, alias); 再次循环检查一遍,判断是否hasAlias(),如果是true的话,就报错,不是的话,走第5步. 具体hasAlias()流程如下:
循环找出registeredName 为myTestBean的那组键值对 (这里和上面的遍历不一样哦,这里是根据直接找重复的beanName的,上面是找重复的alias的 如果这个键值对的key即alias也是等于mtb的话,报错 (但是实际我们这第三步也查过这种情况) 如果这个myTestBean找出来的alias是&amp;quot;myTB&amp;quot;,那就还要走一遍hasAlias(&amp;quot;myTB&amp;quot;,&amp;quot;mtb&amp;quot;) ,换句话说,就是要看一看是不是有哪个bean名字叫myTB,别名叫mtb的,如果真的有,就返回true 第四步的hasAlias() 这种判断是啥意思呢?
想注册 mtb&amp;ndash;myTestBean (别名&amp;ndash;本名)
如果已存在 mtb&amp;ndash;myTestBean ,那么返回true
如果已存在 myTB&amp;ndash;myTestBean,
​ 且存在 mtb&amp;ndash;myTB ,
那就构成了 mtb&amp;ndash;myTB&amp;ndash;myTestBean 也返回true
如果已存在 myTB&amp;ndash;myTestBean,
​ 且存在 mta&amp;ndash;myTB
​ 且存在 mtb&amp;ndash;mta ,
那就构成了 mtb&amp;ndash;mta&amp;ndash;myTB&amp;ndash;myTestBean 还是返回true
.
这下看明白了吧,</description></item><item><title>Spring源码笔记-1.4 获取bean流程之注册BeanDefinition</title><link>https://heeexy.com/posts/spring-note-6-registerbeandefinition/</link><pubDate>Fri, 15 Sep 2017 21:26:00 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-6-registerbeandefinition/</guid><description>本文要看啥 这个bean总算是解析完了,也装饰完了,等于是说信息我们都提取好了,现在该做的就是去注册啦.
BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, this.getReaderContext().getRegistry()); 就是这个方法了
开始进入方法吧 public static void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException { String beanName = definitionHolder.getBeanName(); registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition()); String[] aliases = definitionHolder.getAliases(); if (aliases != null) { String[] var4 = aliases; int var5 = aliases.length; for(int var6 = 0; var6 &amp;lt; var5; ++var6) { String alias = var4[var6]; registry.registerAlias(beanName, alias); } } } 拿到beanName
用beanName和bd去registry里注册.
registry是个接口,具体的实现在4.3.7版本中看到两种,一种是SimpleBeanDefinitionRegistry里,和它名字一样非常简单,就是塞进map, 另外一种就复杂了,稍后我们再来看
用beanName和alias去registry里注册
注册aliases也是接口 ,BeanDefinitionRegistry还是继承自AliasRegistry的, 4.3.7只看到SimpleAliasRegistry一种实现
注册alias就简单多了, SimpleAliasRegistry里有
private final Map&amp;lt;String, String&amp;gt; aliasMap = new ConcurrentHashMap(16); 稍后我再另开一文把SimpleAliasRegistry来读一遍</description></item><item><title>Spring源码笔记-1.3 获取bean流程之解析bean标签中的自定义标签元素</title><link>https://heeexy.com/posts/spring-note-4-decoratebeandefinitionifrequired/</link><pubDate>Fri, 15 Sep 2017 21:24:00 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-4-decoratebeandefinitionifrequired/</guid><description>本文要看啥 protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) { BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) { bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try { BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, this.getReaderContext().getRegistry()); } catch (BeanDefinitionStoreException var5) { this.getReaderContext().error(&amp;#34;Failed to register bean definition with name &amp;#39;&amp;#34; + bdHolder.getBeanName() + &amp;#34;&amp;#39;&amp;#34;, ele, var5); } this.getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); } } 前面的笔记中,我们已经走完了这个方法中的第一步,感觉第一步就走了很远,眼瞅要迷路了,但无论如何,总归是拿到了我们的bdHolder, 里面已经存放了Bean标签里面的默认的元素.
如果bdHolder不为空的话,我们可以继续往下走啦.
今天来研究下这段代码
bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); 看方法名字就大概知道,这里要做的事情就是 如果有需要的话,装饰我们刚拿到的bdHolder.
那么何为需要呢?下面这样的场景便是了
&amp;lt;bean id=&amp;#34;test&amp;#34; class=&amp;#34;test.myClass&amp;#34;&amp;gt; &amp;lt;mybean:user username=&amp;#34;aaa&amp;#34;/&amp;gt; &amp;lt;/bean&amp;gt; 这里的自定义标签和
&amp;lt;mvc:resources mapping=&amp;#34;/img/**&amp;#34; location=&amp;#34;img/&amp;#34;/&amp;gt; &amp;lt;aop:config/&amp;gt; &amp;lt;tx:advice id=&amp;#34;transactionAdvice&amp;#34; transaction-manager=&amp;#34;transactionManager&amp;#34;/&amp;gt; 并不同,这里的是在bean内的, 而mvc那种标签是在beans里面,与bean同级的</description></item><item><title>ConstructorArgumentValues 构造器参数值保存器</title><link>https://heeexy.com/posts/spring-note-3-constructorargumentvalues/</link><pubDate>Thu, 14 Sep 2017 21:10:33 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-3-constructorargumentvalues/</guid><description>private final Map&amp;lt;Integer, ConstructorArgumentValues.ValueHolder&amp;gt; indexedArgumentValues = new LinkedHashMap(0); private final List&amp;lt;ConstructorArgumentValues.ValueHolder&amp;gt; genericArgumentValues = new LinkedList(); 这个保存器的核心就在他的LinkedHashMap和LinkedList
疑问: 这里为什么选用linked来储存呢?
答:
添加有index的关键代码如下
private void addOrMergeIndexedArgumentValue(Integer key, ConstructorArgumentValues.ValueHolder newValue) { //拿当前这个位置的值 ConstructorArgumentValues.ValueHolder currentValue = (ConstructorArgumentValues.ValueHolder)this.indexedArgumentValues.get(key); //如果当前位置有值,并且新值是接受合并的话,那合并一波之后作为新值 //如果不接受合并的话,那扔了之前的value不管了,只用新来的value if (currentValue != null &amp;amp;&amp;amp; newValue.getValue() instanceof Mergeable) { Mergeable mergeable = (Mergeable)newValue.getValue(); if (mergeable.isMergeEnabled()) { newValue.setValue(mergeable.merge(currentValue.getValue())); } } //将新值放入LinkedHashMap this.indexedArgumentValues.put(key, newValue); } 疑问:在获取vh之前我们不就验证过index不能重复么?为什么这里还有可能搞一波合并?是有其它地方也调用这个方法,那里可以合并?
答: 注意到这个类里有个方法,addArgumentValues(ConstructorArgumentValues other),貌似就是专门和其它CAV搞合并的,用CAV做构造参数的那个构造器调用了此方法,这里会有可能需要合并
添加没有index的参数
public void addGenericArgumentValue(ConstructorArgumentValues.ValueHolder newValue) { //校验不为空 Assert.notNull(newValue, &amp;#34;ValueHolder must not be null&amp;#34;); //如果list内已经含有此value则跳过 if (!</description></item><item><title>Spring源码笔记-1.2 获取bean流程之bean标签的解析及注册</title><link>https://heeexy.com/posts/spring-note-2/</link><pubDate>Tue, 12 Sep 2017 21:41:09 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-2/</guid><description>1.解析BeanDefinition BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); 作用就是将element封装进bdHolder里面.
其源码很长,不贴了,但功能流程还很清晰
处理id,name,aliases. 关键是需要beanName ,
name分隔开做aliases的list.
beanName优先用id,没id的话就从aliases里remove(0)出来一个,
如果有beanName了,校验beanName和aliases唯一性
​ 如果还是没beanName,等会再给它用方法生成个
将element解析,放入GenericBeanDefinition里面 把上一步拿到的bd连带着aliases转String[], beanName一起封装一下成为BeanDefinitionHolder返回;如果上一步返回null,就直接返回null 这里的关键步骤显然是第二步,element转beanDefinition
AbstractBeanDefinition beanDefinition = this.parseBeanDefinitionElement(ele, beanName, containingBean); 这个方法也很长,大概步骤是
this.parseState.push(new BeanEntry(beanName)) 开头push,结尾pop,不明白是做什么??? 获取下className和parent 拿着className和parent去创建个GenericBeanDefinition bd 拿着bd和element进行一系列的解析步骤,把各种值塞入bd 返回bd this.parseState.pop(); 解析各种属性 this.parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); 这个方法的代码丧心病狂地达到了70行,相比于目前读到的其它源码,确实是最长的一个.
但是里面的内容其实并不复杂,就是一个个地从element拿属性,塞属性进bd, 各种 get &amp;amp; set .感觉确实不太好重构.
解析了很多属性,包括scope,abstract,lazy-init,autowire&amp;hellip;
解析子元素meta 解析子元素lookup-method 解析方法和meta差别很小,这里主要是去了解下lookup-method的功能
&amp;lt;bean class=&amp;#34;beanClass&amp;#34;&amp;gt; &amp;lt;lookup-method name=&amp;#34;method&amp;#34; bean=&amp;#34;non-singleton-bean&amp;#34;/&amp;gt; &amp;lt;/bean&amp;gt; method是beanClass中的一个方法，beanClass和method是不是抽象都无所谓，不会影响CGLIB的动态代理，根据项目实际需求去定义。non-singleton-bean指的是lookup-method中bean属性指向的必须是一个非单例模式的bean，当然如果不是也不会报错，只是每次得到的都是相同引用的bean（同一个实例），这样用lookup-method就没有意义了。
参考: Spring - lookup-method方式实现依赖注入
解析子元素replaced-method 这个不仅可以动态地替换返回实体bean,而且还能动态地更改原有方法的逻辑!!!
解析子元素constructor-arg 这里提取构造参数的一些属性值就相比之前复杂多了.
提取index,type,name,判断是否有index属性值 如果有index: 构造Entry压入parseState栈 解析constructor-arg的子元素 使用ConstructorArgumentValues.</description></item><item><title>Spring源码笔记-1.1 获取bean流程之容器的基本实现</title><link>https://heeexy.com/posts/spring-note-1/</link><pubDate>Mon, 11 Sep 2017 20:31:00 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-1/</guid><description>以通过BeanFactory获取bean为例学习,实际项目中更多是使用ApplicationContext
1.读取配置文件 beanFactoryTest.xml
2.通过文件资源获取工厂
3.从工厂中拿bean
读配置 配置文件封装 ClassPathResource类 继承&amp;ndash;AbstractFileResolvingResource
​ 继承&amp;ndash;AbstractResource
​ 实现&amp;ndash;Resource
​ 继承&amp;ndash;InputStreamSource接口 唯一方法: getInputStream()
Resource接口提供了一系列方法来封装底层资源,比如 exists() isReadable() getURL() getFile() getDescription() 等等
XmlBeanFactory的实例化 大概步骤 public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException { super(parentBeanFactory);//1.设置父工厂(null)...本例未使用到此 this.reader = new XmlBeanDefinitionReader(this);//2.实例化XmlBeanDefinitionReader, 注册到此工厂 this.reader.loadBeanDefinitions(resource);//3.重要部分,通过resource来加载beanDefinations,bean的一些定义 } loadBeanDefinitions(resource)方法就是下面的主要要看的
它做了几件事:
将resource用EncodedResource包装一下,编码要用, 本例没特定的charset和encoding因此都是null 获取当前正在加载的资源集 Set currentResources ,如果currentResources 是null 就初始化个 new HashSet(4), 然后将我们要读的encodedResource加到这个set里面去 如果返回false说明正在加载这个xml了,报个错,不继续往下读了
当读完这个资源后,在finally里面会从set里移出这个encodedResource,如果set空了,还会remove这个currentResources,
这个set是放ThreadLocal里面的,
private final ThreadLocal&amp;lt;Set&amp;gt; resourcesCurrentlyBeingLoaded;
是线程安全的,功能是防止同时循环加载同一个xml文件
从encodedResouce里取出文件的inputStream 拿去初始化个InputSource(有enconding的话,给inputSource也设个编码,本例为null)然后 inputSource和encodedResouce里面的resouce一起拿去执行doLoadBeanDefinitions(..)方法,稍后重点讲 var5 = this.doLoadBeanDefinitions(inputSource, encodedResource.</description></item><item><title>Lantern配置</title><link>https://heeexy.com/posts/lantern%E9%85%8D%E7%BD%AE/</link><pubDate>Thu, 03 Aug 2017 13:45:14 +0000</pubDate><guid>https://heeexy.com/posts/lantern%E9%85%8D%E7%BD%AE/</guid><description>第一步:飞跃长城
预备工作 下载安装 chrome
下载安装 lantern
下载安装 switchyOmega
配置代理 启动lantern.exe, 如果已启动过,也可以从右下角托盘中找到lantern图标,右击,显示蓝灯,此时浏览器会显示蓝灯的页面
找到本机蓝灯的端口,按下图步骤找到标注出的127.0.0.1:56939
​
​
右击chrome右上方安装好的switchyOmega的插件图标,点击选项
进入配置页面.在左侧菜单栏找到 新建情景模式,情景模式名称随意填写,比如就叫蓝灯,创建.
编辑刚才创建的情景模式,如下图配置
代理协议http
代理服务器127.0.0.1
代理端口 (填写你自己在第2步找到的端口号,本例是56939)
![](http://ots7yt7am.bkt.clouddn.com/blog/20170803144056.png) 屏幕左下角**应用选项** ,配置完成 成功翻墙 打开Google 页面, 左击 选中情景模式为蓝灯 ,此时应该已经可以成功翻墙了!
蓝灯模式适用翻墙,浏览国内网站时可以改为直接连接.
当然有方便的自动切换代理的功能啦!
但是你已经身在墙外了,自己搜搜吧!</description></item><item><title>Elasticsearch 2.3升级至6.3</title><link>https://heeexy.com/posts/updgradeelasticsearch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heeexy.com/posts/updgradeelasticsearch/</guid><description>集群管理 节点分配 原集群 master*3 data*12 client*0
新集群 master*3 data*12 injest*0 coordinating*0
ingest 节点用于支持 pipeline 操作 对bulk和index文档进行预处理
coordinating 功能主要是分发请求,聚合各节点的处理结果,负载均衡,大规模集群可以设置一个给读,一个给写。但coordinating 数量也不宜过多,会拖慢选举主节点的时间,并且data节点其实也可以处理这些请求.
节点设置 search.remote.connect: false node.ingest: false
数据迁移 数据源 由于有数据源及同步方案,所以只需数据全量导入6.3版本的集群即可.
索引管理 目前生产环境有300个索引需要同步,要检查同步脚本的创建索引,切别名等步骤.
mapping设置 type 只支持1种，自 ES7.0 起将不再支持 type&amp;mdash;官方说明 对可以使用自增 id 的索引使用自增 id 对大多数字符串字段使用 keyword 类型 对不用于数值范围查找的数值类型改为keyword类型 分词插件可能需要改动 index: no 改为 index:false index: not_analyzed 删掉 提高迁移速度 sudo swapoff -a 副本设置为0 refresh_interval 设置为 -1 （对线上生产集群上索引批量导入时，设置-1后，重新打开时可能会导致集群压力暴增） 导入数据 refresh_interval 设置为30 确认数据正确性 POST /_forcemerge max_num_segments=1（对于大索引可能非常耗时） 副本设置为1 scala项目升级 scala &amp;amp; play 升级, 尤其是play的升级会导致大量代码改动 elastic4s 依赖升级，注意除了core包还需要http包 。 原本的获取client, 构建dsl,excute,解析response的大量代码要修改，尤其是构建dsl涉及大量业务，需要逐一比对修改。 监控 Prometheus + Grafana 主要是获取ES信息的api随之升级，改动通常不大</description></item><item><title>Elasticsearch在高并发复杂查询业务场景的应用</title><link>https://heeexy.com/posts/elasticsearch-for-search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heeexy.com/posts/elasticsearch-for-search/</guid><description>说起 Elasticsearch，往往大家想到的都是 ELK 的一套，但是作为 NoSQL，ES 有极快的响应速度，强大的聚合功能，支持复杂的查询条件，应对高并发的复杂查询的业务场景其实也是非常强力的。
You Know, for Search
我们团队就一直使用 ES 作为主力数据库， 从一开始做全文检索，到现在承担全部的商品列表页查询。近几个月将查询系统的 qps 从 1k 优化到了 10k+，其中 ES 的优化占了很重要一部分，准确的来说，应该是对 ES 特性的扬长避短起到了非常大的作用。
数组 &amp;amp; 嵌套结构 ES 没有 join，很多人直接就会认为 ES 无法处理一对多的情况，其实还有数组和嵌套结构可以应付常见的业务场景。
比如一个商品拥有多种属性，都存放在一个数组字段中，使用 must 和 must_not 就可以灵活地进行查询筛选。
比如同款不同色的几件T恤，使用嵌套结构保存，搜索时只需要其中一件满足筛选条件，便可以全部带出来，在页面上以多个小色块展示，而无需占用多个展示位。并且还可以拿满足筛选条件的商品中的某属性最大值/最小值等进行排序，如官网给出的示例:
{ &amp;#34;query&amp;#34;: { &amp;#34;nested&amp;#34;: { &amp;#34;path&amp;#34;: &amp;#34;parent&amp;#34;, &amp;#34;query&amp;#34;: { &amp;#34;bool&amp;#34;: { &amp;#34;must&amp;#34;: {&amp;#34;range&amp;#34;: {&amp;#34;parent.age&amp;#34;: {&amp;#34;gte&amp;#34;: 21}}}, &amp;#34;filter&amp;#34;: { &amp;#34;nested&amp;#34;: { &amp;#34;path&amp;#34;: &amp;#34;parent.child&amp;#34;, &amp;#34;query&amp;#34;: {&amp;#34;match&amp;#34;: {&amp;#34;parent.child.name&amp;#34;: &amp;#34;matt&amp;#34;}} } } } } } }, &amp;#34;sort&amp;#34; : [ { &amp;#34;parent.</description></item><item><title>MemSQL简介</title><link>https://heeexy.com/posts/memsql/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://heeexy.com/posts/memsql/</guid><description>为什么要看MemSQL 因为 MemSQL 自称突出一个快！而我们团队的数据平台正需要一个ms级别查询的数据库，因此花了一点时间来调研 MemSQL 。
初体验结果 MemSQL与我们期望的ms级别查询相差甚远，最简单的查询也通常是500ms返回，并不能应对线上的高并发实时查询系统。秒级查询已经有presto等各种大数据组件，对于我们团队已经没有理由再来深入使用MemSQL。
MemSQL 其实有很多优点，有完善的文档，精致的页面管理工具，方便的安装，甚至一键导入大量数据来方便用户体验 （就差把sql的耗时贴出来了，要是贴出来就省了我调研的时间了），可惜在同一梯队还有太多免费、开源、有活跃社区的竞争对手。
特点 MemSQL属于商业公司，免费4 units. (每8核32G 为1 unit)，不开源 自带portal界面管理，MemSQL Studio，自带安装工具 完全支持mysql语法，jdbc，增删改查 支持 in-memory rowstore &amp;amp;&amp;amp; on-disk columnstore 大吞吐量数据写入(loading TPC-H SF100 (approximately 100 GBs of row files) will take around four minutes) exactly-once aggregator节点运行sql，聚合结果；leaf节点存储&amp;amp;处理数据 数据导入 file , 指定分隔符 Streaming (Kafka , S3 , Azure Blob , Filesystem) 通过Pipelines MySQL (sql文件) 选择 shard key (类似ES的routing) Using a column or set of columns unique enough to minimize skew.</description></item></channel></rss>