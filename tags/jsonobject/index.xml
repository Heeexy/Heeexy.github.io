<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>JSONObject on 网站标题</title><link>https://heeexy.com/tags/jsonobject/</link><description>Recent content in JSONObject on 网站标题</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 04 Jan 2018 21:22:33 +0000</lastBuildDate><atom:link href="https://heeexy.com/tags/jsonobject/index.xml" rel="self" type="application/rss+xml"/><item><title>MyBatis 对未知数据类型的转换(二)TypeHandlerRegistry</title><link>https://heeexy.com/posts/typehandlerregistry/</link><pubDate>Thu, 04 Jan 2018 21:22:33 +0000</pubDate><guid>https://heeexy.com/posts/typehandlerregistry/</guid><description>问题 上一篇我们讲到，对于未知数据类型的解析，UnknownTypeHandler 把部分任务交给了 TypeHandlerRegistry ,甚至可能仅仅只丢了一个 javaType 过来就要求返回一个合适的解析器回去 。TypeHandlerRegistry 到底里面做了啥可以找到合适的解析器呢？
功能 从类的名字我们就知道这个类的功能大概就是个注册表，而且很可能是全局共用的，记录各种 javaType,jdbcType,TypeHandler 的映射关系。实际这个类的核心也就是维护了几个 map 。
核心字段 JDBC_TYPE_HANDLER_MAP private final Map&amp;lt;JdbcType, TypeHandler&amp;lt;?&amp;gt;&amp;gt; JDBC_TYPE_HANDLER_MAP = new EnumMap&amp;lt;JdbcType, TypeHandler&amp;lt;?&amp;gt;&amp;gt;(JdbcType.class); 这个很直观，就是注册 jdbcType 和解析器的对应关系。
TYPE_HANDLER_MAP private final Map&amp;lt;Type, Map&amp;lt;JdbcType, TypeHandler&amp;lt;?&amp;gt;&amp;gt;&amp;gt; TYPE_HANDLER_MAP = new ConcurrentHashMap&amp;lt;Type, Map&amp;lt;JdbcType, TypeHandler&amp;lt;?&amp;gt;&amp;gt;&amp;gt;(); 书上原文是：“记录了 java 类型向指定的 JdbcType 转换时，需要使用的 TypeHandler 对象。例如：Java 类型中的 String 转换成数据库的 char 、varchar 等多种类型，所以存在一对多关系”。
Type 是 java.lang.reflect 包下的接口，Class 类实现了此接口。所以此 map 的 key 值是 javaType ,比如 String.class 。
UNKNOWN_TYPE_HANDLER 就是上一篇文章学习过的 UnknownTypeHandler 的实例，主要用在 Object.</description></item><item><title>MyBatis 对未知数据类型的转换(一)TypeHandler</title><link>https://heeexy.com/posts/mybatis%E5%AF%B9%E6%9C%AA%E7%9F%A5%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/</link><pubDate>Tue, 02 Jan 2018 22:35:52 +0000</pubDate><guid>https://heeexy.com/posts/mybatis%E5%AF%B9%E6%9C%AA%E7%9F%A5%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/</guid><description>问题 前面说到，我们可以用 JSONObject 替代习惯使用的 JavaBean ，而之所以能用 JSONObject 主要就是因为它实现了 Map&amp;lt;String,Object&amp;gt; 。
实际使用我们就会发现，MyBatis 使用JSONObject 封装返回结果的时候很“智能”，数据库里字段是 varchar 类型，JSONObject 中返回值就是 String 类型，数据库字段是 int/float 类型，JSONObject 中返回值就是对应的数值类型。甚至通过 debug 发现数据库中保存了datetime 类型的数据，JSONObject 中保存的是 java.sql.timestamp 类型，而timestamp 类型继承了常见的 java.util.Date 。
为什么 MyBatis 可以用得这么爽呢？我们实现可完全没声明需要此字段的 javaType 呢。而且用得爽了，类型转换会不会导致程序性能大打折扣呢？
今天我们就从深入源码，探究一番 MyBatis 到底是怎样做到对未明确声明的字段处理返回类型的。
TypeHandler MyBatis 类型转换的核心就是这个接口，定义的方法可以看做就两种 setParameter 和 getResult ,很好理解，我们传参和接收 sql 结果时就调用这个。
public interface TypeHandler&amp;lt;T&amp;gt; { void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException; T getResult(ResultSet rs, String columnName) throws SQLException; T getResult(ResultSet rs, int columnIndex) throws SQLException; T getResult(CallableStatement cs, int columnIndex) throws SQLException; } 抽象类 BaseTypeHandler 部分实现了 TypeHandler ,主要完成了对空值的处理。 非空值的处理全部交给了子类完成。</description></item><item><title>MyBatis 中使用 JSONObject 处理一对多结果</title><link>https://heeexy.com/posts/one2many/</link><pubDate>Sun, 31 Dec 2017 12:11:29 +0000</pubDate><guid>https://heeexy.com/posts/one2many/</guid><description>问题 在上一文介绍了 JSONObject 接受 MyBatis 的结果集的简单用法，但是在处理一对多的情况时，单纯的JSONObject就不好使了。
比如要查询一个角色下的多个用户，resultMap如下定义
&amp;lt;resultMap id=&amp;#34;roleMap&amp;#34; type=&amp;#34;com.alibaba.fastjson.JSONObject&amp;#34;&amp;gt; &amp;lt;id column=&amp;#34;roleId&amp;#34; property=&amp;#34;roleId&amp;#34;/&amp;gt; &amp;lt;result column=&amp;#34;roleName&amp;#34; property=&amp;#34;roleName&amp;#34;/&amp;gt; &amp;lt;collection property=&amp;#34;users&amp;#34; ofType=&amp;#34;com.alibaba.fastjson.JSONObject&amp;#34;&amp;gt; &amp;lt;id column=&amp;#34;userId&amp;#34; property=&amp;#34;userId&amp;#34;/&amp;gt; &amp;lt;result column=&amp;#34;nickname&amp;#34; property=&amp;#34;nickname&amp;#34;/&amp;gt; &amp;lt;/collection&amp;gt; &amp;lt;/resultMap&amp;gt; 期望查出来的users 属性对应着一个数组,
然而实际查出来只是一个对象，只有一条数据。
解决方案 只需要建一个实体类继承 JSONObject ,里面有你要的集合类型的成员变量，就足够了。
比如我建的 One2Many 类：
public class One2Many extends JSONObject { private List&amp;lt;JSONObject&amp;gt; users; } 然后xml改为
&amp;lt;resultMap id=&amp;#34;roleMap&amp;#34; type=&amp;#34;com.heeexy.example.util.model.One2Many&amp;#34;&amp;gt; &amp;lt;id column=&amp;#34;roleId&amp;#34; property=&amp;#34;roleId&amp;#34;/&amp;gt; &amp;lt;result column=&amp;#34;roleName&amp;#34; property=&amp;#34;roleName&amp;#34;/&amp;gt; &amp;lt;collection property=&amp;#34;users&amp;#34; ofType=&amp;#34;com.alibaba.fastjson.JSONObject&amp;#34;&amp;gt; &amp;lt;id column=&amp;#34;userId&amp;#34; property=&amp;#34;userId&amp;#34;/&amp;gt; &amp;lt;result column=&amp;#34;nickname&amp;#34; property=&amp;#34;nickname&amp;#34;/&amp;gt; &amp;lt;/collection&amp;gt; &amp;lt;/resultMap&amp;gt; 是不是非常简单？
更棒的是，这个 One2Many 类是可以复用的，里面再添加其它的成员变量就 OK 了。而且 Dao 层不需要改动，外面正常的还是用 JSONObject 就可以了。</description></item><item><title>MyBatis 中使用 JSONObject 替代 JavaBean</title><link>https://heeexy.com/posts/mybatis%E4%B8%AD%E4%BD%BF%E7%94%A8jsonobject%E6%9B%BF%E4%BB%A3javabean/</link><pubDate>Sat, 30 Dec 2017 21:51:55 +0000</pubDate><guid>https://heeexy.com/posts/mybatis%E4%B8%AD%E4%BD%BF%E7%94%A8jsonobject%E6%9B%BF%E4%BB%A3javabean/</guid><description>问题背景 项目后端与前端全部使用 JSON 进行数据交互，比如查询用户列表，通常后端从数据库查出的数据放入实体类再转为 JSON 返回给前端，但是前端的小伙伴表示明明只需要 nickname,avatar,userId 三个字段，为什么传过来的数据多出 phone,address ,profile 之类十几个字段，里面都 null,0 等值？
其实是因为 User 实体类定义了太多字段，转为 JSON 的时候都被包括进去了。稍微多几个还能忍，但通常 User/Order 这些实体类字段特别多，对调试开发实在非常不友好。
因此本次任务就是：确保每个接口返回字段都与接口文档上一模一样，去除冗余字段。
解决过程就省略了，直接抛出我最后的解决方案吧：就是 MyBatis 的返回值几乎完全抛弃实体类，全部使用com.alibaba.fastjson.JSONObject 。
使用 JSONObject 先最简化直观的看一下 JSONObject 的使用吧。
Controller:
@GetMapping(&amp;#34;/list&amp;#34;) public JSONObject listUser(@RequestBody JSONObject requestJson){ return userService.listUser(requestJson); } Service:
JSONObject listUser(JSONObject jsonObject); ServiceImpl:
@Override public JSONObject listUser(JSONObject jsonObject) { //fillPageParam是自定义的封装分页参数 CommonUtil.fillPageParam(jsonObject); int count = userDao.countUser(jsonObject); List&amp;lt;JSONObject&amp;gt; list = userDao.listUser(jsonObject); //自定义successPage封装分页结果 return CommonUtil.successPage(jsonObject, list, count); } Dao:
public interface UserDao { int countUser(JSONObject jsonObject); List&amp;lt;JSONObject&amp;gt; listUser(JSONObject jsonObject); } UserMapper.</description></item></channel></rss>