<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on 网站标题</title><link>https://heeexy.com/tags/java/</link><description>Recent content in Java on 网站标题</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 03 Feb 2020 19:57:00 +0000</lastBuildDate><atom:link href="https://heeexy.com/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>JDBC为什么不需要Class.forName()</title><link>https://heeexy.com/posts/drivermaneger/</link><pubDate>Mon, 03 Feb 2020 19:57:00 +0000</pubDate><guid>https://heeexy.com/posts/drivermaneger/</guid><description>&lt;h3 id="drivermanager">
&lt;a href="#drivermanager" class="header-anchor">#&lt;/a>
DriverManager
&lt;/h3>&lt;p>在初学JDBC时，总是记得开头就要来这么一句&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Class.&lt;span style="color:#a6e22e">forName&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;com.mysql.jdbc.Driver&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然而今天学习类加载机制时偶然知道不需要这句也同样可以正常运行，测试的确如此，看了一眼源码，看似原因很简单，因为无论写不写那段&lt;code>Class.forName&lt;/code>，在触发加载DriverManager时，会运行&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Load the initial JDBC drivers by checking the System property
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * jdbc.properties and then use the {@code ServiceLoader} mechanism
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loadInitialDrivers();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;JDBC DriverManager initialized&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>都会扫描到这个Driver，注册到&lt;code>registeredDrivers&lt;/code>中。&lt;/p>
&lt;hr>
&lt;p>如果只要回答这个问题，可能上面的答案就已经足够了。&lt;/p>
&lt;p>然而兴趣来了，总想把源码继续看下去到底扫描了啥，咋扫描的，明明&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>ServiceLoader&lt;span style="color:#f92672">&amp;lt;&lt;/span>Driver&lt;span style="color:#f92672">&amp;gt;&lt;/span> loadedDrivers &lt;span style="color:#f92672">=&lt;/span> ServiceLoader.&lt;span style="color:#a6e22e">load&lt;/span>(Driver.&lt;span style="color:#a6e22e">class&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里是 &lt;code>java.sql.Driver&lt;/code> 接口，上哪找出来的实现类？&lt;/p>
&lt;p>我们就一层层的往下看吧。&lt;/p>
&lt;h3 id="serviceloader">
&lt;a href="#serviceloader" class="header-anchor">#&lt;/a>
ServiceLoader
&lt;/h3>&lt;p>主要做了两点&lt;/p>
&lt;ol>
&lt;li>设置ClassLoader为当前线程的。（破坏双亲委派，让它rt.jar包中的类可以通过AppClassLoader获取到外部的类，很多讲双亲委派机制的文章已经大书特书过了）&lt;/li>
&lt;li>初始化了一个懒加载的迭代器 &lt;code>lookupIterator = new LazyIterator(service, loader);&lt;/code>。正是这个迭代器中最终帮我们找到了各种driver注册进去。&lt;/li>
&lt;/ol>
&lt;h3 id="lazyiterator">
&lt;a href="#lazyiterator" class="header-anchor">#&lt;/a>
LazyIterator
&lt;/h3>&lt;p>既然是迭代器，最重要的当然是hasNext()和next()方法。&lt;/p>
&lt;p>在next()方法中，已经拿到了nextName完整的&amp;quot;com.mysql.cj.jdbc.Driver&amp;quot;类名，说明还是hasNext()方法干了真正的扫描工作。&lt;/p>
&lt;p>hasNext()方法的主要工作也都放在了hasNextService()中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">hasNextService&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (nextName &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (configs &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//此处拼出了全名为 META-INF/services/java.sql.Driver&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String fullName &lt;span style="color:#f92672">=&lt;/span> PREFIX &lt;span style="color:#f92672">+&lt;/span> service.&lt;span style="color:#a6e22e">getName&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (loader &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configs &lt;span style="color:#f92672">=&lt;/span> ClassLoader.&lt;span style="color:#a6e22e">getSystemResources&lt;/span>(fullName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configs &lt;span style="color:#f92672">=&lt;/span> loader.&lt;span style="color:#a6e22e">getResources&lt;/span>(fullName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (IOException x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fail(service, &lt;span style="color:#e6db74">&amp;#34;Error locating configuration files&amp;#34;&lt;/span>, x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ((pending &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#f92672">!&lt;/span>pending.&lt;span style="color:#a6e22e">hasNext&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>configs.&lt;span style="color:#a6e22e">hasMoreElements&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pending &lt;span style="color:#f92672">=&lt;/span> parse(service, configs.&lt;span style="color:#a6e22e">nextElement&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nextName &lt;span style="color:#f92672">=&lt;/span> pending.&lt;span style="color:#a6e22e">next&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>看起来不算复杂，我们拿着&amp;quot;META-INF/services/java.sql.Driver&amp;quot;去AppClassLoader找个configs。&lt;/p>
&lt;p>但是debug的时候并不直观，因为debug的时候看到config似乎包含了各层类加载器扫出来的几十个jar包，然而到configs.nextElement()时突然就直接拿到了&lt;code>jar:file:/C:/Users/dell/.m2/repository/mysql/mysql-connector-java/8.0.13/mysql-connector-java-8.0.13.jar!/META-INF/services/java.sql.Driver&lt;/code>的完整路径。最后发现实在是源码作者太喜欢实现hasNext()和next()方法（&lt;code>hasMoreElements&lt;/code>和&lt;code>nextElement&lt;/code>）了，一层又一层的把人看晕了。&lt;/p>
&lt;p>我们先跟进这段代码&lt;code> configs = loader.getResources(fullName);&lt;/code>，看configs是如何拿到的吧。&lt;/p>
&lt;h3 id="classloader">
&lt;a href="#classloader" class="header-anchor">#&lt;/a>
ClassLoader
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> Enumeration&lt;span style="color:#f92672">&amp;lt;&lt;/span>URL&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">getResources&lt;/span>(String name) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@SuppressWarnings&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;unchecked&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Enumeration&lt;span style="color:#f92672">&amp;lt;&lt;/span>URL&lt;span style="color:#f92672">&amp;gt;[]&lt;/span> tmp &lt;span style="color:#f92672">=&lt;/span> (Enumeration&lt;span style="color:#f92672">&amp;lt;&lt;/span>URL&lt;span style="color:#f92672">&amp;gt;[]&lt;/span>) &lt;span style="color:#66d9ef">new&lt;/span> Enumeration&lt;span style="color:#f92672">&amp;lt;?&amp;gt;[&lt;/span>2&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (parent &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tmp&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> parent.&lt;span style="color:#a6e22e">getResources&lt;/span>(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tmp&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> getBootstrapResources(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//AppClassLoader和ExtClassLoader都是调用父类URLClassLoader的findResources方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tmp&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> findResources(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CompoundEnumeration&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>(tmp);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>遵循了双亲委派机制，先向上找parent，一直找到顶部的Bootstrap启动类加载器。再向下一直找到自身类加载器。 当然此处由于可以返回多层结果，因此返回的最终是&lt;code>CompoundEnumeration&lt;/code> 组合的结果，而不是单条数据。&lt;/p>
&lt;p>后面我们会看到，不同的实现的Enumeration的&lt;code>hasMoreElements&lt;/code>和&lt;code>nextElement&lt;/code>真是花里胡哨。用&lt;code>Enumeration&amp;lt;URL&amp;gt;&lt;/code> 这个看似最简单的只有两个方法的&lt;code>Interface&lt;/code>作为返回类型，真是给作者玩出花来了。&lt;/p>
&lt;p>三层找的结果如下图。&lt;/p>
&lt;p>&lt;img src="http://img.heeexy.com/BootstrapResouces.png"
loading="lazy"
>&lt;/p>
&lt;p>&lt;img src="http://img.heeexy.com/ExtResouces.png"
loading="lazy"
>&lt;/p>
&lt;p>&lt;img src="http://img.heeexy.com/AppResources.png"
loading="lazy"
>&lt;/p>
&lt;p>debug看完三层扫描的结果，三层类加载器一共扫了一百多个jar包出来，貌似没毛病，但是明明我传了name进去找resource的啊，如果你要返回全部jar包，还要我传name干啥？要是遍历一百多个jar包的话，&lt;code>pending = parse(service, configs.nextElement());&lt;/code>这要遍历一百多次去找&lt;code>java.sql.Driver&lt;/code>的实现类？&lt;/p>
&lt;p>但是debug到&lt;code>configs.nextElement()&lt;/code>时突然就直接拿到了&lt;code>jar:file:/C:/Users/dell/.m2/repository/mysql/mysql-connector-java/8.0.13/mysql-connector-java-8.0.13.jar!/META-INF/services/java.sql.Driver&lt;/code>的完整路径。我们先看一眼这个jar包中的内容，&lt;/p>
&lt;p>&lt;img src="http://img.heeexy.com/TargetDriverMetaInf.png"
loading="lazy"
>&lt;/p>
&lt;p>的确这就是我们要找的jar包和配置文件，里面写明了我们要注册的Driver的实现类就是&amp;quot;com.mysql.cj.jdbc.Driver&amp;quot;。&lt;/p>
&lt;p>那这到底是什么时候遍历出来的呢？看来返回的这个&lt;code>configs&lt;/code>中间大有玄机，我们继续跟进它的&lt;strong>迭代&lt;/strong>的方法。&lt;/p>
&lt;h3 id="urlclassloader">
&lt;a href="#urlclassloader" class="header-anchor">#&lt;/a>
URLClassLoader
&lt;/h3>&lt;p>AppClassLoader和ExtClassLoader都是继承于URLClassLoader，且它们的&lt;code>findResources&lt;/code>方法都是使用父类的。&lt;/p>
&lt;p>而URLClassLoader的这个方法的核心又是调用URLClassPath的&lt;code>findResources&lt;/code>方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Enumeration&lt;span style="color:#f92672">&amp;lt;&lt;/span>URL&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">findResources&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> String name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throws&lt;/span> IOException
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> Enumeration&lt;span style="color:#f92672">&amp;lt;&lt;/span>URL&lt;span style="color:#f92672">&amp;gt;&lt;/span> e &lt;span style="color:#f92672">=&lt;/span> ucp.&lt;span style="color:#a6e22e">findResources&lt;/span>(name, &lt;span style="color:#66d9ef">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//这里还是在URLClassPath返回的Enumeration上再包了一次，又实现了一遍Enumeration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Enumeration&lt;span style="color:#f92672">&amp;lt;&lt;/span>URL&lt;span style="color:#f92672">&amp;gt;&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> URL url &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">next&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//这里额外加上的checkURL方法，连name都没带，肯定也不是校验我们java.sql.Driver的，只是简单校验下路径合法或者存在。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> url &lt;span style="color:#f92672">=&lt;/span> ucp.&lt;span style="color:#a6e22e">checkURL&lt;/span>(u);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="urlclasspath">
&lt;a href="#urlclasspath" class="header-anchor">#&lt;/a>
URLClassPath
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> Enumeration&lt;span style="color:#f92672">&amp;lt;&lt;/span>URL&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">findResources&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> String var1, &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> var2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Enumeration&lt;span style="color:#f92672">&amp;lt;&lt;/span>URL&lt;span style="color:#f92672">&amp;gt;&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> index &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> cache &lt;span style="color:#f92672">=&lt;/span> URLClassPath.&lt;span style="color:#a6e22e">this&lt;/span>.&lt;span style="color:#a6e22e">getLookupCache&lt;/span>(var1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> URL url &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">next&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">url&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">do&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> URLClassPath.&lt;span style="color:#a6e22e">Loader&lt;/span> var1x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//终于找到遍历jar包的地方，此处的var1x就是每个jar包&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ((var1x &lt;span style="color:#f92672">=&lt;/span> URLClassPath.&lt;span style="color:#a6e22e">this&lt;/span>.&lt;span style="color:#a6e22e">getNextLoader&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">cache&lt;/span>, &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">index&lt;/span>&lt;span style="color:#f92672">++&lt;/span>)) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//findResource就是从这个jar包中找出我们要的META-INF/services/java.sql.Driver&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">url&lt;/span> &lt;span style="color:#f92672">=&lt;/span> var1x.&lt;span style="color:#a6e22e">findResource&lt;/span>(var1, var2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">while&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">url&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="http://img.heeexy.com/URLClassPath.png"
loading="lazy"
>&lt;/p>
&lt;p>在一个jar包中，又有很多的配置文件路径，如何找到我们要的那个的呢？&lt;/p>
&lt;p>这里var1x就是JarLoader，用了其中的getResource方法。&lt;/p>
&lt;h3 id="jarloader">
&lt;a href="#jarloader" class="header-anchor">#&lt;/a>
JarLoader
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Resource &lt;span style="color:#a6e22e">getResource&lt;/span>(String var1, &lt;span style="color:#66d9ef">boolean&lt;/span> var2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//关键就在这个metaIndex中，mayContain方法去查了jar包中是否包含我们要找的目标文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">metaIndex&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">metaIndex&lt;/span>.&lt;span style="color:#a6e22e">mayContain&lt;/span>(var1)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">ensureOpen&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (IOException var5) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> InternalError(var5);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JarEntry var3 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">jar&lt;/span>.&lt;span style="color:#a6e22e">getJarEntry&lt;/span>(var1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (var3 &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">checkResource&lt;/span>(var1, var2, var3);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">index&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HashSet var4 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashSet();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getResource&lt;/span>(var1, var2, var4);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="http://img.heeexy.com/JarLoader.png"
loading="lazy"
>&lt;/p>
&lt;p>至此，我们已经找到了全部遍历的地方，URLClassLoader加载了全部jar包之后，在开始迭代时，URLClassPath 遍历每个jar包，JarLoader查找每个jar包中是否有目标文件META-INF/services/java.sql.Driver。&lt;/p></description></item><item><title>使用MyBatis时为什么Dao层不需要@Repository</title><link>https://heeexy.com/posts/%E4%BD%BF%E7%94%A8mybatis%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88dao%E5%B1%82%E4%B8%8D%E9%9C%80%E8%A6%81-repository/</link><pubDate>Tue, 03 Apr 2018 17:07:46 +0000</pubDate><guid>https://heeexy.com/posts/%E4%BD%BF%E7%94%A8mybatis%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88dao%E5%B1%82%E4%B8%8D%E9%9C%80%E8%A6%81-repository/</guid><description>&lt;h1 id="问题">
&lt;a href="#%e9%97%ae%e9%a2%98" class="header-anchor">#&lt;/a>
问题
&lt;/h1>&lt;p>Service层注入Dao时， Intellij 总会以红色波浪线提示我们&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Autowired&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> UserDao userDao;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Could not autowire. No beans of &amp;lsquo;UserDao&amp;rsquo; type found.
Checks autowiring problems in a bean class.&lt;/p>
&lt;p>尽管我们都知道 Dao 层的 Bean 实际上都是有的，并且可以设置关闭这恼人的提示，但是我们有没有想过为什么 Intellij 就找不到这个 Bean 呢？甚至有人有这种做法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Repository&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">UserDao&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>来避免提示，但是这种做法正确么？&lt;/p>
&lt;p>所以今天我们的疑问就是&lt;/p>
&lt;ol>
&lt;li>为什么 Dao 层不需要加 @Repository 注解，源码里到底做了什么？&lt;/li>
&lt;li>加了 @Repository 注解有什么影响？&lt;/li>
&lt;/ol>
&lt;h1 id="答案">
&lt;a href="#%e7%ad%94%e6%a1%88" class="header-anchor">#&lt;/a>
答案
&lt;/h1>&lt;ol>
&lt;li>
&lt;p>关键在于 ClassPathMapperScanner 对指定包的扫描，并且扫描过程对 Spring 原本的扫描 Bean 的步骤 &amp;ldquo;加了料” ，Spring 本身只扫实现类，但 MyBatis 的扫描器&lt;strong>扫了接口&lt;/strong> 。并且扫完接口之后，为接口配了个 &lt;strong>BeanDefinition&lt;/strong> ,并且这个 bd 的 BeanClass 是 &lt;strong>MapperFactoryBean&lt;/strong> 。&lt;/p>
&lt;blockquote>
&lt;p>对于 BeanDefinition 和 MapperFactoryBean 不了解的同学请查询相关资料和源码&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>仅仅只能解决 Intellij 静态查找 bean 的问题，没有实际作用。即使加了注解，比如@Controller，@Service 等等，也会被 Spring 的扫描器给忽略掉，因为&lt;strong>扫描器会过滤掉接口&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="源码探索">
&lt;a href="#%e6%ba%90%e7%a0%81%e6%8e%a2%e7%b4%a2" class="header-anchor">#&lt;/a>
源码探索
&lt;/h1>&lt;blockquote>
&lt;p>下面的源码部分如果读者提前有 MyBatis 的 Bean 的执行流程，和 Spring 的 Bean加载的相关知识就更好理解。&lt;/p>
&lt;/blockquote>
&lt;h3 id="1-分析问题">
&lt;a href="#1-%e5%88%86%e6%9e%90%e9%97%ae%e9%a2%98" class="header-anchor">#&lt;/a>
1. 分析问题
&lt;/h3>&lt;p>关于为什么不需要注解就能获取到 Dao 层的 Bean，看似答案很简单，因为配置了扫描指定这个包里的 xxxDao.class 啊，比如使用注解 @MapperScan(&amp;ldquo;com.example.dao&amp;rdquo;)。&lt;/p>
&lt;p>这个答案太过表面，觉得问题简单只是因为对 Spring 的 Bean 不熟悉。&lt;/p>
&lt;p>我们何时见过 @Component 及其衍生的3个注解 @Controller、@Service、@Repository &lt;strong>加在接口上面&lt;/strong>的？&lt;/p>
&lt;p>自己测试新建个接口，上面加注解，然后找个 Controller 里 @Autowired 注入一下，项目立马会报错 NoSuchBeanDefinitionException 。&lt;/p>
&lt;h3 id="2-切入源码">
&lt;a href="#2-%e5%88%87%e5%85%a5%e6%ba%90%e7%a0%81" class="header-anchor">#&lt;/a>
2. 切入源码
&lt;/h3>&lt;h4 id="切入点">
&lt;a href="#%e5%88%87%e5%85%a5%e7%82%b9" class="header-anchor">#&lt;/a>
切入点
&lt;/h4>&lt;p>既然使用注解 @MapperScan 就好使，那么我们就从这个点切入源码看一下，先找出源码中何处用了此注解，非常幸运的是，只有一处用到了此注解 ：MapperScannerRegistrar.registerBeanDefinitions() 。&lt;/p>
&lt;p>并且从类名和方法名就可以很清楚的看出这个类的功能是扫描 Mapper 并注册，方法的功能就是注册 BeanDefinitions 到 Spring 中。方法的源码我就不贴了，很容易看出来是创建一个扫描器 &lt;code>ClassPathMapperScanner&lt;/code> ，设置好一系列属性比如 Spring 的注册表之后，执行 doScan() 方法去扫描 @MapperScan 提供的包。&lt;/p>
&lt;h4 id="doscan-扫描资源转换为-beandefinition">
&lt;a href="#doscan-%e6%89%ab%e6%8f%8f%e8%b5%84%e6%ba%90%e8%bd%ac%e6%8d%a2%e4%b8%ba-beandefinition" class="header-anchor">#&lt;/a>
doScan() 扫描资源，转换为 BeanDefinition
&lt;/h4>&lt;p>doScan() 方法也很简单，就是两步：&lt;/p>
&lt;ol>
&lt;li>调用父类 ClassPathBeanDefinitionScanner 的doScan()方法，也就是 Spring 扫描BeanDefinition 的方法。过程不是很重要，我们需要知道这个扫描方法的一个关键就是&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Set&lt;span style="color:#f92672">&amp;lt;&lt;/span>BeanDefinition&lt;span style="color:#f92672">&amp;gt;&lt;/span> candidates &lt;span style="color:#f92672">=&lt;/span> findCandidateComponents(basePackage);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在其中对所有的候选者使用 isCandidateComponent() 方法判断是否为符合要求的 BeanDefinition。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (TypeFilter tf : &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">excludeFilters&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (tf.&lt;span style="color:#a6e22e">match&lt;/span>(metadataReader, &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">metadataReaderFactory&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (TypeFilter tf : &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">includeFilters&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (tf.&lt;span style="color:#a6e22e">match&lt;/span>(metadataReader, &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">metadataReaderFactory&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> isConditionMatch(metadataReader);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这有两组过滤器来过滤扫描到的资源。&lt;strong>Spring 默认的过滤器是排除掉抽象类/接口的。而MyBatis 的扫描器重新注册了过滤器，默认对接口放行。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>其实还有一些其它的过滤要求，但是不影响我们本问题的探究，所以不深入解读了。&lt;/p>
&lt;/blockquote>
&lt;p>源码读到这里，我们先找到了本文的第二个问题的答案。也就是 Spring 会忽略掉接口上面的注解，不会添加它进入 BeanDefiniiton ,也就难怪测试的时候会抛出 NoSuchBeanDefinitionException 的异常了。而 MyBatis 则会把这些接口拉过来注册BD 。&lt;/p>
&lt;h4 id="对-beandefinition-的加工">
&lt;a href="#%e5%af%b9-beandefinition-%e7%9a%84%e5%8a%a0%e5%b7%a5" class="header-anchor">#&lt;/a>
对 BeanDefinition 的加工
&lt;/h4>&lt;p>读到这里我们可能有了更大的疑问，拿接口注册 BeanDefinition ，那获取 Bean 的时候如何去实例化这个对象啊？接口可是不能实例化出对象的啊，而且我们也没有做实现。&lt;/p>
&lt;p>原来是 MyBatis 的扫描器在调用完父类的扫描方法后，对 BeanDefinition 进行了加工 processBeanDefinitions() 。其中最关键的两行代码是&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>definition.&lt;span style="color:#a6e22e">getConstructorArgumentValues&lt;/span>().&lt;span style="color:#a6e22e">addGenericArgumentValue&lt;/span>(definition.&lt;span style="color:#a6e22e">getBeanClassName&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>definition.&lt;span style="color:#a6e22e">setBeanClass&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">mapperFactoryBean&lt;/span>.&lt;span style="color:#a6e22e">getClass&lt;/span>());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>第一行，我们发现把这个&lt;strong>接口的类名塞到了构造器参数中&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>小彩蛋，这里塞的是 String ，而我们的构造器参数其实要的是 Class 。但是 Spring 的 ConstructorResolver.autowireConstructor 中用到了 Object[] argsToUse 去做了个转换 。&lt;/p>
&lt;/blockquote>
&lt;p>第二行，beanDefinition 的 &lt;strong>BeanClass 被设置成了 MapperFactoryBean&lt;/strong> !&lt;/p>
&lt;p>熟悉 Spring 和 MyBatis 的读者肯定一下就明白了，就是这个地方进行了&amp;quot;偷梁换柱&amp;rdquo;！&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Autowired&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> UserDao userDao;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>还是拿 UserDao 为例，我们向 Spring 容器说 &amp;ldquo;给我来个 UserDao 的实例&amp;rdquo;，而 Spring 根据注册时候的 BeanDefinition ，去工厂( &lt;strong>MapperFactoryBean&lt;/strong> )里面扔了个 UserDao.class 的参数进去，工厂的 getObject() 方法给我们返回了它制造的 userDao 。&lt;/p>
&lt;p>就这样，我们没有去写实现类，轻轻松松拿到了我们需要的 userDao 。&lt;/p>
&lt;p>至于 &lt;strong>MapperFactoryBean&lt;/strong> 里做了什么返回了 userDao 出来？其实就是它的 getObject 方法返回的是 DefaultSqlSession.getMapper(Class&lt;!-- raw HTML omitted --> type)方法，返回的是 MapperProxy 代理的类，而这个代理类的 invoke 方法并不像我们平时见到的代理中的 invoke 方法一样调用原始目标的 method.invoke ，而是去找 MapperMethod 执行了。&lt;/p>
&lt;h1 id="收获">
&lt;a href="#%e6%94%b6%e8%8e%b7" class="header-anchor">#&lt;/a>
收获
&lt;/h1>&lt;p>这次的源码探究下来，收获的不仅仅是了解了 Dao 层 Bean 的注入，更是串起了我们最常用的 Spring 和 MyBatis ，换句话说，我们打通了从 Service 层到 Dao 层。&lt;/p>
&lt;p>在以往 Debug 代码时看到的 MapperProxy，MapperMethod，我们清楚了这是从何而来，也对 MyBatis 中代理的巧妙运用更加熟悉。&lt;/p>
&lt;h1 id="参考文献">
&lt;a href="#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae" class="header-anchor">#&lt;/a>
参考文献
&lt;/h1>&lt;p>&lt;a class="link" href="https://blog.csdn.net/java280580332/article/details/72123890" target="_blank" rel="noopener"
>https://blog.csdn.net/java280580332/article/details/72123890&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://blog.csdn.net/mingtian625/article/details/47684271" target="_blank" rel="noopener"
>https://blog.csdn.net/mingtian625/article/details/47684271&lt;/a>&lt;/p></description></item><item><title>极简 Spring 框架 -- 浅析循环依赖</title><link>https://heeexy.com/posts/spring-note-18-ioc/</link><pubDate>Sun, 28 Jan 2018 13:37:32 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-18-ioc/</guid><description>&lt;blockquote>
&lt;p>从网上看到一篇博文 &lt;a class="link" href="https://diaozxin007.github.io/2018/01/08/spring-ioc/" target="_blank" rel="noopener"
>徒手撸框架&amp;ndash;实现IoC&lt;/a> ，写得很棒，作者抛开了 Spring 源码中复杂的校验，拓展等功能，实现了一个极简的 IoC 框架，让 Spring 源码初学者可以清楚的看到 IOC 的实现流程。&lt;/p>
&lt;p>本文就借其框架，略加改造，再次介绍一下 Spring 是如何处理循环依赖的。&lt;/p>
&lt;/blockquote>
&lt;p>了解本项目核心代码需要先参考原作者的博文 &lt;a class="link" href="https://diaozxin007.github.io/2018/01/08/spring-ioc/" target="_blank" rel="noopener"
>徒手撸框架&amp;ndash;实现IoC&lt;/a> 。&lt;/p>
&lt;h3 id="循环依赖">
&lt;a href="#%e5%be%aa%e7%8e%af%e4%be%9d%e8%b5%96" class="header-anchor">#&lt;/a>
循环依赖
&lt;/h3>&lt;p>其实很好理解，A 类依赖 B，B 又依赖 A。&lt;/p>
&lt;p>说具体点就是 ，我们要 getBean(&amp;ldquo;a&amp;rdquo;)， A 在实例化时需要为类型为 B 的成员变量赋值，因此去 getBean(&amp;ldquo;b&amp;rdquo;)，而 getBean(&amp;ldquo;b&amp;rdquo;) 的时候又需要为其类型为A 的成员变量赋值，此时又会回过头去实例化 A ，导致无限循环。&lt;/p>
&lt;p>用代码展示就是&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">A&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@AutoWired&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> B b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">B&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@AutoWired&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> A a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="代码改造">
&lt;a href="#%e4%bb%a3%e7%a0%81%e6%94%b9%e9%80%a0" class="header-anchor">#&lt;/a>
代码改造
&lt;/h3>&lt;p>最主要的代码改造在于 BeanFactoryImpl 内， 添加了成员变量&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Object&lt;span style="color:#f92672">&amp;gt;&lt;/span> earlySingletonObjects &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashMap&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Object&lt;span style="color:#f92672">&amp;gt;&lt;/span>(16);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>用于缓存正在创建中的，提前暴露出来的单例 bean。&lt;/p>
&lt;p>在获取 bean 时，会在创建之前先从此 Map 中尝试获取，而这就是解决循环依赖的关键。&lt;/p>
&lt;p>以上面的例子来说，就是一开始 getBean(&amp;ldquo;a&amp;rdquo;) 时，将未完成的 a 放入缓存，getBean(&amp;ldquo;b&amp;rdquo;) 时，需要去获取 a ,会从缓存中获取，而不是再去实例化 a。&lt;/p>
&lt;p>&lt;img src="http://img.heeexy.com/CyclicDependence.png"
loading="lazy"
>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> Object &lt;span style="color:#a6e22e">getBean&lt;/span>(String name) &lt;span style="color:#66d9ef">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//查找对象是否已经实例化过&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object bean &lt;span style="color:#f92672">=&lt;/span> beanMap.&lt;span style="color:#a6e22e">get&lt;/span>(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (bean &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> bean;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object earlyBean &lt;span style="color:#f92672">=&lt;/span> earlySingletonObjects.&lt;span style="color:#a6e22e">get&lt;/span>(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (earlyBean &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;循环依赖，提前返回尚未加载完成的bean:&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> earlyBean;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果没有实例化，那就需要调用createBean来创建对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BeanDefinition beanDefinition &lt;span style="color:#f92672">=&lt;/span> beanDefineMap.&lt;span style="color:#a6e22e">get&lt;/span>(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bean &lt;span style="color:#f92672">=&lt;/span> createBean(beanDefinition);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (bean &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> earlySingletonObjects.&lt;span style="color:#a6e22e">put&lt;/span>(name, bean);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//对象创建成功以后，注入对象需要的参数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> populatebean(bean, beanDefinition);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//再吧对象存入Map中方便下次使用。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> beanMap.&lt;span style="color:#a6e22e">put&lt;/span>(name, bean);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//从早期单例Map中移除&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> earlySingletonObjects.&lt;span style="color:#a6e22e">remove&lt;/span>(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//结束返回&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> bean;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="q--a">
&lt;a href="#q--a" class="header-anchor">#&lt;/a>
Q &amp;amp; A
&lt;/h3>&lt;p>Q: 构造器循环依赖为什么无法解决？&lt;/p>
&lt;p>A: 从上面代码可以看出，需要在 createBean 之后，才能将其放入缓存，而构造过程是在 createBean 之内的，此时尚未构造好一个基本的 bean ,拿什么放入缓存呢？&lt;/p>
&lt;h3 id="心得">
&lt;a href="#%e5%bf%83%e5%be%97" class="header-anchor">#&lt;/a>
心得
&lt;/h3>&lt;p>上面只贴了 getBean 的代码，仅仅修改了原作者不到 10 行代码，其实在修改原框架，实现我们要的功能时不止这么多，包括调整对 json 的解析，对 bean 的填充等。&lt;/p>
&lt;p>感受到 Spring 框架真的是很复杂很全面，这复杂程度靠说是说不清楚的，也不是翻一遍书看看源码就能明白的。而且看源码其实还是似懂非懂，中间的细节迷迷糊糊就可能跳过去了。&lt;/p>
&lt;p>在追随 Spring 脚步，复现其代码的时候，才更深刻的理解其中很多操作，很多类的作用。比如说 BeanDefinition, BeanWrapper , PropertyDescriptor 这些类在我想要实现一些功能的时候才能体会到 Spring 创造它们的重要性。&lt;/p></description></item><item><title>Spring 源码笔记-2.8 根据类型寻找 bean--找出所有匹配类型的 beanName</title><link>https://heeexy.com/posts/spring-note-16-beannamesfortypeincludingancestors/</link><pubDate>Wed, 24 Jan 2018 09:48:02 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-16-beannamesfortypeincludingancestors/</guid><description>&lt;blockquote>
&lt;p>&lt;a class="link" href="https://heeexy.com/2018/01/23/findAutowireCandidates/" >前文&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h3 id="源码解析">
&lt;a href="#%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90" class="header-anchor">#&lt;/a>
源码解析
&lt;/h3>&lt;p>入参说明&lt;/p>
&lt;ul>
&lt;li>includeNonSingletons：是否包括非单例的 bean，比如 prototype scope&lt;/li>
&lt;li>allowEagerInit：为了这个检查（找出所有匹配类型的 beanName），是否初始化 lazy-init 单例和由 FactoryBeans 创建的对象。此处我们传入的值为 true。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> String&lt;span style="color:#f92672">[]&lt;/span> &lt;span style="color:#a6e22e">beanNamesForTypeIncludingAncestors&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListableBeanFactory lbf, Class&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> type, &lt;span style="color:#66d9ef">boolean&lt;/span> includeNonSingletons, &lt;span style="color:#66d9ef">boolean&lt;/span> allowEagerInit) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Assert.&lt;span style="color:#a6e22e">notNull&lt;/span>(lbf, &lt;span style="color:#e6db74">&amp;#34;ListableBeanFactory must not be null&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//方法主干还是在这行 getBeanNamesForType&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String&lt;span style="color:#f92672">[]&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> lbf.&lt;span style="color:#a6e22e">getBeanNamesForType&lt;/span>(type, includeNonSingletons, allowEagerInit);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//下面的内容就是从 bf 的 parent 中找，&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (lbf &lt;span style="color:#66d9ef">instanceof&lt;/span> HierarchicalBeanFactory) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HierarchicalBeanFactory hbf &lt;span style="color:#f92672">=&lt;/span> (HierarchicalBeanFactory) lbf;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (hbf.&lt;span style="color:#a6e22e">getParentBeanFactory&lt;/span>() &lt;span style="color:#66d9ef">instanceof&lt;/span> ListableBeanFactory) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//此处以 parent 再来调此方法，合并结果。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String&lt;span style="color:#f92672">[]&lt;/span> parentResult &lt;span style="color:#f92672">=&lt;/span> beanNamesForTypeIncludingAncestors(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (ListableBeanFactory) hbf.&lt;span style="color:#a6e22e">getParentBeanFactory&lt;/span>(), type, includeNonSingletons, allowEagerInit);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> resultList &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resultList.&lt;span style="color:#a6e22e">addAll&lt;/span>(Arrays.&lt;span style="color:#a6e22e">asList&lt;/span>(result));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (String beanName : parentResult) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>resultList.&lt;span style="color:#a6e22e">contains&lt;/span>(beanName) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>hbf.&lt;span style="color:#a6e22e">containsLocalBean&lt;/span>(beanName)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resultList.&lt;span style="color:#a6e22e">add&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result &lt;span style="color:#f92672">=&lt;/span> StringUtils.&lt;span style="color:#a6e22e">toStringArray&lt;/span>(resultList);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>看来我们还需要继续深入到 &lt;code>getBeanNamesForType&lt;/code>中去一探究竟。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> String&lt;span style="color:#f92672">[]&lt;/span> &lt;span style="color:#a6e22e">getBeanNamesForType&lt;/span>(Class&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> type, &lt;span style="color:#66d9ef">boolean&lt;/span> includeNonSingletons, &lt;span style="color:#66d9ef">boolean&lt;/span> allowEagerInit) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//configurationFrozen：判断所有 bean 的 定义元数据是否可以被缓存&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果不能缓存 或没type 或不允许急切初始化，则直接查 doGetBeanNamesForType&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>isConfigurationFrozen() &lt;span style="color:#f92672">||&lt;/span> type &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#f92672">!&lt;/span>allowEagerInit) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> doGetBeanNamesForType(ResolvableType.&lt;span style="color:#a6e22e">forRawClass&lt;/span>(type), includeNonSingletons, allowEagerInit);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//否则先查缓存，没有缓存的话再查 doGetBeanNamesForType 并塞入缓存&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>Class&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span>, String&lt;span style="color:#f92672">[]&amp;gt;&lt;/span> cache &lt;span style="color:#f92672">=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (includeNonSingletons &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">allBeanNamesByType&lt;/span> : &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">singletonBeanNamesByType&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String&lt;span style="color:#f92672">[]&lt;/span> resolvedBeanNames &lt;span style="color:#f92672">=&lt;/span> cache.&lt;span style="color:#a6e22e">get&lt;/span>(type);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (resolvedBeanNames &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> resolvedBeanNames;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resolvedBeanNames &lt;span style="color:#f92672">=&lt;/span> doGetBeanNamesForType(ResolvableType.&lt;span style="color:#a6e22e">forRawClass&lt;/span>(type), includeNonSingletons, &lt;span style="color:#66d9ef">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//判断是否缓存安全：依据我们目标class 和当前beanFactory的classLoader是否一致&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (ClassUtils.&lt;span style="color:#a6e22e">isCacheSafe&lt;/span>(type, getBeanClassLoader())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cache.&lt;span style="color:#a6e22e">put&lt;/span>(type, resolvedBeanNames);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> resolvedBeanNames;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>再深入一层到 &lt;code>doGetBeanNamesForType&lt;/code> ，其中逻辑外层是遍历所有的 beanName, 对于不是别名的进行处理，处理过程如下（省略了 try-catch ）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//首先获取这个beanName对应的mbd，它的相关定义配置信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RootBeanDefinition mbd &lt;span style="color:#f92672">=&lt;/span> getMergedLocalBeanDefinition(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Only check bean definition if it is complete.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 不是抽象的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 并且 允许急切初始化 或 （此bean不需要急切初始化 且（有beanClass 或 不是lazyInit 或 允许急切的类加载，即使是懒惰的初始化bean））&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>mbd.&lt;span style="color:#a6e22e">isAbstract&lt;/span>() &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> (allowEagerInit &lt;span style="color:#f92672">||&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ((mbd.&lt;span style="color:#a6e22e">hasBeanClass&lt;/span>() &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#f92672">!&lt;/span>mbd.&lt;span style="color:#a6e22e">isLazyInit&lt;/span>() &lt;span style="color:#f92672">||&lt;/span> isAllowEagerClassLoading())) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">!&lt;/span>requiresEagerInitForType(mbd.&lt;span style="color:#a6e22e">getFactoryBeanName&lt;/span>()))) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// In case of FactoryBean, match object created by FactoryBean.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//判断是否 FactoryBean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span> isFactoryBean &lt;span style="color:#f92672">=&lt;/span> isFactoryBean(beanName, mbd);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BeanDefinitionHolder dbd &lt;span style="color:#f92672">=&lt;/span> mbd.&lt;span style="color:#a6e22e">getDecoratedDefinition&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//接下来又是一段非常长的逻辑判断，判断是否匹配&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span> matchFound &lt;span style="color:#f92672">=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (allowEagerInit &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#f92672">!&lt;/span>isFactoryBean &lt;span style="color:#f92672">||&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (dbd &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>mbd.&lt;span style="color:#a6e22e">isLazyInit&lt;/span>()) &lt;span style="color:#f92672">||&lt;/span> containsSingleton(beanName)) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (includeNonSingletons &lt;span style="color:#f92672">||&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (dbd &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">?&lt;/span> mbd.&lt;span style="color:#a6e22e">isSingleton&lt;/span>() : isSingleton(beanName))) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> isTypeMatch(beanName, type);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>matchFound &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> isFactoryBean) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// In case of FactoryBean, try to match FactoryBean instance itself next.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//如果不匹配，还要试试匹配FactoryBean本身，因为说不好要的就是这个FactoryBean呢&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> beanName &lt;span style="color:#f92672">=&lt;/span> FACTORY_BEAN_PREFIX &lt;span style="color:#f92672">+&lt;/span> beanName;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> matchFound &lt;span style="color:#f92672">=&lt;/span> (includeNonSingletons &lt;span style="color:#f92672">||&lt;/span> mbd.&lt;span style="color:#a6e22e">isSingleton&lt;/span>()) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> isTypeMatch(beanName, type);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (matchFound) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.&lt;span style="color:#a6e22e">add&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//检查一遍手动的单例集合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//对于 FactoryBean ,如果匹配到它的getObject()满足，就不会继续去匹配它本身&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (String beanName : &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">manualSingletonNames&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// In case of FactoryBean, match object created by FactoryBean.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (isFactoryBean(beanName)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ((includeNonSingletons &lt;span style="color:#f92672">||&lt;/span> isSingleton(beanName)) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> isTypeMatch(beanName, type)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.&lt;span style="color:#a6e22e">add&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Match found for this bean: do not match FactoryBean itself anymore.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// In case of FactoryBean, try to match FactoryBean itself next.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> beanName &lt;span style="color:#f92672">=&lt;/span> FACTORY_BEAN_PREFIX &lt;span style="color:#f92672">+&lt;/span> beanName;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Match raw bean instance (might be raw FactoryBean).&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (isTypeMatch(beanName, type)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.&lt;span style="color:#a6e22e">add&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>前一段的超长的逻辑判断看得人头疼，但是先看下半段的遍历，突然就找到了最关键判断类型匹配的函数 &lt;code>isTypeMatch&lt;/code>，从名字就看出来，这应该就是判断类型匹配的地方啦。&lt;/p>
&lt;p>然而点进去一看，居然是长达 100 行的函数。&lt;/p>
&lt;h4 id="istypematch">
&lt;a href="#istypematch" class="header-anchor">#&lt;/a>
isTypeMatch
&lt;/h4>&lt;p>首先从单例中查找，匹配这个单例 bean 的类型和我们目标的类型，其中对 factoryBean 的处理也比较简单，就不再贴代码了。对于注册的 null instance ,也返回 false。&lt;/p>
&lt;p>再从父工厂找，递归 isTypeMatch 。&lt;/p>
&lt;p>再就是复杂的查找了。&lt;/p>
&lt;p>先定义个 typesToMatch ，包括了目标类型和 FactoryBean .&lt;/p>
&lt;p>然后我们再继续看代码。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Check decorated bean definition, if any: We assume it&amp;#39;ll be easier&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// to determine the decorated bean&amp;#39;s type than the proxy&amp;#39;s type.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 先检查 bean 的装饰definition。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BeanDefinitionHolder dbd &lt;span style="color:#f92672">=&lt;/span> mbd.&lt;span style="color:#a6e22e">getDecoratedDefinition&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (dbd &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>BeanFactoryUtils.&lt;span style="color:#a6e22e">isFactoryDereference&lt;/span>(name)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> RootBeanDefinition tbd &lt;span style="color:#f92672">=&lt;/span> getMergedBeanDefinition(dbd.&lt;span style="color:#a6e22e">getBeanName&lt;/span>(), dbd.&lt;span style="color:#a6e22e">getBeanDefinition&lt;/span>(), mbd);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Class&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> targetClass &lt;span style="color:#f92672">=&lt;/span> predictBeanType(dbd.&lt;span style="color:#a6e22e">getBeanName&lt;/span>(), tbd, typesToMatch);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (targetClass &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>FactoryBean.&lt;span style="color:#a6e22e">class&lt;/span>.&lt;span style="color:#a6e22e">isAssignableFrom&lt;/span>(targetClass)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> typeToMatch.&lt;span style="color:#a6e22e">isAssignableFrom&lt;/span>(targetClass);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 注意此处predictBeanType返回了很关键的Class ,我们后面再详细分析此方法。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Class&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> beanType &lt;span style="color:#f92672">=&lt;/span> predictBeanType(beanName, mbd, typesToMatch);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (beanType &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Check bean class whether we&amp;#39;re dealing with a FactoryBean.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//接下来就是处理 FactoryBean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (FactoryBean.&lt;span style="color:#a6e22e">class&lt;/span>.&lt;span style="color:#a6e22e">isAssignableFrom&lt;/span>(beanType)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>BeanFactoryUtils.&lt;span style="color:#a6e22e">isFactoryDereference&lt;/span>(name)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// If it&amp;#39;s a FactoryBean, we want to look at what it creates, not the factory class.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> beanType &lt;span style="color:#f92672">=&lt;/span> getTypeForFactoryBean(beanName, mbd);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (beanType &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (BeanFactoryUtils.&lt;span style="color:#a6e22e">isFactoryDereference&lt;/span>(name)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Special case: A SmartInstantiationAwareBeanPostProcessor returned a non-FactoryBean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// type but we nevertheless are being asked to dereference a FactoryBean...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Let&amp;#39;s check the original bean class and proceed with it if it is a FactoryBean.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> beanType &lt;span style="color:#f92672">=&lt;/span> predictBeanType(beanName, mbd, FactoryBean.&lt;span style="color:#a6e22e">class&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (beanType &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#f92672">!&lt;/span>FactoryBean.&lt;span style="color:#a6e22e">class&lt;/span>.&lt;span style="color:#a6e22e">isAssignableFrom&lt;/span>(beanType)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//对其 resolvableType 进行处理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ResolvableType resolvableType &lt;span style="color:#f92672">=&lt;/span> mbd.&lt;span style="color:#a6e22e">targetType&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (resolvableType &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resolvableType &lt;span style="color:#f92672">=&lt;/span> mbd.&lt;span style="color:#a6e22e">factoryMethodReturnType&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (resolvableType &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> resolvableType.&lt;span style="color:#a6e22e">resolve&lt;/span>() &lt;span style="color:#f92672">==&lt;/span> beanType) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> typeToMatch.&lt;span style="color:#a6e22e">isAssignableFrom&lt;/span>(resolvableType);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//如果以上都没有处理掉的话， 则判读typeToMatch和 beanType &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">return&lt;/span> typeToMatch.&lt;span style="color:#a6e22e">isAssignableFrom&lt;/span>(beanType);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>总结：&lt;/p>
&lt;p>目前很遗憾 isTypeMatch 往下还有很复杂的逻辑暂时不能看懂，但是从外层的逻辑大致知道寻找所有匹配的beanName 的方法非常的“复杂粗暴”。遍历 beanDefinitionNames 已定义的所有 bean，即使是一个小型的项目也有近200个 bean 需要遍历，并且这数百个 beanName 还要遍历非常多次。&lt;/p>
&lt;p>只能说根据 type 寻找 bean 实在是比根据 name 复杂了太多太多，从源码看真是深坑，理解了为什么作者直接忽略了这部分&amp;hellip;应该是第二遍或第三遍阅读 Spring 源码时才能理解。&lt;/p></description></item><item><title>Spring 源码笔记-2.7 根据类型寻找 bean</title><link>https://heeexy.com/posts/spring-note-15-findautowirecandidates/</link><pubDate>Tue, 23 Jan 2018 09:00:22 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-15-findautowirecandidates/</guid><description>&lt;h2 id="前言">
&lt;a href="#%e5%89%8d%e8%a8%80" class="header-anchor">#&lt;/a>
前言
&lt;/h2>&lt;p>Spring 装配 bean 有两种类型：&lt;code>autowireByName&lt;/code> 和 &lt;code>autowireByType&lt;/code> 。&lt;/p>
&lt;p>&lt;code>autowireByName&lt;/code> 通过名称查找很直接，就是我们一直在学的 getBean() 。&lt;/p>
&lt;p>而 &lt;code>autowireByType&lt;/code> 根据类型查找相比起来就要复杂一些了，《 Spring 源码深度解析 》 中有介绍过的部分我就不再重复贴了，但是书中遗漏了一处重要的部分&amp;mdash;&amp;mdash; &lt;strong>findAutowireCandidates 查找所有合适的 bean&lt;/strong>，还有一处新版本 Spring 中升级的部分&amp;mdash;&amp;mdash;&lt;strong>如果只需要一个但是找出多个 bean 该怎么处理&lt;/strong>，今天我们先来学习第一部分。&lt;/p>
&lt;h2 id="正文">
&lt;a href="#%e6%ad%a3%e6%96%87" class="header-anchor">#&lt;/a>
正文
&lt;/h2>&lt;h3 id="本函数要做什么">
&lt;a href="#%e6%9c%ac%e5%87%bd%e6%95%b0%e8%a6%81%e5%81%9a%e4%bb%80%e4%b9%88" class="header-anchor">#&lt;/a>
本函数要做什么
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@RestController&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@RequestMapping&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/article&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ArticleController&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Autowired&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> ArticleService articleService;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在初始化 ArticleController 的过程中，我们要为其装配 ArticleService 。&lt;/p>
&lt;p>忽略掉外面代码一层一层的包裹之后，我们走到 &lt;code>DefaultListableBeanFactory.findAutowireCandidates&lt;/code> 这个函数中，要寻找合适的候选 bean 。由于可能会找到多个，因此返回结果是候选 bean 的名称和其对应实例构成的 Map 。&lt;/p>
&lt;h3 id="源码解析">
&lt;a href="#%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90" class="header-anchor">#&lt;/a>
源码解析
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//三个参数的含义依次是 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 正在解析的 beanName, 本例中即 &amp;#34;articleController&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 需要装配的 bean 类型, 本例中即 ArticleService.class&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 对当前依赖关系的解析类，记录了 ArticleController 和 ArticleService 的依赖关系&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">protected&lt;/span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Object&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">findAutowireCandidates&lt;/span>(String beanName,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Class&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> requiredType,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DependencyDescriptor descriptor) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//第一步就是查找出所有符合类型的 beanName 。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//似乎第一句就干完全部逻辑了？？？稍后我们再详细分析这个方法。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String&lt;span style="color:#f92672">[]&lt;/span> candidateNames &lt;span style="color:#f92672">=&lt;/span> BeanFactoryUtils.&lt;span style="color:#a6e22e">beanNamesForTypeIncludingAncestors&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>, requiredType, &lt;span style="color:#66d9ef">true&lt;/span>, descriptor.&lt;span style="color:#a6e22e">isEager&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Object&lt;span style="color:#f92672">&amp;gt;&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> LinkedHashMap&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Object&lt;span style="color:#f92672">&amp;gt;&lt;/span>(candidateNames.&lt;span style="color:#a6e22e">length&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * resolvableDependencies 记录了 依赖类型--具体装配值 的映射
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 遍历 resolvableDependencies。如果该类型是我们需要的类型（ArticleService），
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Class&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> autowiringType : &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">resolvableDependencies&lt;/span>.&lt;span style="color:#a6e22e">keySet&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (autowiringType.&lt;span style="color:#a6e22e">isAssignableFrom&lt;/span>(requiredType)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object autowiringValue &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">resolvableDependencies&lt;/span>.&lt;span style="color:#a6e22e">get&lt;/span>(autowiringType);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//key值是我们需要的类型，但value值未必。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//value可能是ObjectFactory，就得调用它的 getObject() 来获取真正的bean.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> autowiringValue &lt;span style="color:#f92672">=&lt;/span> AutowireUtils.&lt;span style="color:#a6e22e">resolveAutowiringValue&lt;/span>(autowiringValue, requiredType);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (requiredType.&lt;span style="color:#a6e22e">isInstance&lt;/span>(autowiringValue)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果类型匹配，则塞入result&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.&lt;span style="color:#a6e22e">put&lt;/span>(ObjectUtils.&lt;span style="color:#a6e22e">identityToString&lt;/span>(autowiringValue), autowiringValue);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (String candidate : candidateNames) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果不是自己依赖自己 ， 并且符合装配候选，就塞入result。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//何为符合装配候选（isAutowireCandidate）呢？稍后我们再详细分析。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>isSelfReference(beanName, candidate) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> isAutowireCandidate(candidate, descriptor)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> addCandidateEntry(result, candidate, descriptor, requiredType);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (result.&lt;span style="color:#a6e22e">isEmpty&lt;/span>() &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>indicatesMultipleBeans(requiredType)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Consider fallback matches if the first pass failed to find anything...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果之前一轮都没找到，则考虑回退匹配，什么是回退匹配？稍后再分析。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DependencyDescriptor fallbackDescriptor &lt;span style="color:#f92672">=&lt;/span> descriptor.&lt;span style="color:#a6e22e">forFallbackMatch&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (String candidate : candidateNames) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>isSelfReference(beanName, candidate) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> isAutowireCandidate(candidate, fallbackDescriptor)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//再执行一遍上面的方法。如果不是自己依赖自己，并且符合装配候选，就塞入result。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> addCandidateEntry(result, candidate, descriptor, requiredType);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (result.&lt;span style="color:#a6e22e">isEmpty&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Consider self references as a final pass...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// but in the case of a dependency collection, not the very same bean itself.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 如果依然没找到结果，那么满足以下条件的也是我们的目标。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 1.是自引用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 2.依赖不是多元素依赖 或者 bean名和候选者名字不相等（这里就避免了自引用导致无限循环）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 3.候选者符合回退匹配之后的装配候选&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (String candidate : candidateNames) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (isSelfReference(beanName, candidate) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#f92672">!&lt;/span>(descriptor &lt;span style="color:#66d9ef">instanceof&lt;/span> MultiElementDescriptor) &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#f92672">!&lt;/span>beanName.&lt;span style="color:#a6e22e">equals&lt;/span>(candidate)) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> isAutowireCandidate(candidate, fallbackDescriptor)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> addCandidateEntry(result, candidate, descriptor, requiredType);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>看完主干自然还是有点迷糊，我们留下了三个问题要继续研究：&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://heeexy.com/2018/01/24/beanNamesForTypeIncludingAncestors/" >如何查找出所有符合类型的 beanName&lt;/a>&lt;/li>
&lt;li>什么是符合装配候选&lt;/li>
&lt;li>什么是回退匹配&lt;/li>
&lt;/ul></description></item><item><title>Spring 源码笔记-2.6 BeanWrapper 对比 MyBatis</title><link>https://heeexy.com/posts/spring-note-14-beanwrapper/</link><pubDate>Fri, 19 Jan 2018 15:21:58 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-14-beanwrapper/</guid><description>&lt;h2 id="spring-vs-mybatis">
&lt;a href="#spring-vs-mybatis" class="header-anchor">#&lt;/a>
Spring vs MyBatis
&lt;/h2>&lt;p>Spring 和 MyBatis 中都有 BeanWrapper , Spring 中为接口， 实现类为 BeanWrapperImpl , 为了方便后面区分，本文用 SB 指代 Spring 的 BeanWrapperImpl ，用 MB 指代 MyBatis 中的 BeanWrapper。&lt;/p>
&lt;h2 id="功能">
&lt;a href="#%e5%8a%9f%e8%83%bd" class="header-anchor">#&lt;/a>
功能
&lt;/h2>&lt;p>BeanWrapper 都属于各自框架的&lt;strong>反射工具箱&lt;/strong>的重要组成部分。都是创建实例并且为其属性赋值的。以 SB 为例，下面的代码应该很容易看明白它的功能。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>BeanWrapper company &lt;span style="color:#f92672">=&lt;/span> BeanWrapperImpl(&lt;span style="color:#66d9ef">new&lt;/span> Company());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// setting the company name..&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>company.&lt;span style="color:#a6e22e">setPropertyValue&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Some Company Inc.&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ... can also be done like this:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PropertyValue value &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> PropertyValue(&lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Some Company Inc.&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>company.&lt;span style="color:#a6e22e">setPropertyValue&lt;/span>(value);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ok, let&amp;#39;s create the director and tie it to the company:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BeanWrapper jim &lt;span style="color:#f92672">=&lt;/span> BeanWrapperImpl(&lt;span style="color:#66d9ef">new&lt;/span> Employee());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jim.&lt;span style="color:#a6e22e">setPropertyValue&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Jim Stravinsky&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>company.&lt;span style="color:#a6e22e">setPropertyValue&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;managingDirector&amp;#34;&lt;/span>, jim.&lt;span style="color:#a6e22e">getWrappedInstance&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// retrieving the salary of the managingDirector through the company&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Float salary &lt;span style="color:#f92672">=&lt;/span> (Float) company.&lt;span style="color:#a6e22e">getPropertyValue&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;managingDirector.salary&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="共同点">
&lt;a href="#%e5%85%b1%e5%90%8c%e7%82%b9" class="header-anchor">#&lt;/a>
共同点
&lt;/h2>&lt;ol>
&lt;li>&lt;strong>核心功能&lt;/strong>功能基本相同&lt;/li>
&lt;li>对要生成的类的要求规范也相同，有 get set 方法。&lt;/li>
&lt;li>它们的&lt;strong>底层&lt;/strong>也没有什么秘密，归根到底都是使用 &lt;code>java.lang.reflect&lt;/code> 包下的 Constructor , Method 等等工具。&lt;/li>
&lt;/ol>
&lt;h2 id="不同点">
&lt;a href="#%e4%b8%8d%e5%90%8c%e7%82%b9" class="header-anchor">#&lt;/a>
不同点
&lt;/h2>&lt;p>可能是我刚开始研究 SB 的原因，感觉 SB 源码更加复杂，结构也没那么清楚，关联了向下层级的工具类，很长很长一段的源码。 &lt;a class="link" href="http://blog.csdn.net/zhiweianran/article/details/7919129" target="_blank" rel="noopener"
>这篇博文&lt;/a> 分析了其中一部分。&lt;/p>
&lt;p>得益于已经学习过结构更为清晰的 MB，尽管 SB 源码复杂，但是读的时候不再会恐惧，因为简略的Debug 一遍就知道它底层还是调 getter/setter 的反射。再复杂的结构也离不开这最终的方法。&lt;/p>
&lt;p>已目前对 SB 粗浅的了解来说，感受到最大的区别就是在工具箱中的&lt;strong>结构地位不同&lt;/strong>。&lt;/p>
&lt;p>MB 属于&lt;code>BaseWrapper&lt;/code> 的子类之一，同级别的还有 MapWrapper ，上级还有 CollectionWrapper 。&lt;/p>
&lt;p>而 SB 就已经是在创建 Bean 时直接使用到的接口了。&lt;/p>
&lt;p>像&lt;strong>解析嵌套参数名&lt;/strong> (比如 user.name / address.city.mailcode)，&lt;strong>类型转换&lt;/strong>这些事情，SB 都能处理完。而 MB 都是先要使用其它工具类处理，比如依靠 PropertyTokenizer 。&lt;/p>
&lt;p>总而言之，SB 就是对外的一个大接口，包含很多功能，MB 则是MyBatis 反射工具箱内的一个小的工具实现。&lt;/p></description></item><item><title>Spring源码笔记-2.5 createBean</title><link>https://heeexy.com/posts/spring-note-13-createbean/</link><pubDate>Thu, 18 Jan 2018 14:22:06 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-13-createbean/</guid><description>&lt;p>此方法交给了 &lt;code>AbstractBeanFactory&lt;/code> 的子类 &lt;code>AbstractAutowireCapableBeanFactory&lt;/code> 去实现。&lt;/p>
&lt;p>并且不管这个bean是单例还是 prototype 还是其它 scope ,最终都是会走到此处，只是前后的一些验证、处理有区别。比如单例的就要先去缓存中获取，prototype 就不需要。&lt;/p>
&lt;p>源码阅读到这里，我们已经习惯了一层一层剥。createBean 依然还是没有直接地把 bean 创建出来（当然我所期望的看到创建 bean 就是看到它的反射源码为止）。&lt;/p>
&lt;p>createBean 的大致步骤为:&lt;/p>
&lt;ol>
&lt;li>根据 RootBeanDefinition 来获取要创建 bean 的 class 。这 class 还有可能为 null。&lt;/li>
&lt;li>prepareMethodOverrides 。准备 override 方法，对 override 属性进行验证。&lt;/li>
&lt;li>给后处理器一个机会来返回代理，替代真正的 bean.&lt;/li>
&lt;li>doCreateBean 创建真正的 bean 实例。&lt;/li>
&lt;/ol>
&lt;h3 id="preparemethodoverrides">
&lt;a href="#preparemethodoverrides" class="header-anchor">#&lt;/a>
prepareMethodOverrides
&lt;/h3>&lt;p>首先去温习一遍 lookup-method 和 replace-method 吧。&lt;a class="link" href="http://blog.csdn.net/qq_22912803/article/details/52503914" target="_blank" rel="noopener"
>博文&lt;/a>&lt;/p>
&lt;p>其实就是通过配置把原本 bean 中的某个方法给替代掉。&lt;/p>
&lt;p>此处我们先只是确认一遍指定的替代方法存在于要生成的 bean 中。&lt;/p>
&lt;p>顺带看一看这个方法有没有重载overload)，做个标记。&lt;/p>
&lt;h3 id="resolvebeforeinstantiation">
&lt;a href="#resolvebeforeinstantiation" class="header-anchor">#&lt;/a>
resolveBeforeInstantiation
&lt;/h3>&lt;p>经过一波预处理器&lt;code>InstantiationAwareBeanPostProcessor&lt;/code> ，如果生产出了 bean，再经过一波后处理器。&lt;/p>
&lt;p>一旦生产出 bean，则立即将此 bean 返回。&lt;/p>
&lt;p>此处就是留下了一个拓展点，经过此方法之后，bean可能已经不是我们认为的 bean 了，而可能已经变成了一个经过处理的代理 bean 。&lt;/p>
&lt;h1 id="循环依赖">
&lt;a href="#%e5%be%aa%e7%8e%af%e4%be%9d%e8%b5%96" class="header-anchor">#&lt;/a>
循环依赖
&lt;/h1>&lt;h4 id="构造器循环依赖">
&lt;a href="#%e6%9e%84%e9%80%a0%e5%99%a8%e5%be%aa%e7%8e%af%e4%be%9d%e8%b5%96" class="header-anchor">#&lt;/a>
构造器循环依赖
&lt;/h4>&lt;p>如果是 prototype，无法解决，只能抛错。&lt;/p>
&lt;p>代码在 &lt;code>AbstractBeanFactory&lt;/code> : 256 &lt;code>doGetBean()&lt;/code> 。&lt;/p>
&lt;p>当创建 bean 时，首先去“当前创建 bean 池”查找是否当前 bean 正在创建，如果发现存在，则表示循环依赖了。抛出 BeanCurrentlyInCreationExcetion 。&lt;/p>
&lt;p>当前创建 bean 池：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> ThreadLocal&lt;span style="color:#f92672">&amp;lt;&lt;/span>Object&lt;span style="color:#f92672">&amp;gt;&lt;/span> prototypesCurrentlyInCreation &lt;span style="color:#f92672">=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">new&lt;/span> NamedThreadLocal&lt;span style="color:#f92672">&amp;lt;&lt;/span>Object&lt;span style="color:#f92672">&amp;gt;&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Prototype beans currently in creation&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="setter-循环依赖">
&lt;a href="#setter-%e5%be%aa%e7%8e%af%e4%be%9d%e8%b5%96" class="header-anchor">#&lt;/a>
setter 循环依赖
&lt;/h4>&lt;p>只能解决单例的情况。&lt;/p>
&lt;p>在创建单例 bean 时，提前暴露刚完成构造器但未完成其他步骤（如 setter 注入）的 bean 。&lt;/p>
&lt;p>通过提前暴露这个单例工厂方法，从而使其他 bean 能够引用到此 bean。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (earlySingletonExposure) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (logger.&lt;span style="color:#a6e22e">isDebugEnabled&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.&lt;span style="color:#a6e22e">debug&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Eagerly caching bean &amp;#39;&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> beanName &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&amp;#39; to allow for resolving potential circular references&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> addSingletonFactory(beanName, &lt;span style="color:#66d9ef">new&lt;/span> ObjectFactory&lt;span style="color:#f92672">&amp;lt;&lt;/span>Object&lt;span style="color:#f92672">&amp;gt;&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Object &lt;span style="color:#a6e22e">getObject&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> BeansException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//注意这里返回的是 早期引用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> getEarlyBeanReference(beanName, mbd, bean);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">protected&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">addSingletonFactory&lt;/span>(String beanName, ObjectFactory&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> singletonFactory) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Assert.&lt;span style="color:#a6e22e">notNull&lt;/span>(singletonFactory, &lt;span style="color:#e6db74">&amp;#34;Singleton factory must not be null&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">synchronized&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">singletonObjects&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">singletonObjects&lt;/span>.&lt;span style="color:#a6e22e">containsKey&lt;/span>(beanName)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//单例工厂注册&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">singletonFactories&lt;/span>.&lt;span style="color:#a6e22e">put&lt;/span>(beanName, singletonFactory);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//早期单例移出&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">earlySingletonObjects&lt;/span>.&lt;span style="color:#a6e22e">remove&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//注册单例加入&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">registeredSingletons&lt;/span>.&lt;span style="color:#a6e22e">add&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>简单地记一下这里解决步骤：&lt;/p>
&lt;p>testA 先创建，并且暴露一个工厂出去，进行 setter 注入 testB.&lt;/p>
&lt;p>testB 创建，并且暴露一个工厂，进行 setter 注入 testA.&lt;/p>
&lt;p>在这里想用 testA 时，&lt;strong>由于发现提前暴露的工厂，从而在此处走了另一条路&lt;/strong>，使用此工厂来创建 testA ,在此处解决了循环问题。&lt;/p>
&lt;p>再返回回去继续完成 testA 的 setter 注入。&lt;/p></description></item><item><title>MyBatis 的日志设计--适配器模式 &amp; 工厂模式</title><link>https://heeexy.com/posts/mybatis%E6%97%A5%E5%BF%97--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 14 Dec 2017 14:45:47 +0000</pubDate><guid>https://heeexy.com/posts/mybatis%E6%97%A5%E5%BF%97--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid><description>&lt;p>​ MyBatis 想要打印日志，时不时想要来句 log.debug() 、log.error() ，需要个打印机 ，可是自己又不想去实现（而且跟着整个项目用同样的打印系统才是王道啊），需要去用别人家的打印机，要用别人家的产品啊，那问题可就来了。&lt;/p>
&lt;h2 id="问题-1">
&lt;a href="#%e9%97%ae%e9%a2%98-1" class="header-anchor">#&lt;/a>
问题 1
&lt;/h2>&lt;p>​ 市面上各家的打印机 slf4j、java.util.logging、log4j 甚至 System.out 都是各种不同的用法，这使用起来就太麻烦了。&lt;/p>
&lt;h4 id="思路">
&lt;a href="#%e6%80%9d%e8%b7%af" class="header-anchor">#&lt;/a>
思路
&lt;/h4>&lt;p>​ 不管市面上打印机有多少型号，我家 MyBatis 包里的类只用自家的统一接口，我家的类只管 log.debug()、log.error()&amp;hellip;&lt;/p>
&lt;p>​ 定义好了接口，就需要实现类 impl 来实现这些 debug()、error() 方法了 , 咱假装是自己来实现，其实去调用真正打印机 slf4、log4j 的方法，这样就把别人家的打印机和咱自家的接口关联起来啦。&lt;/p>
&lt;p>​ 这就是&lt;strong>适配器模式&lt;/strong>。&lt;/p>
&lt;p>​ 我家的每个实现类其实就是一个适配器，每个适配器去适配一种打印机。比如 slf4jLoggerImpl 就完成了对 slf4j 打印机的适配，slf4jLoggerImpl .debug() 调用了slf4j.Logger.debug()。&lt;/p>
&lt;p>​ 这样市面上每多一种打印机，比如想用 log4j2 了，我就只需要加一种适配器 log4j2LoggerImpl 去适配它就可以了。&lt;/p>
&lt;h4 id="代码">
&lt;a href="#%e4%bb%a3%e7%a0%81" class="header-anchor">#&lt;/a>
代码
&lt;/h4>&lt;p>​ 定义接口&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">Log&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isDebugEnabled&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">debug&lt;/span>(String s);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>​ 在实现类里完成适配，比如适配 slf4j 的 &lt;code>Slf4jLoggerImpl&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> org.apache.ibatis.logging.Log;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> org.slf4j.Logger;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Slf4jLoggerImpl&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> Log {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Logger log;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//注意这个地方，入参为 org.slf4j.Logger &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//说明咱这个适配器要用起来，是需要传入一个真正的 slf4j 家的打印机进来的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">Slf4jLoggerImpl&lt;/span>(Logger logger) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log &lt;span style="color:#f92672">=&lt;/span> logger;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//看似外面调用咱 MyBatis 的 Log 的 debug()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//其实是调用 org.slf4j.Logger 的 debug() &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">debug&lt;/span>(String s) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#a6e22e">debug&lt;/span>(s);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="问题-2">
&lt;a href="#%e9%97%ae%e9%a2%98-2" class="header-anchor">#&lt;/a>
问题 2
&lt;/h2>&lt;p>​ 适配器咱是做好了，slf4j、log4j、stdout&amp;hellip;做了那么多适配器，可是怎么用啊？我真正要打印机的时候，怎么才能知道我该调用哪款适配器啊？难道每次取打印机的时候，都去查一遍咱的系统配了那款打印机（jar) 包么？而且以后多加了1种打印机，我还去每个地方都改一遍，都多加一道判断么？&lt;/p>
&lt;h4 id="思路-1">
&lt;a href="#%e6%80%9d%e8%b7%af-1" class="header-anchor">#&lt;/a>
思路
&lt;/h4>&lt;p>​ 这其实就是获取实例的时候的问题，咱获取实例太累了，不如来个统一的工厂吧，我每次想打印的时候，都去找工厂要一台打印机，你工厂按照我 Log 的接口给我一个实例就是了。我也不管你给的具体实现到底是 slf4j 家的，还是 log4j 的，甚至可能是 &lt;code>NoLoggingImpl&lt;/code> 每次调接口都不处理的这种空壳打印机。&lt;/p>
&lt;p>​ 这样一来，有了统一的工厂，判断系统用哪种适配器的任务就可以在工厂完成了。&lt;/p>
&lt;p>​ 而且以后就算新加了打印机，也只要改改工厂的代码，在工厂里多加一重判断就可以了。&lt;/p>
&lt;p>​ 这就是&lt;strong>工厂模式&lt;/strong>。&lt;/p>
&lt;h4 id="代码-1">
&lt;a href="#%e4%bb%a3%e7%a0%81-1" class="header-anchor">#&lt;/a>
代码
&lt;/h4>&lt;p>​&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">LogFactory&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> Constructor&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> Log&lt;span style="color:#f92672">&amp;gt;&lt;/span> logConstructor;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tryImplementation(&lt;span style="color:#66d9ef">new&lt;/span> Runnable() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> useSlf4jLogging();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tryImplementation(&lt;span style="color:#66d9ef">new&lt;/span> Runnable() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> useCommonsLogging();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#a6e22e">LogFactory&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// disable construction&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> Log &lt;span style="color:#a6e22e">getLog&lt;/span>(String logger) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> logConstructor.&lt;span style="color:#a6e22e">newInstance&lt;/span>(logger);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (Throwable t) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>​ LogFactory 提供了对外的 getLog(String logger) 方法，给需要 logger 的地方提供一个 Log 的实例。&lt;/p>
&lt;p>​ 内部的实现依靠 &lt;code>logConstructor&lt;/code> 这个构造器通过反射来实例化一个 Log 的 Impl ，也就是之前的适配器，比如 Slf4jLoggerImpl 。&lt;/p>
&lt;p>​ 判断采用哪种&lt;code>logConstructor&lt;/code> 的任务则在类初始化的时候就执行了，依次尝试了我们的每一款适配器，碰上报错就说明没 jar 包，下一款，全都没有的话，就用 NoLoggingImpl 了。&lt;/p></description></item><item><title>前后端分离实践小结</title><link>https://heeexy.com/posts/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%AE%9E%E8%B7%B5/</link><pubDate>Sun, 29 Oct 2017 00:27:05 +0000</pubDate><guid>https://heeexy.com/posts/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%AE%9E%E8%B7%B5/</guid><description>&lt;h2 id="背景">
&lt;a href="#%e8%83%8c%e6%99%af" class="header-anchor">#&lt;/a>
背景
&lt;/h2>&lt;p>​ 公司项目转型,要开新的运营管理平台,我提议借此开新项目的机会,进行前后端分离,由我负责带领小组新技术学习/分享,探坑填坑.&lt;/p>
&lt;h2 id="分离原因">
&lt;a href="#%e5%88%86%e7%a6%bb%e5%8e%9f%e5%9b%a0" class="header-anchor">#&lt;/a>
分离原因
&lt;/h2>&lt;ol>
&lt;li>最关键一点,受不了jsp/freemarker里一塌糊涂的代码,分离之后,代码按规范写,简洁,好管理&lt;/li>
&lt;li>原本我们后端就一直在给Android/iOS提供接口,本次分离,可以方便以后H5端的项目重构,实现Android+iOS+H5的统一,一套接口可以供三端同时使用,大量节省工作量,也可以更好地保证公司产品质量的统一性.&lt;/li>
&lt;li>方便后端专心处理数据,前端实现页面效果.而不是前端仅仅画页面写css,后端还需要复制粘贴过来,套数据,修改已有页面时,前端更是不方便插手.&lt;/li>
&lt;/ol>
&lt;h2 id="技术选型">
&lt;a href="#%e6%8a%80%e6%9c%af%e9%80%89%e5%9e%8b" class="header-anchor">#&lt;/a>
技术选型
&lt;/h2>&lt;p>​ 组员后端技术都是SSM,前端都只是略接触过AngularJS/Vue.&lt;/p>
&lt;p>​ 我之前接触了一下Spring Boot,感觉配置很清爽,搭框架轻松,业务写起来快,可以让组员无缝切过来,无需费时学习,因此后端框架选定Spring Boot.而登录控制与权限管理一直是公司以前几个项目的弱项,因此本次决定引入shiro,而组员无一对shiro熟悉的,研究shiro的任务自然由我承担.&lt;/p>
&lt;p>​ 前端框架是本次前后端分离的重点,由于我们组无人熟悉前端的新框架,所以这次势必每个人都需要学习许多新的前端知识.我拿公司的H5项目的几个页面进行过搭建vue框架重构练手,认为vue文档清晰,资料丰富,相关开源方案够多,我们这次可以放心学习,使用.(当然最主要的还是因为坑全都得由我来填,得挑个熟悉的)&lt;/p>
&lt;h2 id="目前进展">
&lt;a href="#%e7%9b%ae%e5%89%8d%e8%bf%9b%e5%b1%95" class="header-anchor">#&lt;/a>
目前进展
&lt;/h2>&lt;p>​ 后端:Spring Boot框架搭建完成,shiro可以进行权限管理,自定义拦截器,常用工具类完成,对常用的增删改查,返回结果,异常处理都可以快速搞定.&lt;/p>
&lt;p>​ 前端:数据交互封装完毕,路由熟悉,前端权限管理初步熟悉,选用饿了么开源的Element框架,常用的增删改查的页面元素及工具方法都已让大家掌握.&lt;/p>
&lt;p>​ 本周一开始教组员使用Intellij IDEA,教前端快速铺页面的方法,介绍前后端我封装的各种小轮子.经过一周时间,全部都已熟悉这套新的前后端框架,每个人都可以独立快速地推出常用页面.&lt;/p>
&lt;h2 id="接口端小技巧">
&lt;a href="#%e6%8e%a5%e5%8f%a3%e7%ab%af%e5%b0%8f%e6%8a%80%e5%b7%a7" class="header-anchor">#&lt;/a>
接口端小技巧
&lt;/h2>&lt;p>​ 因为后端全部返回统一json格式的接口,所以我设计了一些小的工具方法,方便快速推出新接口,节省重复代码.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>使用JSONObject而不是实体类&lt;/p>
&lt;p>​ 因为后端业务不算复杂,所以舍弃了实体类的语义性,转而使用阿里的fastjson的JSONObject接收MyBatis返回的结果.比如一个简单的查询只需要&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;select&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;getSimple&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">resultType=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;com.alibaba.fastjson.JSONObject&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SELECT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> s.order_id shopOrderId,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> s.operation operation,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> date_format(s.create_time, &amp;#39;%Y.%m.%d %H:%i:%s&amp;#39;) createTime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FROM shop_order_log s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> WHERE s.user_delete_status = &amp;#34;1&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/select&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>就可以将三个字段shopOrderId,operation,createTime放入json内,字段名称更加灵活,也免去了大量的建实体类,写resultMap的代码.&lt;/p>
&lt;p>​ 更好的一点是,不使用实体类,可以在返回结果中避免掉很多空的需不要的字段.&lt;/p>
&lt;p>​ 还有,因为所有的接口层都返回JSONObject,所以编写工具方法,快速返回成功/失败结果也很简单,我写了多个工具方法,包括入参转json,入参非空校验,返回成功/失败结果,分页,这里就不一一贴出代码了.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>自定义Exception&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CommonJsonException&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> RuntimeException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> JSONObject resultJson;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* 调用时可以在任何代码处直接throws这个Exception,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* 都会统一被拦截,并封装好json返回给前台
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* @param errorEnum 以错误的ErrorEnum做参数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">CommonJsonException&lt;/span>(ErrorEnum errorEnum) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JSONObject jsonObject &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> JSONObject();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CommonUtil.&lt;span style="color:#a6e22e">returnJson&lt;/span>(jsonObject, errorEnum);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">resultJson&lt;/span> &lt;span style="color:#f92672">=&lt;/span> jsonObject;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">CommonJsonException&lt;/span>(JSONObject resultJson) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">resultJson&lt;/span> &lt;span style="color:#f92672">=&lt;/span> resultJson;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> JSONObject &lt;span style="color:#a6e22e">getResultJson&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> resultJson;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@ControllerAdvice&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@ResponseBody&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">GlobalExceptionHandler&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@ExceptionHandler&lt;/span>(CommonJsonException.&lt;span style="color:#a6e22e">class&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> JSONObject &lt;span style="color:#a6e22e">CommonJsonExceptionHandler&lt;/span>(CommonJsonException commonJsonException) &lt;span style="color:#66d9ef">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> commonJsonException.&lt;span style="color:#a6e22e">getResultJson&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;p>在需要返回给前端错误代码编号时,比如校验参数非空,校验手机号失败,可以直接抛出此异常,经错误拦截器拦截到此异常后,可以直接返回错误码给前端,节省大量的判断/返回的代码.这一点也是前阵子从Spring源码中学到的.&lt;/p>
&lt;h2 id="存在的问题">
&lt;a href="#%e5%ad%98%e5%9c%a8%e7%9a%84%e9%97%ae%e9%a2%98" class="header-anchor">#&lt;/a>
存在的问题
&lt;/h2>&lt;ol>
&lt;li>近期主要问题基本都是待我去研究深入的技术,比如shiro的动态权限与vue-router的异步路由的结合,vue组件的通信,vuex的状态管理&lt;/li>
&lt;li>其次是组员需要对vue更加熟悉,我这次要求了大家抛弃jQuery,用数据绑定的思想去写前端.目前大家的前端水平也还只是可以快速复制粘贴出页面,对于复杂的页面和组件,甚至对我们前端项目的目录结构与各部分功能,都不算掌握.&lt;/li>
&lt;li>目前我们所谓的前后端分离其实还只是初步的业务和代码上的分离,以后如果要重构H5项目,可能还需要开NodeJS项目来解决和Android/iOS一样的接口加密问题,统一session管理问题,以及更多的前后端分离可能给我们带来的问题.&lt;/li>
&lt;/ol></description></item><item><title>搭建springboot-shiro-vue框架时遇到的坑</title><link>https://heeexy.com/posts/build-springboot-shiro/</link><pubDate>Sun, 22 Oct 2017 11:19:33 +0000</pubDate><guid>https://heeexy.com/posts/build-springboot-shiro/</guid><description>&lt;p>​ 最近在做前后端分离的新框架,选用了后端springboot+shiro,前端vue+elementUI,第一次搭SSM之外的非demo项目,尤其shiro更是之前从未接触,折腾了很多天,遇到很多问题,大部分能百度出来,剩下的非常费时的问题且称之为坑吧.&lt;/p>
&lt;h3 id="跨域">
&lt;a href="#%e8%b7%a8%e5%9f%9f" class="header-anchor">#&lt;/a>
跨域
&lt;/h3>&lt;p>​ 一大部分问题就是跨域造成的,本身vue-cli搭建的项目可以用&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 1. axios的baseURL设置为/api
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 2. 如下设置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">proxyTable&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;/api&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">target&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;http://127.0.0.1:8080/&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">changeOrigin&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">pathRewrite&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;^/api&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;/&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>来解决开发环境跨域的问题,生产环境反正可以打包静态文件到springboot项目中直接跑.&lt;/p>
&lt;p>而我还是脑抽得选择了强行跨域,假装自己要把静态文件单独放个服务器跑&amp;hellip;为此遇到很多问题,折腾好几天.&lt;/p>
&lt;p>&lt;strong>因此强力推荐上面的方案,简单快捷地解决跨域!&lt;/strong>&lt;/p>
&lt;p>如果生产环境真的需要跨域的话,再按下面方法设置&lt;/p>
&lt;p>大部分跨域的配置都能百度搜出来:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>axios要 &lt;code>withCredentials: true&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用session而不用啥特殊的token之类的话,就不用 &lt;code>config.headers['X-Token'] = getToken() &lt;/code> ,这句是&lt;a class="link" href="https://github.com/PanJiaChen/vueAdmin-template" target="_blank" rel="noopener"
>&lt;strong>vueAdmin-template&lt;/strong>&lt;/a> 中带的,需要删掉.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>后端需要配置允许跨域&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CorsConfig&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> CorsConfiguration &lt;span style="color:#a6e22e">buildConfig&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CorsConfiguration corsConfiguration &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CorsConfiguration();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> corsConfiguration.&lt;span style="color:#a6e22e">addAllowedOrigin&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;*&amp;#34;&lt;/span>); &lt;span style="color:#75715e">// 1 设置访问源地址&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> corsConfiguration.&lt;span style="color:#a6e22e">addAllowedHeader&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;*&amp;#34;&lt;/span>); &lt;span style="color:#75715e">// 2 设置访问源请求头&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> corsConfiguration.&lt;span style="color:#a6e22e">addAllowedMethod&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;*&amp;#34;&lt;/span>); &lt;span style="color:#75715e">// 3 设置访问源请求方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> corsConfiguration.&lt;span style="color:#a6e22e">setAllowCredentials&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> corsConfiguration;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> CorsFilter &lt;span style="color:#a6e22e">corsFilter&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> UrlBasedCorsConfigurationSource source &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> UrlBasedCorsConfigurationSource();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> source.&lt;span style="color:#a6e22e">registerCorsConfiguration&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/**&amp;#34;&lt;/span>, buildConfig()); &lt;span style="color:#75715e">// 4 对接口配置跨域设置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CorsFilter(source);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;h3 id="shiro拦截ajax返回json">
&lt;a href="#shiro%e6%8b%a6%e6%88%aaajax%e8%bf%94%e5%9b%9ejson" class="header-anchor">#&lt;/a>
shiro拦截ajax返回json
&lt;/h3>&lt;p>​ shiro拦截到需要登录而用户尚未的请求时,会重定向至 /login/auth (未配置时是login.jsp),而ajax是不允许重定向的,ajax会收到302错误码,报错&lt;/p>
&lt;blockquote>
&lt;p>Failed to load http://localhost:8080/test: Redirect from &amp;lsquo;http://localhost:8080/test&amp;rsquo; to &amp;lsquo;http://localhost:8080/login/auth&amp;rsquo; has been blocked by CORS policy: No &amp;lsquo;Access-Control-Allow-Origin&amp;rsquo; header is present on the requested resource. Origin &amp;lsquo;http://localhost:9528&amp;rsquo; is therefore not allowed access.&lt;/p>
&lt;/blockquote>
&lt;p>因此我们需要对拦截器进行改造,不要它默认的重定向了,我们直接去response里把json写好输出给前端.&lt;/p>
&lt;p>自定义filter,(因为我的后端全部返回json,所以这里不判断是否ajax了)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">AjaxPermissionsAuthorizationFilter&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> FormAuthenticationFilter {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">protected&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">onAccessDenied&lt;/span>(ServletRequest request, ServletResponse response) &lt;span style="color:#66d9ef">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JSONObject jsonObject &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> JSONObject();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jsonObject.&lt;span style="color:#a6e22e">put&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;returnMsg&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;未登录或登录已失效&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">isLoginRequest&lt;/span>(request, response)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">isLoginSubmission&lt;/span>(request, response)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">executeLogin&lt;/span>(request, response);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PrintWriter out &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HttpServletResponse res &lt;span style="color:#f92672">=&lt;/span> (HttpServletResponse) response;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//下面这几行也是后面要讲的坑, 这里的Access-Control-Allow-Origin 设置为*的话,前端还是会报错. &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res.&lt;span style="color:#a6e22e">setHeader&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Access-Control-Allow-Origin&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;http://localhost:9528&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// response1.setHeader(&amp;#34;Access-Control-Allow-Origin&amp;#34;, &amp;#34;*&amp;#34;);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res.&lt;span style="color:#a6e22e">setHeader&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Access-Control-Allow-Credentials&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res.&lt;span style="color:#a6e22e">setCharacterEncoding&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;UTF-8&amp;#34;&lt;/span>);&lt;span style="color:#75715e">//设置编码&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> res.&lt;span style="color:#a6e22e">setContentType&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;application/json&amp;#34;&lt;/span>);&lt;span style="color:#75715e">//设置返回类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out &lt;span style="color:#f92672">=&lt;/span> response.&lt;span style="color:#a6e22e">getWriter&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out.&lt;span style="color:#a6e22e">println&lt;/span>(jsonObject);&lt;span style="color:#75715e">//输出&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> out) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out.&lt;span style="color:#a6e22e">flush&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out.&lt;span style="color:#a6e22e">close&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来就是最坑的地方了,拦截器的注入.&lt;/p>
&lt;p>&lt;a class="link" href="http://m.blog.csdn.net/u014042146/article/details/72834582" target="_blank" rel="noopener"
>原本搜到的方法&lt;/a>是在ShiroConfiguration类中注入.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Bean&lt;/span>(name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;ajaxPermissionsAuthorizationFilter&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> AjaxPermissionsAuthorizationFilter &lt;span style="color:#a6e22e">ajaxPermissionsAuthorizationFilter&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> AjaxPermissionsAuthorizationFilter();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//然后shiroFilterFactoryBean设置过滤器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Filter&lt;span style="color:#f92672">&amp;gt;&lt;/span> filterMap &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> LinkedHashMap&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> filterMap.&lt;span style="color:#a6e22e">put&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;authc&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">new&lt;/span> AjaxPermissionsAuthorizationFilter());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shiroFilterFactoryBean.&lt;span style="color:#a6e22e">setFilters&lt;/span>(filterMap);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>结果自定义的拦截器把所有的请求都拦截了,直接无视了我设置的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>filterChainDefinitionMap.&lt;span style="color:#a6e22e">put&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;anon&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>filterChainDefinitionMap.&lt;span style="color:#a6e22e">put&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/static/**&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;anon&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>filterChainDefinitionMap.&lt;span style="color:#a6e22e">put&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/login/**&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;anon&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>filterChainDefinitionMap.&lt;span style="color:#a6e22e">put&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/error&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;anon&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>filterChainDefinitionMap.&lt;span style="color:#a6e22e">put&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/**&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;authc&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>各种百度,能搜到的相关的资料也就只有&lt;a class="link" href="https://segmentfault.com/q/1010000010747919" target="_blank" rel="noopener"
>segmentfault的提问没解决,题主给我的回复也不能解决&lt;/a> , &lt;a class="link" href="https://zhidao.baidu.com/question/436777330932025604.html" target="_blank" rel="noopener"
>百度知道提问的没解决&lt;/a> , &lt;a class="link" href="http://www.jianshu.com/p/e30dc5e78641" target="_blank" rel="noopener"
>简书方案并不能解决&lt;/a> .&lt;/p>
&lt;p>最终在某个百度结果的第三页找到&lt;a class="link" href="http://www.hillfly.com/2017/179.html" target="_blank" rel="noopener"
>这篇博客&lt;/a> ,博主对问题一步一步的排查分析,debug源码,最终知道&lt;/p>
&lt;p>&lt;strong>Springboot 先加载了我们自定义的 Filter，然后再加载了 ShiroFilter&lt;/strong>&lt;/p>
&lt;p>解决方法:
在自定义的filter里加上下面的代码&lt;/p>
&lt;pre tabindex="0">&lt;code>@Bean
public FilterRegistrationBean registration(自定义Filter filter) {
FilterRegistrationBean registration = new FilterRegistrationBean(filter);
registration.setEnabled(false);
return registration;
}
&lt;/code>&lt;/pre>&lt;p>在configration类里就不需要声明这个bean,只需要直接调用 &lt;code>filterMap.put(&amp;quot;authc&amp;quot;, new 自定义Filter());&lt;/code>&lt;/p>
&lt;h3 id="access-control-allow-origin">
&lt;a href="#access-control-allow-origin" class="header-anchor">#&lt;/a>
Access-Control-Allow-Origin
&lt;/h3>&lt;p>在上面的自定义filter里,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> res.&lt;span style="color:#a6e22e">setHeader&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Access-Control-Allow-Origin&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;http://localhost:9528&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果设置为*的话,前端虽然可以收到json,但还是会报错&lt;/p>
&lt;blockquote>
&lt;p>Failed to load http://localhost:8080/test: The value of the &amp;lsquo;Access-Control-Allow-Origin&amp;rsquo; header in the response must not be the wildcard &amp;lsquo;*&amp;rsquo; when the request&amp;rsquo;s credentials mode is &amp;lsquo;include&amp;rsquo;. Origin &amp;lsquo;http://localhost:9528&amp;rsquo; is therefore not allowed access. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.&lt;/p>
&lt;/blockquote>
&lt;p>不允许设置为通配符* .&lt;/p>
&lt;p>虽然此处设置了&amp;quot;http://localhost:9528&amp;quot; 但是这种做法终究不合适.&lt;/p>
&lt;p>百度继续搜到&lt;a class="link" href="http://blog.csdn.net/u011517841/article/details/68490586" target="_blank" rel="noopener"
>此博客&lt;/a>&lt;/p>
&lt;p>得到解决方法&lt;/p>
&lt;pre tabindex="0">&lt;code>res.setHeader(&amp;#34;Access-Control-Allow-Origin&amp;#34;, ((HttpServletRequest) request).getHeader(&amp;#34;Origin&amp;#34;));
&lt;/code>&lt;/pre></description></item><item><title>Spring源码笔记-2.4 获取单例</title><link>https://heeexy.com/posts/spring-note-12-%E8%8E%B7%E5%8F%96%E5%8D%95%E4%BE%8B/</link><pubDate>Fri, 29 Sep 2017 22:49:00 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-12-%E8%8E%B7%E5%8F%96%E5%8D%95%E4%BE%8B/</guid><description>&lt;h2 id="获取单例bean-getsingleton">
&lt;a href="#%e8%8e%b7%e5%8f%96%e5%8d%95%e4%be%8bbean-getsingleton" class="header-anchor">#&lt;/a>
获取单例bean &lt;code>getSingleton&lt;/code>
&lt;/h2>&lt;blockquote>
&lt;p>明明之前一篇已经讲过了获取单例,为什么这里又是获取单例bean呢?&lt;/p>
&lt;p>两天不看书,果断又忘了.前面学的是&lt;strong>从缓存中&lt;/strong>获取,这里是真正的获取.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>DefaultSingletonBeanRegistry&lt;/code> 中重载此方法,第二参数为ObjectFactory&lt;!-- raw HTML omitted -->&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Object &lt;span style="color:#a6e22e">getSingleton&lt;/span>(String beanName, ObjectFactory&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> singletonFactory) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Assert.&lt;span style="color:#a6e22e">notNull&lt;/span>(beanName, &lt;span style="color:#e6db74">&amp;#34;&amp;#39;beanName&amp;#39; must not be null&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//这里再次看到了这个singletonObjects,上篇文章介绍过,是维护了单例对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//书中说法是:用于保存BeanName和创建bean实例之间的关系&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map var3 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">singletonObjects&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">synchronized&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">singletonObjects&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object singletonObject &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">singletonObjects&lt;/span>.&lt;span style="color:#a6e22e">get&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//首先获取一遍,如果不存在,才去创建&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (singletonObject &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//工厂如果正在销毁,这时候获取bean就会报错&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">singletonsCurrentlyInDestruction&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BeanCreationNotAllowedException(beanName, &lt;span style="color:#e6db74">&amp;#34;Singleton bean creation not allowed while the singletons of this factory are in destruction (Do not request a bean from a BeanFactory in a destroy method implementation!)&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">logger&lt;/span>.&lt;span style="color:#a6e22e">isDebugEnabled&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//打印日志,正在创建单例bean(beanName)的共享的实例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">logger&lt;/span>.&lt;span style="color:#a6e22e">debug&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Creating shared instance of singleton bean &amp;#39;&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> beanName &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#39;&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//标志这个beanName正在创建,如果同时重复创建,会报错&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">beforeSingletonCreation&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span> newSingleton &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span> recordSuppressedExceptions &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">suppressedExceptions&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (recordSuppressedExceptions) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">suppressedExceptions&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> LinkedHashSet();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//=============这里应该是最关键的创建bean的步骤===============&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> singletonObject &lt;span style="color:#f92672">=&lt;/span> singletonFactory.&lt;span style="color:#a6e22e">getObject&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//标识新创建出来的单例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> newSingleton &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (IllegalStateException var16) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//非法状态错误,应该是创建过程中发现存在其他线程已创建此单例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//所以此处catch里面再次调用了singletonObjects.get(beanName);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> singletonObject &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">singletonObjects&lt;/span>.&lt;span style="color:#a6e22e">get&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (singletonObject &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> var16;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (BeanCreationException var17) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//其它创建bean错误&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BeanCreationException ex &lt;span style="color:#f92672">=&lt;/span> var17;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (recordSuppressedExceptions) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Iterator var8 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">suppressedExceptions&lt;/span>.&lt;span style="color:#a6e22e">iterator&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(var8.&lt;span style="color:#a6e22e">hasNext&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Exception suppressedException &lt;span style="color:#f92672">=&lt;/span> (Exception)var8.&lt;span style="color:#a6e22e">next&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//把其它recordSuppressedExceptions塞入这个ex一并抛出&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ex.&lt;span style="color:#a6e22e">addRelatedCause&lt;/span>(suppressedException);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> ex;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (recordSuppressedExceptions) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">suppressedExceptions&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//确认这个beanName在几个set中的状态&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">afterSingletonCreation&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (newSingleton) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果是新创建的,则加入缓存,移除几个新创建的标识,名字加入registeredSingletons&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">addSingleton&lt;/span>(beanName, singletonObject);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//返回,如果是NULL_OBJECT也作为null返回.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//这个NULL_OBJECT应该是在前面的获取方法中有可能的特殊返回值&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> singletonObject &lt;span style="color:#f92672">!=&lt;/span> NULL_OBJECT &lt;span style="color:#f92672">?&lt;/span> singletonObject : &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从上可以看出,获取单例还是通过 &lt;code>synchronized(this.singletonObjects)&lt;/code> 加锁来实现，先从 &lt;code>singletonObjects&lt;/code> 查一遍有没有已存在的，若没有则再进行创建。&lt;/p>
&lt;p>而创建的步骤，则是在入参的 &lt;code> ObjectFactory&amp;lt;?&amp;gt;&lt;/code> 中完成，调用其 getObject() 依然还是调用我们本身&lt;code>AbstractBeanFactory&lt;/code> 的 &lt;code>createBean&lt;/code> 方法。&lt;/p>
&lt;hr>
&lt;p>我们先不急着往下看，先理一理，首先第一点要知道的是单例加锁都是 &lt;code>synchronized(this.singletonObjects)&lt;/code> 。其次获取单例 bean 的大致步骤，无非就是：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>上一文中介绍的，从缓存中拿，并且允许“早期引用” ，即从 &lt;code>earlySingletonObjects&lt;/code> 中拿。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果缓存中没有，则自己创建，&lt;/p>
&lt;p>2.1 在各种 map 里记录它的 创建、销毁等信息&lt;/p>
&lt;p>2.2 通过&lt;code>createBean&lt;/code> 方法去具体创建这个实例。&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>Spring源码笔记-2.3 缓存中获取单例bean及获取对象</title><link>https://heeexy.com/posts/spring-note-11-getsingleton/</link><pubDate>Tue, 26 Sep 2017 23:28:00 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-11-getsingleton/</guid><description>&lt;h2 id="缓存中获取单例bean-getsingleton">
&lt;a href="#%e7%bc%93%e5%ad%98%e4%b8%ad%e8%8e%b7%e5%8f%96%e5%8d%95%e4%be%8bbean-getsingleton" class="header-anchor">#&lt;/a>
缓存中获取单例bean &lt;code>getSingleton&lt;/code>
&lt;/h2>&lt;p>&lt;code>DefaultSingletonBeanRegistry&lt;/code> 中实现此方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//这个map维护了单例对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Object&lt;span style="color:#f92672">&amp;gt;&lt;/span> singletonObjects &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ConcurrentHashMap(256);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//当前正在创建中的单例对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Set&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> singletonsCurrentlyInCreation &lt;span style="color:#f92672">=&lt;/span> Collections.&lt;span style="color:#a6e22e">newSetFromMap&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> ConcurrentHashMap(16));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//早期单例对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Object&lt;span style="color:#f92672">&amp;gt;&lt;/span> earlySingletonObjects &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashMap(16);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//单例工厂?&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, ObjectFactory&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&amp;gt;&lt;/span> singletonFactories &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashMap(16);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">protected&lt;/span> Object &lt;span style="color:#a6e22e">getSingleton&lt;/span>(String beanName, &lt;span style="color:#66d9ef">boolean&lt;/span> allowEarlyReference) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object singletonObject &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">singletonObjects&lt;/span>.&lt;span style="color:#a6e22e">get&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果根据这个beanName没取到对象,但发现这个对象还在创建中.....&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (singletonObject &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">isSingletonCurrentlyInCreation&lt;/span>(beanName)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map var4 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">singletonObjects&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">synchronized&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">singletonObjects&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> singletonObject &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">earlySingletonObjects&lt;/span>.&lt;span style="color:#a6e22e">get&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果早期单例对象中没有此bean,并且允许早期依赖&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (singletonObject &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> allowEarlyReference) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//当某些方法需要提前初始化的时候则会调用 addSingletonFactory方法将对应的ObjectFactory初始化策略存储在singletonFactories&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ObjectFactory&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> singletonFactory &lt;span style="color:#f92672">=&lt;/span> (ObjectFactory)&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">singletonFactories&lt;/span>.&lt;span style="color:#a6e22e">get&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (singletonFactory &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//调用预先设定的getObject方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> singletonObject &lt;span style="color:#f92672">=&lt;/span> singletonFactory.&lt;span style="color:#a6e22e">getObject&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//记录在缓存中,earlySingletonObjects 和 singletonFactories互斥&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">earlySingletonObjects&lt;/span>.&lt;span style="color:#a6e22e">put&lt;/span>(beanName, singletonObject);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">singletonFactories&lt;/span>.&lt;span style="color:#a6e22e">remove&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> singletonObject &lt;span style="color:#f92672">!=&lt;/span> NULL_OBJECT &lt;span style="color:#f92672">?&lt;/span> singletonObject : &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="http://ots7yt7am.bkt.clouddn.com/blog/DefaultSingletonBeanRegistry.png"
loading="lazy"
>&lt;/p>
&lt;p>这里还是看得迷迷糊糊的,毕竟一来就各种取值, 往后看看在哪塞值的吧!&lt;/p>
&lt;h2 id="从bean的实例中获取对象-getobjectforbeaninstance">
&lt;a href="#%e4%bb%8ebean%e7%9a%84%e5%ae%9e%e4%be%8b%e4%b8%ad%e8%8e%b7%e5%8f%96%e5%af%b9%e8%b1%a1-getobjectforbeaninstance" class="header-anchor">#&lt;/a>
从bean的实例中获取对象 &lt;code>getObjectForBeanInstance&lt;/code>
&lt;/h2>&lt;p>​ 我们得到bean的实例后要做的第一步都是调用这个方法来检测一下正确性,其实就是用于检测当前bean是否是&lt;code>FactoryBean&lt;/code> 类型的bean,如果是,就要调用&lt;code>getObject()&lt;/code> 方法作为返回值&lt;/p>
&lt;p>​ &lt;a class="link" href="http://heeexy.com/2017/09/26/FactoryBean/" target="_blank" rel="noopener"
>FactoryBean&lt;/a> 在之前我们便已经接触过.&lt;/p>
&lt;p>​ &lt;code>getObjectForBeanInstance&lt;/code> 方法就不贴了, 主要就是各种验证, 取缓存等等, 里面需要注释的一段如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//将存储XML配置文件的GernericBeanDefinition 转换为RootBeanDefinition,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果指定BeanName是子bean的话,同时会合并父类的相关属性&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (mbd &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">containsBeanDefinition&lt;/span>(beanName)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mbd &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getMergedLocalBeanDefinition&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>​ 方法中的关键是 &lt;code>getObjectFromFactoryBean&lt;/code> , 实现类为 &lt;code>FactoryBeanRegistrySupport&lt;/code>&lt;/p>
&lt;p>​ 而 &lt;code>getObjectFromFactoryBean&lt;/code> 方法中也还不是最核心的, 其代码主要是保证单例bean的全局唯一. 如果是单例,那就不用重复创建,可以使用缓存来提高性能. 另外方法还根据需要对bean进行了后处理&lt;code>postProcessObjectFromFactoryBean()&lt;/code>&lt;/p>
&lt;p>&lt;strong>后处理&lt;/strong>即是遍历所有的bean后处理器,在bean初始化后调用它的处理方法,后面还会详细学习.&lt;/p>
&lt;p>​ 它的关键是 &lt;code>doGetObjectFromFactoryBean&lt;/code> ,方法名前面多加了个do&amp;hellip;&lt;/p>
&lt;pre>&lt;code>在这个方法里面,我们终于看到想要看到的 `object = factory.getObject();` ,虽然早已知道必须要走到这,但是到这一步`getObject()` 还是绕了很多路,包括到这里居然还使用了`java.security.AccessController` 权限验证...
&lt;/code>&lt;/pre>
&lt;p>​&lt;/p></description></item><item><title>Spring源码笔记-2.2 FactoryBean</title><link>https://heeexy.com/posts/spring-note-10-factorybean/</link><pubDate>Tue, 26 Sep 2017 14:47:00 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-10-factorybean/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> org.springframework.beans.factory;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">FactoryBean&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//返回由FactoryBean创建的bean实例,如果isSingleton()返回true,则该实例会放到Spring容器中单实例缓存池中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T &lt;span style="color:#a6e22e">getObject&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> Exception;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//返回FactoryBean创建的bean类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Class&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> getObjectType();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//返回bean实例的作用域是singleton还是prototype&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isSingleton&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>​ 当配置文件&lt;!-- raw HTML omitted -->的class属性配置的实现类是&lt;code>FactoryBean&lt;/code> 时,通过&lt;code>getBean()&lt;/code> 方法返回的不是&lt;code>FactoryBean&lt;/code> 本身,而是&lt;code>FactoryBean.getObject()&lt;/code> 方法所返回的对象.&lt;/p>
&lt;p>​ 相当于&lt;code>FactoryBean.getObject()&lt;/code> 代理了&lt;code>getBean()&lt;/code> 方法.&lt;/p>
&lt;p>​ 例如,如果使用传统方式配置Car的bean,Car的每个属性对应一个&lt;!-- raw HTML omitted --> 元素标签&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Car&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxSpeed;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String brand;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">double&lt;/span> price;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//get/set&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>​ 如果使用FactoryBean的方式就会灵活一些,下面通过逗号分隔符的方式一次性地为Car的所有属性指定配置值:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CarFactoryBean&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> FactoryBean&lt;span style="color:#f92672">&amp;lt;&lt;/span>Car&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String carInfo;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Car &lt;span style="color:#a6e22e">getObject&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Car car &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Car();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String&lt;span style="color:#f92672">[]&lt;/span> infos &lt;span style="color:#f92672">=&lt;/span> carInfo.&lt;span style="color:#a6e22e">split&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;,&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> car.&lt;span style="color:#a6e22e">setBrand&lt;/span>(infos&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> car.&lt;span style="color:#a6e22e">setMaxSpeed&lt;/span>(Integer.&lt;span style="color:#a6e22e">valueOf&lt;/span>(infos&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">]&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> car.&lt;span style="color:#a6e22e">setPrice&lt;/span>(Double.&lt;span style="color:#a6e22e">valueOf&lt;/span>(infos&lt;span style="color:#f92672">[&lt;/span>2&lt;span style="color:#f92672">]&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> car;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Class&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> getObjectType() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Car.&lt;span style="color:#a6e22e">class&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isSingleton&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getCarInfo&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> carInfo;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setCarInfo&lt;/span>(String carInfo) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">carInfo&lt;/span> &lt;span style="color:#f92672">=&lt;/span> carInfo;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>有了这个CarFactoryBean之后,就可以在配置文件使用下面这种自定义的配置方式配置Car bean了&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;bean&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;car&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">class=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;com.test.factoryBean.CarFactoryBean&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">carInfo=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;超级跑车,400,3000&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>调用 getBean(&amp;ldquo;car&amp;rdquo;) , Spring并不会返回&lt;code>CarFactoryBean&lt;/code> 而是返回car&lt;/p>
&lt;p>如果希望返回&lt;code>CarFactoryBean&lt;/code> 那就 getBean(&amp;quot;&amp;amp;car&amp;quot;)&lt;/p>
&lt;hr>
&lt;p>书本作者讲到&lt;code>FactoryBean&lt;/code> 接口对于Spring框架很关键, Spring自身就提供了70多个实现.&lt;/p>
&lt;p>它们隐藏了实例化一些复杂的bean的细节,给上层应用带来了便利.&lt;/p>
&lt;blockquote>
&lt;p>疑问: 具体哪些地方用&lt;code>FactoryBean&lt;/code> 带来了真正的便利呢?&lt;/p>
&lt;p>答:&lt;/p>
&lt;/blockquote></description></item><item><title>Spring源码笔记-2.1 bean的加载初探</title><link>https://heeexy.com/posts/spring-note-9-beanload/</link><pubDate>Tue, 26 Sep 2017 11:16:00 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-9-beanload/</guid><description>&lt;h3 id="本文要看啥">
&lt;a href="#%e6%9c%ac%e6%96%87%e8%a6%81%e7%9c%8b%e5%95%a5" class="header-anchor">#&lt;/a>
本文要看啥?
&lt;/h3>&lt;p>​ 前面已经了解了bean从配置文件到解析成BDHolder到注册的流程,我们已经将bean的信息封装好,塞入了map中,这个map可能在不同的实现里面,前面重点学的就是DefaultListableBeanFactory里的beanDefinitionMap.&lt;/p>
&lt;p>​ 我们现在要探索bean的加载,围绕最初的示例代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> MyTestBean bean &lt;span style="color:#f92672">=&lt;/span>(MyTestBean)bf.&lt;span style="color:#a6e22e">getBean&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;myTestBean&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>​ BeanFactory是个接口,其下实现关系很复杂, getBean方法的实现主要是在&lt;code>AbstractBeanFactory&lt;/code> 这一层.&lt;/p>
&lt;p>​ 本文就是先来快速体验一下加载bean的大体流程&lt;/p>
&lt;h3 id="进入代码吧">
&lt;a href="#%e8%bf%9b%e5%85%a5%e4%bb%a3%e7%a0%81%e5%90%a7" class="header-anchor">#&lt;/a>
进入代码吧
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">protected&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> T &lt;span style="color:#a6e22e">doGetBean&lt;/span>(String name, Class&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> requiredType, &lt;span style="color:#66d9ef">final&lt;/span> Object&lt;span style="color:#f92672">[]&lt;/span> args, &lt;span style="color:#66d9ef">boolean&lt;/span> typeCheckOnly) &lt;span style="color:#66d9ef">throws&lt;/span> BeansException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//转换beanName&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> String beanName &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">transformedBeanName&lt;/span>(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//根据beanName找其单例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object sharedInstance &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getSingleton&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object bean;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (sharedInstance &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> args &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">logger&lt;/span>.&lt;span style="color:#a6e22e">isDebugEnabled&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">isSingletonCurrentlyInCreation&lt;/span>(beanName)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">logger&lt;/span>.&lt;span style="color:#a6e22e">debug&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Returning eagerly cached instance of singleton bean &amp;#39;&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> beanName &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#39; that is not fully initialized yet - a consequence of a circular reference&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">logger&lt;/span>.&lt;span style="color:#a6e22e">debug&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Returning cached instance of singleton bean &amp;#39;&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> beanName &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#39;&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//返回对应的实例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bean &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getObjectForBeanInstance&lt;/span>(sharedInstance, name, beanName, (RootBeanDefinition)&lt;span style="color:#66d9ef">null&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//原型模式下,如果这个bean已经正在创建中,说明是如下情况&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//A中有B的属性,B中有A的属性,当依赖注入的时候,就回产生当A还未创建完的时候,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//因为对于B的创建,再次返回创建A,造成循环依赖&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//所以就会报错&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">isPrototypeCurrentlyInCreation&lt;/span>(beanName)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BeanCurrentlyInCreationException(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//获取父工厂&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BeanFactory parentBeanFactory &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getParentBeanFactory&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果本工厂没有这个bean,存在父工厂,就去父工厂找&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (parentBeanFactory &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">containsBeanDefinition&lt;/span>(beanName)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String nameToLookup &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">originalBeanName&lt;/span>(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//注意下面是递归地去父工厂找&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (args &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> parentBeanFactory.&lt;span style="color:#a6e22e">getBean&lt;/span>(nameToLookup, args);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> parentBeanFactory.&lt;span style="color:#a6e22e">getBean&lt;/span>(nameToLookup, requiredType);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果不是仅仅做类检查则是创建bean,这里要进行记录&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>typeCheckOnly) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">markBeanAsCreated&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> RootBeanDefinition mbd &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getMergedLocalBeanDefinition&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">checkMergedBeanDefinition&lt;/span>(mbd, beanName, args);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String&lt;span style="color:#f92672">[]&lt;/span> dependsOn &lt;span style="color:#f92672">=&lt;/span> mbd.&lt;span style="color:#a6e22e">getDependsOn&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String&lt;span style="color:#f92672">[]&lt;/span> var11;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果存在依赖,就递归地先去实例化依赖的bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (dependsOn &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> var11 &lt;span style="color:#f92672">=&lt;/span> dependsOn;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> var12 &lt;span style="color:#f92672">=&lt;/span> dependsOn.&lt;span style="color:#a6e22e">length&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> var13 &lt;span style="color:#f92672">=&lt;/span> 0; var13 &lt;span style="color:#f92672">&amp;lt;&lt;/span> var12; &lt;span style="color:#f92672">++&lt;/span>var13) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String dep &lt;span style="color:#f92672">=&lt;/span> var11&lt;span style="color:#f92672">[&lt;/span>var13&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">isDependent&lt;/span>(beanName, dep)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BeanCreationException(mbd.&lt;span style="color:#a6e22e">getResourceDescription&lt;/span>(), beanName, &lt;span style="color:#e6db74">&amp;#34;Circular depends-on relationship between &amp;#39;&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> beanName &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#39; and &amp;#39;&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> dep &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#39;&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">registerDependentBean&lt;/span>(dep, beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getBean&lt;/span>(dep);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (mbd.&lt;span style="color:#a6e22e">isSingleton&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//单例模式的创建&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sharedInstance &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getSingleton&lt;/span>(beanName, &lt;span style="color:#66d9ef">new&lt;/span> ObjectFactory&lt;span style="color:#f92672">&amp;lt;&lt;/span>Object&lt;span style="color:#f92672">&amp;gt;&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Object &lt;span style="color:#a6e22e">getObject&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> BeansException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> AbstractBeanFactory.&lt;span style="color:#a6e22e">this&lt;/span>.&lt;span style="color:#a6e22e">createBean&lt;/span>(beanName, mbd, args);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (BeansException var2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AbstractBeanFactory.&lt;span style="color:#a6e22e">this&lt;/span>.&lt;span style="color:#a6e22e">destroySingleton&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> var2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bean &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getObjectForBeanInstance&lt;/span>(sharedInstance, name, beanName, mbd);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (mbd.&lt;span style="color:#a6e22e">isPrototype&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//原型模式的创建&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> var11 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object prototypeInstance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//创建原型之前,先把prototypesCurrentlyInCreation里塞值,表示当前正在创建哪些原型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">beforePrototypeCreation&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//注意到createBean这个方法留给了子类去实现&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prototypeInstance &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">createBean&lt;/span>(beanName, mbd, args);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//移出prototypesCurrentlyInCreation,表示创建这个原型结束&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">afterPrototypeCreation&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bean &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getObjectForBeanInstance&lt;/span>(prototypeInstance, name, beanName, mbd);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//其它模式的创建(指定的scope上实例化bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String scopeName &lt;span style="color:#f92672">=&lt;/span> mbd.&lt;span style="color:#a6e22e">getScope&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Scope scope &lt;span style="color:#f92672">=&lt;/span> (Scope)&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">scopes&lt;/span>.&lt;span style="color:#a6e22e">get&lt;/span>(scopeName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (scope &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> IllegalStateException(&lt;span style="color:#e6db74">&amp;#34;No Scope registered for scope name &amp;#39;&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> scopeName &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#39;&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object scopedInstance &lt;span style="color:#f92672">=&lt;/span> scope.&lt;span style="color:#a6e22e">get&lt;/span>(beanName, &lt;span style="color:#66d9ef">new&lt;/span> ObjectFactory&lt;span style="color:#f92672">&amp;lt;&lt;/span>Object&lt;span style="color:#f92672">&amp;gt;&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Object &lt;span style="color:#a6e22e">getObject&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> BeansException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AbstractBeanFactory.&lt;span style="color:#a6e22e">this&lt;/span>.&lt;span style="color:#a6e22e">beforePrototypeCreation&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object var1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> var1 &lt;span style="color:#f92672">=&lt;/span> AbstractBeanFactory.&lt;span style="color:#a6e22e">this&lt;/span>.&lt;span style="color:#a6e22e">createBean&lt;/span>(beanName, mbd, args);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>AbstractBeanFactory.&lt;span style="color:#a6e22e">this&lt;/span>.&lt;span style="color:#a6e22e">afterPrototypeCreation&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> var1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bean &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getObjectForBeanInstance&lt;/span>(scopedInstance, name, beanName, mbd);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (IllegalStateException var21) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BeanCreationException(beanName, &lt;span style="color:#e6db74">&amp;#34;Scope &amp;#39;&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> scopeName &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#39; is not active for the current thread; consider defining a scoped proxy for this bean if you intend to refer to it from a singleton&amp;#34;&lt;/span>, var21);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (BeansException var23) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">cleanupAfterBeanCreationFailure&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> var23;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (requiredType &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> bean &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>requiredType.&lt;span style="color:#a6e22e">isAssignableFrom&lt;/span>(bean.&lt;span style="color:#a6e22e">getClass&lt;/span>())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//检查类型是否符合bean的实际类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getTypeConverter&lt;/span>().&lt;span style="color:#a6e22e">convertIfNecessary&lt;/span>(bean, requiredType);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (TypeMismatchException var22) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">logger&lt;/span>.&lt;span style="color:#a6e22e">isDebugEnabled&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">logger&lt;/span>.&lt;span style="color:#a6e22e">debug&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Failed to convert bean &amp;#39;&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> name &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#39; to required type &amp;#39;&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> ClassUtils.&lt;span style="color:#a6e22e">getQualifiedName&lt;/span>(requiredType) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#39;&amp;#34;&lt;/span>, var22);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BeanNotOfRequiredTypeException(name, requiredType, bean.&lt;span style="color:#a6e22e">getClass&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> bean;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="提炼大致步骤">
&lt;a href="#%e6%8f%90%e7%82%bc%e5%a4%a7%e8%87%b4%e6%ad%a5%e9%aa%a4" class="header-anchor">#&lt;/a>
提炼大致步骤
&lt;/h4>&lt;p>这120多行的代码,Spring都并没有再进行重构,可见其复杂程度,辛亏有书本解释,了解到大致步骤:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>转换对应的beanName,因为传入的参数可能是alias&lt;/p>
&lt;p>从其具体方法中看,是之前见过的, 处理&lt;code>&amp;amp;&lt;/code> 和别名的递归寻找本名.&lt;/p>
&lt;p>去前面笔记中寻找,在 &lt;a class="link" href="http://heeexy.com/2017/09/15/spring_SimpleAliasRegistry/" target="_blank" rel="noopener"
>SimpleAliasRegistry&lt;/a> 中已经研究过此方法&lt;/p>
&lt;/li>
&lt;li>
&lt;p>尝试从缓存中加载单例&lt;/p>
&lt;p>此时可能从缓存中取出的是还没创建好的bean,主要是因为防止循环依赖&lt;/p>
&lt;/li>
&lt;li>
&lt;p>bean的实例化&lt;/p>
&lt;p>如果从缓存中得到了bean的原始状态,则需要对bean进行实例化.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>原型模式的依赖检查&lt;/p>
&lt;/li>
&lt;li>
&lt;p>检测parentBeanFactory&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将存储XML配置文件的GernericBeanDefinition转换为RootBeanDefinition&lt;/p>
&lt;/li>
&lt;li>
&lt;p>寻找依赖&lt;/p>
&lt;p>因为bean的初始化过程中很可能会用到某些属性,而某些属性很可能是动态配置的,并且配置成依赖于其他的bean,那么这个时候就有必要先加载依赖的bean.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>针对不同的scope进行bean的创建&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>类型转换&lt;/p>
&lt;p>有可能有这种情况,返回的bean,是个String,但是requiredType传入的是Integer类型,那么这时候本步骤就会起作用了. Spring中提供了各种各样的转换器,用户也可以自己扩展转换器来满足需求&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>Spring源码笔记-1.6 自定义标签的解析</title><link>https://heeexy.com/posts/spring-note-8-custom-element/</link><pubDate>Tue, 19 Sep 2017 19:33:23 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-8-custom-element/</guid><description>&lt;h2 id="自定义标签的使用">
&lt;a href="#%e8%87%aa%e5%ae%9a%e4%b9%89%e6%a0%87%e7%ad%be%e7%9a%84%e4%bd%bf%e7%94%a8" class="header-anchor">#&lt;/a>
自定义标签的使用
&lt;/h2>&lt;p>主要内容都在书上,p80&lt;/p>
&lt;p>关键的部分为&lt;/p>
&lt;ul>
&lt;li>创建XSD文件&lt;/li>
&lt;li>创建类 继承AbstractSingleBeanDefinitionParser , 其继承关系最主要是实现了&lt;code>BeanDefinitionParser&lt;/code> 接口,顾名思义,可以用来解析bean.&lt;/li>
&lt;li>创建Handler文件, 继承自 NamespaceHandlerSupport ,目的是将上面的组件注册到Spring容器内&lt;/li>
&lt;li>编写Spring.handlers 和 Spring.schemas文件.&lt;/li>
&lt;/ul>
&lt;p>这样,自定义的配置就结束了.&lt;/p>
&lt;p>Spring加载自定义bean的流程主要就是遇到自定义标签后就去Spring.handlers和Spring.schemas中取找对应的handler 和 XSD .从而可以拿到parser&lt;/p>
&lt;p>而代码里的主要步骤为&lt;/p>
&lt;ol>
&lt;li>拿到标签对应的命名空间&lt;/li>
&lt;li>根据命名空间找到对应的handler&lt;/li>
&lt;li>调用handler的parse方法&lt;/li>
&lt;/ol>
&lt;h2 id="获取标签的命名空间">
&lt;a href="#%e8%8e%b7%e5%8f%96%e6%a0%87%e7%ad%be%e7%9a%84%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4" class="header-anchor">#&lt;/a>
获取标签的命名空间
&lt;/h2>&lt;p>调用org.w3c.dom.Node中的getNamespaceURI()&lt;/p>
&lt;h2 id="提取自定义标签处理器">
&lt;a href="#%e6%8f%90%e5%8f%96%e8%87%aa%e5%ae%9a%e4%b9%89%e6%a0%87%e7%ad%be%e5%a4%84%e7%90%86%e5%99%a8" class="header-anchor">#&lt;/a>
提取自定义标签处理器
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>NamespaceHandler handler &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">readerContext&lt;/span>.&lt;span style="color:#a6e22e">getNamespaceHandlerResolver&lt;/span>().&lt;span style="color:#a6e22e">resolve&lt;/span>(namespaceUri);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个resolve方法是接口,由DefaultNamespaceHandlerResolver 默认命名空间解析器来实现,其实现里面的第一步便是&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Object&lt;span style="color:#f92672">&amp;gt;&lt;/span> handlerMappings &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getHandlerMappings&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>原来&lt;code>handlerMappings&lt;/code> 是个map,想必是在注册时肯定把解析器添加到这个map里面来,用namespaceUri做key,这样找的时候就很好找了.&lt;/p>
&lt;p>取出结果如果是NamespaceHandler 便可以返回,往下读我们发现,之所以这么爽取出来就是handler,是因为已经做过这个解析,把找出的handler塞入了map,相当于是缓存了.&lt;/p>
&lt;p>否则就是类名 className, 我们需要把它转为handler&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//使用反射,将类路径转化为类&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Class&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> handlerClass &lt;span style="color:#f92672">=&lt;/span> ClassUtils.&lt;span style="color:#a6e22e">forName&lt;/span>(className, &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">classLoader&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>NamespaceHandler.&lt;span style="color:#a6e22e">class&lt;/span>.&lt;span style="color:#a6e22e">isAssignableFrom&lt;/span>(handlerClass)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> FatalBeanException(&lt;span style="color:#e6db74">&amp;#34;Class [&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> className &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;] for namespace [&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> namespaceUri &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;] does not implement the [&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> NamespaceHandler.&lt;span style="color:#a6e22e">class&lt;/span>.&lt;span style="color:#a6e22e">getName&lt;/span>() &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;] interface&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//初始化类&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NamespaceHandler namespaceHandler &lt;span style="color:#f92672">=&lt;/span> (NamespaceHandler)BeanUtils.&lt;span style="color:#a6e22e">instantiateClass&lt;/span>(handlerClass);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//调用类自定义的init()方法,这是所有handler都必须实现的方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namespaceHandler.&lt;span style="color:#a6e22e">init&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//塞入缓存&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> handlerMappings.&lt;span style="color:#a6e22e">put&lt;/span>(namespaceUri, namespaceHandler);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> namespaceHandler;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="设计模式--单例模式">
&lt;a href="#%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f--%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f" class="header-anchor">#&lt;/a>
设计模式&amp;ndash;单例模式
&lt;/h3>&lt;p>this.getHandlerMappings(); 获取handlerMapping处使用了单例模式&lt;/p>
&lt;p>声明为volatile&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">volatile&lt;/span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Object&lt;span style="color:#f92672">&amp;gt;&lt;/span> handlerMappings;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>获取单例时使用双重检查锁定&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Object&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">getHandlerMappings&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">handlerMappings&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">synchronized&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">handlerMappings&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//读取&amp;#34;META-INF/spring.handlers&amp;#34; 转为map&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Properties mappings &lt;span style="color:#f92672">=&lt;/span> PropertiesLoaderUtils.&lt;span style="color:#a6e22e">loadAllProperties&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">handlerMappingsLocation&lt;/span>, &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">classLoader&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">logger&lt;/span>.&lt;span style="color:#a6e22e">isDebugEnabled&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">logger&lt;/span>.&lt;span style="color:#a6e22e">debug&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Loaded NamespaceHandler mappings: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> mappings);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Object&lt;span style="color:#f92672">&amp;gt;&lt;/span> handlerMappings &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ConcurrentHashMap(mappings.&lt;span style="color:#a6e22e">size&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CollectionUtils.&lt;span style="color:#a6e22e">mergePropertiesIntoMap&lt;/span>(mappings, handlerMappings);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">handlerMappings&lt;/span> &lt;span style="color:#f92672">=&lt;/span> handlerMappings;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (IOException var5) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> IllegalStateException(&lt;span style="color:#e6db74">&amp;#34;Unable to load NamespaceHandler mappings from location [&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">handlerMappingsLocation&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;]&amp;#34;&lt;/span>, var5);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">handlerMappings&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的volatile非常关键,如果没有的话,在&lt;strong>初始化对象&lt;/strong> 和 &lt;strong>设置handlerMapping指向内存空间&lt;/strong> 中间可能发生&lt;strong>重排序&lt;/strong>,导致另外的线程拿到了handlerMapping的空间地址,但是其实还没有初始化完成.&lt;/p>
&lt;h2 id="标签解析">
&lt;a href="#%e6%a0%87%e7%ad%be%e8%a7%a3%e6%9e%90" class="header-anchor">#&lt;/a>
标签解析
&lt;/h2>&lt;p>拿到解析器之后,就调用解析的parse方法,返回BeanDefinition&lt;/p>
&lt;p>我们的自定义handler里面无需实现parse方法,在父类&lt;code>NamespaceHandlerSupport&lt;/code> 中自有实现,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> BeanDefinition &lt;span style="color:#a6e22e">parse&lt;/span>(Element element, ParserContext parserContext) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">findParserForElement&lt;/span>(element, parserContext).&lt;span style="color:#a6e22e">parse&lt;/span>(element, parserContext);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="http://ots7yt7am.bkt.clouddn.com/blog/findParserForElement.png"
loading="lazy"
>&lt;/p>
&lt;p>而parse方法主要步骤就是调用自己实现类的&lt;code>parseInternal&lt;/code> 方法,&lt;code>parseInternal&lt;/code> 方法除了调用我们实现的doParse方法之外,首先会进行一系列的数据准备,包括对beanClass.scope.lazyInit等属性的准备&lt;/p></description></item><item><title>Spring源码笔记-1.5 其它标签解析</title><link>https://heeexy.com/posts/spring-note-7-other-default-elements/</link><pubDate>Tue, 19 Sep 2017 19:33:04 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-7-other-default-elements/</guid><description>&lt;h2 id="本文要看啥">
&lt;a href="#%e6%9c%ac%e6%96%87%e8%a6%81%e7%9c%8b%e5%95%a5" class="header-anchor">#&lt;/a>
本文要看啥
&lt;/h2>&lt;p>之前我们看解析默认标签,从最核心的bean开始看的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">parseDefaultElement&lt;/span>(Element ele, BeanDefinitionParserDelegate delegate) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (delegate.&lt;span style="color:#a6e22e">nodeNameEquals&lt;/span>(ele, &lt;span style="color:#e6db74">&amp;#34;import&amp;#34;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">importBeanDefinitionResource&lt;/span>(ele);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (delegate.&lt;span style="color:#a6e22e">nodeNameEquals&lt;/span>(ele, &lt;span style="color:#e6db74">&amp;#34;alias&amp;#34;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">processAliasRegistration&lt;/span>(ele);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (delegate.&lt;span style="color:#a6e22e">nodeNameEquals&lt;/span>(ele, &lt;span style="color:#e6db74">&amp;#34;bean&amp;#34;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">processBeanDefinition&lt;/span>(ele, delegate);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (delegate.&lt;span style="color:#a6e22e">nodeNameEquals&lt;/span>(ele, &lt;span style="color:#e6db74">&amp;#34;beans&amp;#34;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">doRegisterBeanDefinitions&lt;/span>(ele);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在主要就剩下alias和import啦, beans其实就是迭代解析.&lt;/p>
&lt;h2 id="alias标签的解析">
&lt;a href="#alias%e6%a0%87%e7%ad%be%e7%9a%84%e8%a7%a3%e6%9e%90" class="header-anchor">#&lt;/a>
alias标签的解析
&lt;/h2>&lt;p>为bean定义别名,除了之前我们接触过的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;bean&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;testBean&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;aliasTestBean&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">class=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;com.test&amp;#34;&lt;/span>&lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>还可以直接用alias标签&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;alias&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;testBean&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">alias=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;aliasTestBean&amp;#34;&lt;/span>&lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>解析步骤即使不看源码也知道很简单,因为之前我们已经深入研究过了&lt;a class="link" href="http://heeexy.com/2017/09/15/spring_SimpleAliasRegistry/" target="_blank" rel="noopener"
>SimpleAliasRegistry&lt;/a>&lt;/p>
&lt;ol>
&lt;li>校验 name alias 两个属性不能为空&lt;/li>
&lt;li>&lt;code>this.getReaderContext().getRegistry().registerAlias(name, alias);&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>这个getRegistry() 然后registerAlias() 果然就是我们之前学过的&lt;code>SimpleAliasRegistry&lt;/code> 里面的注册别名的方法.&lt;/p>
&lt;h2 id="impory标签的解析">
&lt;a href="#impory%e6%a0%87%e7%ad%be%e7%9a%84%e8%a7%a3%e6%9e%90" class="header-anchor">#&lt;/a>
impory标签的解析
&lt;/h2>&lt;p>import标签和bean标签一样是我们最常见的标签,对于分模块管理配置文件很关键.&lt;/p>
&lt;h4 id="解析步骤">
&lt;a href="#%e8%a7%a3%e6%9e%90%e6%ad%a5%e9%aa%a4" class="header-anchor">#&lt;/a>
解析步骤
&lt;/h4>&lt;ol>
&lt;li>
&lt;p>取出并校验&lt;code>resource&lt;/code> 属性作为地址location&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将地址中的系统属性 如 &amp;ldquo;${user.dir}&amp;rdquo;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>判断location是绝对路径还是相对路径&lt;/p>
&lt;ol>
&lt;li>
&lt;p>如果是,则&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>importCount &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getReaderContext&lt;/span>().&lt;span style="color:#a6e22e">getReader&lt;/span>().&lt;span style="color:#a6e22e">loadBeanDefinitions&lt;/span>(location, actualResources);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>否则&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Resource relativeResource &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getReaderContext&lt;/span>().&lt;span style="color:#a6e22e">getResource&lt;/span>().&lt;span style="color:#a6e22e">createRelative&lt;/span>(location);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (relativeResource.&lt;span style="color:#a6e22e">exists&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> importCount &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getReaderContext&lt;/span>().&lt;span style="color:#a6e22e">getReader&lt;/span>().&lt;span style="color:#a6e22e">loadBeanDefinitions&lt;/span>(relativeResource);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> actualResources.&lt;span style="color:#a6e22e">add&lt;/span>(relativeResource);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String baseLocation &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getReaderContext&lt;/span>().&lt;span style="color:#a6e22e">getResource&lt;/span>().&lt;span style="color:#a6e22e">getURL&lt;/span>().&lt;span style="color:#a6e22e">toString&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> importCount &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getReaderContext&lt;/span>().&lt;span style="color:#a6e22e">getReader&lt;/span>().&lt;span style="color:#a6e22e">loadBeanDefinitions&lt;/span>(StringUtils.&lt;span style="color:#a6e22e">applyRelativePath&lt;/span>(baseLocation, location), actualResources);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>还是预留给拓展监听事件的位置.&lt;/li>
&lt;/ol>
&lt;h4 id="关键步骤">
&lt;a href="#%e5%85%b3%e9%94%ae%e6%ad%a5%e9%aa%a4" class="header-anchor">#&lt;/a>
关键步骤
&lt;/h4>&lt;h5 id="判断是否绝对路径">
&lt;a href="#%e5%88%a4%e6%96%ad%e6%98%af%e5%90%a6%e7%bb%9d%e5%af%b9%e8%b7%af%e5%be%84" class="header-anchor">#&lt;/a>
判断是否绝对路径
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>absoluteLocation &lt;span style="color:#f92672">=&lt;/span> ResourcePatternUtils.&lt;span style="color:#a6e22e">isUrl&lt;/span>(location) &lt;span style="color:#f92672">||&lt;/span> ResourceUtils.&lt;span style="color:#a6e22e">toURI&lt;/span>(location).&lt;span style="color:#a6e22e">isAbsolute&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>isUrl : 以 classpath*: 开头 或者 classpath: 开头 或者 可以new URL(resourceLocation); 而不报错&lt;/p>
&lt;p>ResourceUtils.toURI(location): 替换路径中空格为%20 后 new URI ,然后拿absolute属性&lt;/p>
&lt;h5 id="加载bean">
&lt;a href="#%e5%8a%a0%e8%bd%bdbean" class="header-anchor">#&lt;/a>
加载bean
&lt;/h5>&lt;p>其实最后都是调用在第一篇博文中我们就看过的 &lt;code>loadBeanDefinitions&lt;/code> 方法&lt;/p></description></item><item><title>test_volatile_object</title><link>https://heeexy.com/posts/test-volatile-object/</link><pubDate>Mon, 18 Sep 2017 22:28:29 +0000</pubDate><guid>https://heeexy.com/posts/test-volatile-object/</guid><description>&lt;h3 id="本文要看啥">
&lt;a href="#%e6%9c%ac%e6%96%87%e8%a6%81%e7%9c%8b%e5%95%a5" class="header-anchor">#&lt;/a>
本文要看啥
&lt;/h3>&lt;hr>
&lt;p>先不细谈volatile的基本原理,在读(写)这篇文章时,都是假设我们已经粗略了解了一点volatile的原理和作用的,主要就是 &amp;ldquo;&lt;!-- raw HTML omitted -->读写都走主内存,保证任意线程对这个变量的可见性&lt;!-- raw HTML omitted -->&amp;rdquo;&lt;/p>
&lt;p>在查看spring源码的时候,注意到spring在处理并发的操作List&lt;!-- raw HTML omitted -->时, 虽然对list使用了volatile, 然而向list里面添加元素时,用的还是新建一个list,复制全部旧值,增加新元素,然后将旧的list地址指向新的list.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> updatedDefinitions &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">beanDefinitionNames&lt;/span>.&lt;span style="color:#a6e22e">size&lt;/span>() &lt;span style="color:#f92672">+&lt;/span> 1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> updatedDefinitions.&lt;span style="color:#a6e22e">addAll&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">beanDefinitionNames&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> updatedDefinitions.&lt;span style="color:#a6e22e">add&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">beanDefinitionNames&lt;/span> &lt;span style="color:#f92672">=&lt;/span> updatedDefinitions;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这么麻烦的操作,第一反应就是,volatile修饰的list, 直接添加元素&lt;strong>依然不安全&lt;/strong>么?&lt;/p>
&lt;p>去网上搜了一下相关问题, &lt;a class="link" href="http://blog.csdn.net/u014108122/article/details/38173201" target="_blank" rel="noopener"
>参考博文地址&lt;/a> ,发现不止list, 对象也是一样的.&lt;/p>
&lt;p>本文就是要来用代码直观地看看volatile 到底有什么效果,怎么用才有效果.&lt;/p>
&lt;h3 id="开始代码吧">
&lt;a href="#%e5%bc%80%e5%a7%8b%e4%bb%a3%e7%a0%81%e5%90%a7" class="header-anchor">#&lt;/a>
开始代码吧
&lt;/h3>&lt;hr>
&lt;h4 id="线程共享对象里的boolean">
&lt;a href="#%e7%ba%bf%e7%a8%8b%e5%85%b1%e4%ba%ab%e5%af%b9%e8%b1%a1%e9%87%8c%e7%9a%84boolean" class="header-anchor">#&lt;/a>
线程共享对象里的boolean
&lt;/h4>&lt;p>注意代码要以**-server模式**运行，强制虚拟机开启优化&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">VolatileObjectTest&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> Runnable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 加上volatile 就可以正常结束While循环了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> ObjectA a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">VolatileObjectTest&lt;/span>(ObjectA a) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">=&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">stop&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a.&lt;span style="color:#a6e22e">setFlag&lt;/span>(&lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (a.&lt;span style="color:#a6e22e">isFlag&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 注意这里的sysout,如果有调用的话,即使没有volatile,子线程也经常能拿到a.flag,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 结合后面的测试,发现sysout 或者 sysout(a.isFlag())之前有&amp;#34;---&amp;#34;之类字符串
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 都可能让a去从主内存去获取值,影响我们测试的结果
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 所以测试的时候不要乱打sysout了,感兴趣的话可以自己去各种测试一遍
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// System.out.println(); &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;子线程正常结束&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) &lt;span style="color:#66d9ef">throws&lt;/span> InterruptedException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 注意代码要以-server模式运行，强制虚拟机开启优化&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 如果启动的时候加上-server 参数则会 输出 Java HotSpot(TM) Server VM&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(System.&lt;span style="color:#a6e22e">getProperty&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;java.vm.name&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> VolatileObjectTest2 test &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> VolatileObjectTest2(&lt;span style="color:#66d9ef">new&lt;/span> ObjectA());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">new&lt;/span> Thread(test).&lt;span style="color:#a6e22e">start&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread.&lt;span style="color:#a6e22e">sleep&lt;/span>(200);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> test.&lt;span style="color:#a6e22e">stop&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread.&lt;span style="color:#a6e22e">sleep&lt;/span>(200);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;主线程结束&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ObjectA&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> flag &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isFlag&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> flag;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setFlag&lt;/span>(&lt;span style="color:#66d9ef">boolean&lt;/span> flag) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">flag&lt;/span> &lt;span style="color:#f92672">=&lt;/span> flag;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个代码还是很简单,&lt;/p>
&lt;p>主线程将a的flag改为false,&lt;/p>
&lt;p>子线程能正常结束的话, 说明子线程里 a 的 flag值获取到了false,&lt;/p>
&lt;p>不能正常结束的话, 说明子线程a一直都是用其本地内存里的flag值,一直都是true.&lt;/p>
&lt;p>测试结果就是&lt;/p>
&lt;ol>
&lt;li>有volatile 修饰的情况下, 子线程能拿到false值&lt;/li>
&lt;li>没有volatile ,子线程无法正常结束&lt;/li>
&lt;/ol>
&lt;p>在初步了解volatile 的可见性的情况下, 我会觉得这个结果很正常, 觉得自己掌握了volatile , 但是我们继续往下看&amp;hellip;&lt;/p>
&lt;h4 id="线程共享对象里的对象">
&lt;a href="#%e7%ba%bf%e7%a8%8b%e5%85%b1%e4%ba%ab%e5%af%b9%e8%b1%a1%e9%87%8c%e7%9a%84%e5%af%b9%e8%b1%a1" class="header-anchor">#&lt;/a>
线程共享对象里的对象
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">VolatileObjectTest&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> Runnable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 加上volatile 就可以正常结束While循环了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">volatile&lt;/span> ObjectA a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">VolatileObjectTest&lt;/span>(ObjectA a) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">=&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">stop&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a.&lt;span style="color:#a6e22e">getObjectB&lt;/span>().&lt;span style="color:#a6e22e">setFlag&lt;/span>(&lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ObjectB b &lt;span style="color:#f92672">=&lt;/span> a.&lt;span style="color:#a6e22e">getObjectB&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (b.&lt;span style="color:#a6e22e">isFlag&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(b.&lt;span style="color:#a6e22e">isFlag&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(a.&lt;span style="color:#a6e22e">getObjectB&lt;/span>().&lt;span style="color:#a6e22e">isFlag&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;子线程正常结束&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) &lt;span style="color:#66d9ef">throws&lt;/span> InterruptedException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 如果启动的时候加上-server 参数则会 输出 Java HotSpot(TM) Server VM&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(System.&lt;span style="color:#a6e22e">getProperty&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;java.vm.name&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> VolatileObjectTest test &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> VolatileObjectTest(&lt;span style="color:#66d9ef">new&lt;/span> ObjectA());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">new&lt;/span> Thread(test).&lt;span style="color:#a6e22e">start&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread.&lt;span style="color:#a6e22e">sleep&lt;/span>(200);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> test.&lt;span style="color:#a6e22e">stop&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread.&lt;span style="color:#a6e22e">sleep&lt;/span>(200);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;主线程结束&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ObjectA&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> flag &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> ObjectB objectB &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ObjectB();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isFlag&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> flag;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setFlag&lt;/span>(&lt;span style="color:#66d9ef">boolean&lt;/span> flag) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">flag&lt;/span> &lt;span style="color:#f92672">=&lt;/span> flag;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> ObjectB &lt;span style="color:#a6e22e">getObjectB&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> objectB;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ObjectB&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> flag &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isFlag&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> flag;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setFlag&lt;/span>(&lt;span style="color:#66d9ef">boolean&lt;/span> flag) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">flag&lt;/span> &lt;span style="color:#f92672">=&lt;/span> flag;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这次在ObjectA内添加了一个成员变量ObjectB,我们在子线程中跳出循环需要ObjectB中的flag变为false;&lt;/p>
&lt;p>实际测试时发现:&lt;/p>
&lt;ol>
&lt;li>无论ObjectA前有没有 volatile, 调用stop()方法都并不能正确终止子线程&lt;/li>
&lt;li>成员变量ObjectB前添加volatile,同样不能正确终止子线程&lt;/li>
&lt;li>ObjectB的flag前加volatile,可以终止子线程 (这是当然的啦&amp;hellip;)&lt;/li>
&lt;li>如果循环里用的是 &lt;code>while (a.getObjectB().isFlag())&lt;/code> , ObjectA前又有volatile的话, 这样还是可以终止子线程.&lt;/li>
&lt;/ol>
&lt;p>测到这里,感觉这个博主给的例子是不是有问题啊,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> ObjectB b &lt;span style="color:#f92672">=&lt;/span> a.&lt;span style="color:#a6e22e">getObjectB&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (b.&lt;span style="color:#a6e22e">isFlag&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>问题是出在这里提前从a里面取出了b么,b已经指向不同的内存地址了么?不应该吧&amp;hellip;&lt;/p>
&lt;p>稍加思考,第三种结果里,b.flag用volatile修饰后,就可以正常退出,说明b还是指向的a里面的b的地址啊,没毛病啊.&lt;/p>
&lt;p>突然感觉更晕了,把原博的评论翻到底,发现还真有人评论到这个,从评论里又学到了很多东西.&lt;/p>
&lt;h4 id="原博评论区的解疑">
&lt;a href="#%e5%8e%9f%e5%8d%9a%e8%af%84%e8%ae%ba%e5%8c%ba%e7%9a%84%e8%a7%a3%e7%96%91" class="header-anchor">#&lt;/a>
原博评论区的解疑
&lt;/h4>&lt;p>Q: 为什么sysout影响结果?&lt;/p>
&lt;p>A: 如果在循环体内加一些语句,比如sysout或者new对象之类的稍微复杂而耗时的操作,就会发现就算没有volatile,线程同样可能被正常中断.因为&lt;strong>经过高耗时操作之后,CPU会&amp;quot;怀疑人生&amp;quot;&lt;/strong>,单心自己对b.flag的缓存不是最新的,而去从主存获取.在这种情况下，线程会结束，只不过不及时而已。&lt;/p>
&lt;p>Q: 为什么 while (b.isFlag()) 和while(a.getObjectB.isFlag()) 结果有区别,后者就可以拿到最新的flag值?&lt;/p>
&lt;p>A: 一个volatile引用的域或者元素并不具备volatile特性，因为对于该域的写入并不会触发StoreLoad屏障，就&lt;strong>不会强迫该域值立刻回写主存&lt;/strong>。不过其读特性并没有问题，&lt;strong>对volatile的读操作一定是去主存当中读取的&lt;/strong>。&lt;/p>
&lt;p>所以a.getObjectB 在这里a就已经去从主存中读取了.&lt;/p>
&lt;p>这一点因此也就解释了第一个例子中,我们修改a.flag,可以正常地读到flag值.&lt;/p>
&lt;p>Q: 但是问题又来了,写入不能保证刷新到主存的话,岂不是即使&lt;code>while(a.getObjectB.isFlag())&lt;/code> 也是仍然很有可能失败的?经过刚才例子的反复测试,依然很难碰到终止线程失败的情况.&lt;/p>
&lt;p>A: 这个例子还是无法测出这种刷新主存不及时的情况,毕竟即使是不及时刷新,最终刷新了还是可以让子线程结束的.&lt;/p>
&lt;p>&lt;a class="link" href="http://ifeve.com/volatile-array-visiblity/" target="_blank" rel="noopener"
>另外一篇博客&lt;/a> 从汇编语句的角度分析了&lt;strong>volatile的数组只针对数组的引用具有volatile的语义，而不是它的元素&lt;/strong> , 暂时只能记录下来,待以后再深入原理去理解.&lt;/p>
&lt;h4 id="留下更多的疑惑">
&lt;a href="#%e7%95%99%e4%b8%8b%e6%9b%b4%e5%a4%9a%e7%9a%84%e7%96%91%e6%83%91" class="header-anchor">#&lt;/a>
留下更多的疑惑
&lt;/h4>&lt;ol>
&lt;li>
&lt;p>如上面所说,一个volatile引用的域或者元素并不具备volatile特性，因为对于该域的写入并不会触发StoreLoad屏障，就&lt;strong>不会强迫该域值立刻回写主存&lt;/strong>。 如何证明?&lt;/p>
&lt;/li>
&lt;li>
&lt;p>spring里用置换的方式真的不会出问题么? 多个线程同时读取了一个list,然后各自加一个元素进去,刷新,这样不就出了问题?&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果说这样并不安全,那么concurrent包里是怎么实现安全的list的呢?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">add&lt;/span>(E e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> ReentrantLock lock &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">lock&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lock.&lt;span style="color:#a6e22e">lock&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object&lt;span style="color:#f92672">[]&lt;/span> elements &lt;span style="color:#f92672">=&lt;/span> getArray();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> len &lt;span style="color:#f92672">=&lt;/span> elements.&lt;span style="color:#a6e22e">length&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object&lt;span style="color:#f92672">[]&lt;/span> newElements &lt;span style="color:#f92672">=&lt;/span> Arrays.&lt;span style="color:#a6e22e">copyOf&lt;/span>(elements, len &lt;span style="color:#f92672">+&lt;/span> 1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> newElements&lt;span style="color:#f92672">[&lt;/span>len&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> e;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> setArray(newElements);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lock.&lt;span style="color:#a6e22e">unlock&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ReentrantLock 貌似是安全了, 但是为什么这里也用了置换数组啊???&lt;/p>
&lt;p>​&lt;/p>
&lt;/li>
&lt;/ol></description></item><item><title>SimpleAliasRegistry</title><link>https://heeexy.com/posts/spring-note-5-simplealiasregistry/</link><pubDate>Fri, 15 Sep 2017 21:27:09 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-5-simplealiasregistry/</guid><description>&lt;p>功能:注册/存放别名&lt;/p>
&lt;p>唯一成员变量为&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> aliasMap &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ConcurrentHashMap(16);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这Map&amp;lt;String,String&amp;gt; 其实key是alias,value是name. 刚开始没注意可能搞反了呢&lt;/p>
&lt;h2 id="注册别名registeralias">
&lt;a href="#%e6%b3%a8%e5%86%8c%e5%88%ab%e5%90%8dregisteralias" class="header-anchor">#&lt;/a>
注册别名&lt;code>registerAlias()&lt;/code>
&lt;/h2>&lt;hr>
&lt;p>举例来说 我们要注册的beanName为&lt;strong>myTestBean&lt;/strong> , 别名为&lt;strong>mtb&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>校验name和alias都不为空&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果name和alias一样,那map里删了这条name,结束&lt;/p>
&lt;/li>
&lt;li>
&lt;p>依据alias 即 &lt;strong>mtb&lt;/strong>去map里面取已注册的name,如果真的有已注册过的话:&lt;/p>
&lt;ol>
&lt;li>&lt;code>registeredName&lt;/code> 和&lt;code>name&lt;/code>相等的话,那就不用管,结束.&lt;/li>
&lt;li>如果他俩不相等,这个工厂又不允许重写alias,那就抛异常! (&lt;code>allowAliasOverriding()&lt;/code> 这个方法在SimpleAliasRegistry的子类里面有的会被重写.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>如果前面都通过了,&lt;code>this.checkForAliasCircle(name, alias);&lt;/code> 再次循环检查一遍,判断是否&lt;code>hasAlias()&lt;/code>,如果是true的话,就报错,不是的话,走第5步. 具体&lt;code>hasAlias()&lt;/code>流程如下:&lt;/p>
&lt;ol>
&lt;li>循环找出&lt;code>registeredName&lt;/code> 为&lt;strong>myTestBean&lt;/strong>的那组键值对 (这里和上面的遍历不一样哦,这里是根据直接找重复的beanName的,上面是找重复的alias的&lt;/li>
&lt;li>如果这个键值对的key即alias也是等于&lt;strong>mtb&lt;/strong>的话,报错 (但是实际我们这第三步也查过这种情况)&lt;/li>
&lt;li>如果这个myTestBean找出来的alias是&amp;quot;myTB&amp;quot;,那就还要走一遍&lt;code>hasAlias(&amp;quot;myTB&amp;quot;,&amp;quot;mtb&amp;quot;)&lt;/code> ,换句话说,就是要看一看是不是有哪个bean名字叫myTB,别名叫mtb的,如果真的有,就返回true&lt;/li>
&lt;/ol>
&lt;p>第四步的&lt;code>hasAlias()&lt;/code> 这种判断是啥意思呢?&lt;/p>
&lt;p>想注册 mtb&amp;ndash;myTestBean (别名&amp;ndash;本名)&lt;/p>
&lt;p>如果已存在 mtb&amp;ndash;myTestBean ,那么返回true&lt;/p>
&lt;p>如果已存在 myTB&amp;ndash;myTestBean,&lt;/p>
&lt;p>​ 且存在 mtb&amp;ndash;myTB ,&lt;/p>
&lt;p>那就构成了 &lt;strong>mtb&amp;ndash;myTB&amp;ndash;myTestBean&lt;/strong> 也返回true&lt;/p>
&lt;p>如果已存在 myTB&amp;ndash;myTestBean,&lt;/p>
&lt;p>​ 且存在 mta&amp;ndash;myTB&lt;/p>
&lt;p>​ 且存在 mtb&amp;ndash;mta ,&lt;/p>
&lt;p>那就构成了 &lt;strong>mtb&amp;ndash;mta&amp;ndash;myTB&amp;ndash;myTestBean&lt;/strong> 还是返回true&lt;/p>
&lt;p>.&lt;/p>
&lt;p>这下看明白了吧,&lt;/p>
&lt;p>说明hasAlias()方法不止判断mtb是否已经做了myTestBean的别名,&lt;/p>
&lt;p>还判断了mtb是不是myTestBean的别名 的别名 的别名 的别名 的别名&amp;hellip;.最终能通过一条线导向myTestBean&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果前面各种校验全部通过 ,&lt;code>this.aliasMap.put(alias, name);&lt;/code> 很简单,map里面塞值吧!&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>前面校验看着很啰嗦,其实总结起来都很简单&lt;/p>
&lt;ol>
&lt;li>键值都不能为空&lt;/li>
&lt;li>别键值相等,我会删了这个别名的(虽然你应该本来就添加不进来)&lt;/li>
&lt;li>别名已用过,如果还是原name,那不用操作&lt;/li>
&lt;li>别名已用过,这次换了新name,那就看你注册器允不允许我搞覆盖咯&lt;/li>
&lt;li>别告诉我这个alias居然还是那个name的别名的别名&amp;hellip;&lt;/li>
&lt;/ol>
&lt;p>第5种的情况让我突然想到,这种连环关系应该连申请都申请不了吧,即使真的想搞出连环关系,也应该是下面这种情况吧??&lt;/p>
&lt;p>&lt;strong>myTB&amp;ndash;myTestBean已注册好了,新来个bean想注册beanName叫myTB&lt;/strong>&lt;/p>
&lt;p>应该在申请注册beanName叫myTB的时候就&lt;strong>校验过了吧&lt;/strong>!!!&lt;/p>
&lt;p>好,翻回去找找注册beanName的时候,是不是已经校验过不能和已注册的alias重名!&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> BeanDefinitionHolder &lt;span style="color:#a6e22e">parseBeanDefinitionElement&lt;/span>(Element ele, BeanDefinition containingBean) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String id &lt;span style="color:#f92672">=&lt;/span> ele.&lt;span style="color:#a6e22e">getAttribute&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;id&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String nameAttr &lt;span style="color:#f92672">=&lt;/span> ele.&lt;span style="color:#a6e22e">getAttribute&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//都忘掉了bean原本没有alias属性了......&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//aliases数组是原本的name里面的多个值&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//除非之前没id,有name, 那么从aliases里remove(0)出去做beanName,剩下的继续做alias&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> aliases &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (StringUtils.&lt;span style="color:#a6e22e">hasLength&lt;/span>(nameAttr)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String&lt;span style="color:#f92672">[]&lt;/span> nameArr &lt;span style="color:#f92672">=&lt;/span> StringUtils.&lt;span style="color:#a6e22e">tokenizeToStringArray&lt;/span>(nameAttr, &lt;span style="color:#e6db74">&amp;#34;,; &amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> aliases.&lt;span style="color:#a6e22e">addAll&lt;/span>(Arrays.&lt;span style="color:#a6e22e">asList&lt;/span>(nameArr));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String beanName &lt;span style="color:#f92672">=&lt;/span> id;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>StringUtils.&lt;span style="color:#a6e22e">hasText&lt;/span>(id) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>aliases.&lt;span style="color:#a6e22e">isEmpty&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> beanName &lt;span style="color:#f92672">=&lt;/span> (String)aliases.&lt;span style="color:#a6e22e">remove&lt;/span>(0);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">logger&lt;/span>.&lt;span style="color:#a6e22e">isDebugEnabled&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">logger&lt;/span>.&lt;span style="color:#a6e22e">debug&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;No XML &amp;#39;id&amp;#39; specified - using &amp;#39;&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> beanName &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#39; as bean name and &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> aliases &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; as aliases&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (containingBean &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//在这里校验一波beanName和alias的唯一性&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">checkNameUniqueness&lt;/span>(beanName, aliases, ele);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ....
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//校验重名的方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">protected&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">checkNameUniqueness&lt;/span>(String beanName, List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> aliases, Element beanElement) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String foundName &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//看已用名里是否包括了beanName&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (StringUtils.&lt;span style="color:#a6e22e">hasText&lt;/span>(beanName) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">usedNames&lt;/span>.&lt;span style="color:#a6e22e">contains&lt;/span>(beanName)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> foundName &lt;span style="color:#f92672">=&lt;/span> beanName;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//看已用名里是否用过了这些alias&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (foundName &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> foundName &lt;span style="color:#f92672">=&lt;/span> (String)CollectionUtils.&lt;span style="color:#a6e22e">findFirstMatch&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">usedNames&lt;/span>, aliases);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (foundName &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">error&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Bean name &amp;#39;&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> foundName &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#39; is already used in this &amp;lt;beans&amp;gt; element&amp;#34;&lt;/span>, beanElement);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//注意这个地方, beanName和aliases都是全部加入usedNames的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//那就说明,在前面校验的时候,已用名就是包括已用beanName和已用alias的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//所以如果myTB--myTestBean已注册好了,myTB和myTestBean都被usedName收录了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//再想拿myTB做beanName肯定不行了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">usedNames&lt;/span>.&lt;span style="color:#a6e22e">add&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">usedNames&lt;/span>.&lt;span style="color:#a6e22e">addAll&lt;/span>(aliases);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以其实是校验过的啊,感觉上面考虑的第5种情况有点多此一举呢&amp;hellip;&lt;/p>
&lt;p>还是来看看类里面的其它方法吧&lt;/p>
&lt;h2 id="取消注册别名removealias">
&lt;a href="#%e5%8f%96%e6%b6%88%e6%b3%a8%e5%86%8c%e5%88%ab%e5%90%8dremovealias" class="header-anchor">#&lt;/a>
取消注册别名&lt;code>removeAlias()&lt;/code>
&lt;/h2>&lt;hr>
&lt;p>很简单,map直接remove这个别名,如果remove结果是null,那抛个异常&lt;/p>
&lt;h2 id="判断是否为别名-isalias">
&lt;a href="#%e5%88%a4%e6%96%ad%e6%98%af%e5%90%a6%e4%b8%ba%e5%88%ab%e5%90%8d-isalias" class="header-anchor">#&lt;/a>
判断是否为别名 &lt;code>isAlias()&lt;/code>
&lt;/h2>&lt;hr>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">aliasMap&lt;/span>.&lt;span style="color:#a6e22e">containsKey&lt;/span>(name);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="获取某个name的所有别名-getaliasesstring-name">
&lt;a href="#%e8%8e%b7%e5%8f%96%e6%9f%90%e4%b8%aaname%e7%9a%84%e6%89%80%e6%9c%89%e5%88%ab%e5%90%8d-getaliasesstring-name" class="header-anchor">#&lt;/a>
获取某个name的所有别名 &lt;code>getAliases(String name)&lt;/code>
&lt;/h2>&lt;hr>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//加了个同步,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">synchronized&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">aliasMap&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">retrieveAliases&lt;/span>(name, result);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">retrieveAliases&lt;/span>(String name, List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> result) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Iterator var3 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">aliasMap&lt;/span>.&lt;span style="color:#a6e22e">entrySet&lt;/span>().&lt;span style="color:#a6e22e">iterator&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//遍历map,找出value等于这个name的key&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(var3.&lt;span style="color:#a6e22e">hasNext&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Entry&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> entry &lt;span style="color:#f92672">=&lt;/span> (Entry)var3.&lt;span style="color:#a6e22e">next&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String registeredName &lt;span style="color:#f92672">=&lt;/span> (String)entry.&lt;span style="color:#a6e22e">getValue&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (registeredName.&lt;span style="color:#a6e22e">equals&lt;/span>(name)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String alias &lt;span style="color:#f92672">=&lt;/span> (String)entry.&lt;span style="color:#a6e22e">getKey&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.&lt;span style="color:#a6e22e">add&lt;/span>(alias);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//注意这里,厉害了,居然还真的递归地去找它的别名的别名(的别名的别名...)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//到底什么地方能制造出链式的别名啊啊啊啊????&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">retrieveAliases&lt;/span>(alias, result);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>另外注意到,getAliases()方法在AbstractBeanFactory其实是有重写的啊,稍后去看看!&lt;/p>
&lt;h2 id="找本名canonicalname">
&lt;a href="#%e6%89%be%e6%9c%ac%e5%90%8dcanonicalname" class="header-anchor">#&lt;/a>
找本名&lt;code>canonicalName()&lt;/code>
&lt;/h2>&lt;hr>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">canonicalName&lt;/span>(String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String canonicalName &lt;span style="color:#f92672">=&lt;/span> name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String resolvedName;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">do&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resolvedName &lt;span style="color:#f92672">=&lt;/span> (String)&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">aliasMap&lt;/span>.&lt;span style="color:#a6e22e">get&lt;/span>(canonicalName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (resolvedName &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> canonicalName &lt;span style="color:#f92672">=&lt;/span> resolvedName;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">while&lt;/span>(resolvedName &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> canonicalName;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>方法很简单,就是一层一层地去找这个名字的本名.&lt;/p>
&lt;h2 id="abstractbeanfactory-对getaliases-的重写">
&lt;a href="#abstractbeanfactory-%e5%af%b9getaliases-%e7%9a%84%e9%87%8d%e5%86%99" class="header-anchor">#&lt;/a>
&lt;code>AbstractBeanFactory&lt;/code> 对&lt;code>getAliases()&lt;/code> 的重写
&lt;/h2>&lt;hr>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> String&lt;span style="color:#f92672">[]&lt;/span> &lt;span style="color:#a6e22e">getAliases&lt;/span>(String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//找到这个name的真正的beanName, &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//transformedBeanName里面的操作主要是去除头部所有&amp;amp;符号,以及调用上面的canonicalName()来找本名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String beanName &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">transformedBeanName&lt;/span>(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> aliases &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span> factoryPrefix &lt;span style="color:#f92672">=&lt;/span> name.&lt;span style="color:#a6e22e">startsWith&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&amp;amp;&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String fullBeanName &lt;span style="color:#f92672">=&lt;/span> beanName;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (factoryPrefix) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果原name以&amp;amp;开头(可能多个&amp;amp;),表示工厂前缀&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//bean全名就加上一个&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fullBeanName &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;amp;&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> beanName;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>fullBeanName.&lt;span style="color:#a6e22e">equals&lt;/span>(name)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果bean全名还不等于原名, 说明原名可能是 &amp;amp;&amp;amp;&amp;amp;myTestBean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//那么把&amp;amp;myTestBean也作为它的一个别名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> aliases.&lt;span style="color:#a6e22e">add&lt;/span>(fullBeanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//调用上面我们SimpleAliasRegistry的方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String&lt;span style="color:#f92672">[]&lt;/span> retrievedAliases &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">super&lt;/span>.&lt;span style="color:#a6e22e">getAliases&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String&lt;span style="color:#f92672">[]&lt;/span> var7 &lt;span style="color:#f92672">=&lt;/span> retrievedAliases;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> var8 &lt;span style="color:#f92672">=&lt;/span> retrievedAliases.&lt;span style="color:#a6e22e">length&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> var9 &lt;span style="color:#f92672">=&lt;/span> 0; var9 &lt;span style="color:#f92672">&amp;lt;&lt;/span> var8; &lt;span style="color:#f92672">++&lt;/span>var9) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String retrievedAlias &lt;span style="color:#f92672">=&lt;/span> var7&lt;span style="color:#f92672">[&lt;/span>var9&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果是工厂bean,配上工厂前缀&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String alias &lt;span style="color:#f92672">=&lt;/span> (factoryPrefix &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;amp;&amp;#34;&lt;/span> : &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> retrievedAlias;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>alias.&lt;span style="color:#a6e22e">equals&lt;/span>(name)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//只要不等于我们的name,通通可以做为别名 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> aliases.&lt;span style="color:#a6e22e">add&lt;/span>(alias);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//如果这个beanName对应的bean不是单例,并且这个beanName还没注册bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">containsSingleton&lt;/span>(beanName) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">containsBeanDefinition&lt;/span>(beanName)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BeanFactory parentBeanFactory &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getParentBeanFactory&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (parentBeanFactory &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//并且它还有父工厂,那就从它的父工厂里面找&amp;amp;myTestBean的别名 ,都算进来是它的别名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> aliases.&lt;span style="color:#a6e22e">addAll&lt;/span>(Arrays.&lt;span style="color:#a6e22e">asList&lt;/span>(parentBeanFactory.&lt;span style="color:#a6e22e">getAliases&lt;/span>(fullBeanName)));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> StringUtils.&lt;span style="color:#a6e22e">toStringArray&lt;/span>(aliases);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>虽然这个方法看得还不是很明白,但大概知道,这里的重写主要是牵扯到了这个bean的工厂相关属性,待后面了解了工厂应该就能清楚这里的别名与工厂的关系了.&lt;/p>
&lt;h2 id="解析别名resolvealiasesstringvalueresolver-valueresolver">
&lt;a href="#%e8%a7%a3%e6%9e%90%e5%88%ab%e5%90%8dresolvealiasesstringvalueresolver-valueresolver" class="header-anchor">#&lt;/a>
解析别名&lt;code>resolveAliases(StringValueResolver valueResolver)&lt;/code>
&lt;/h2>&lt;hr>
&lt;p>这里的入参需要传个值解析器,&lt;/p>
&lt;p>加锁,复制出map,遍历map,拿到alias,registeredName, 以及,用解析器解析后的resolvedAlias,resolvedName&lt;/p>
&lt;p>如果解析后的别名,本名有一者为空,或者二者相等,那么就要从map里移除这个alias,说明这个alias多余了,没作用.&lt;/p>
&lt;p>否则&lt;/p>
&lt;ol>
&lt;li>
&lt;p>如果解析后别名和解析前别名一致,那么把解析前别名 alias指向解析后的本名,resolvedName (这里就直接覆盖掉原alias的映射了&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果解析后别名和解析前不一致&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//先找找解析后别名是不是在map里有映射&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String existingName &lt;span style="color:#f92672">=&lt;/span> (String)&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">aliasMap&lt;/span>.&lt;span style="color:#a6e22e">get&lt;/span>(resolvedAlias);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (existingName &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果有的话,并且还指向了其它值,那就要抛异常了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>existingName.&lt;span style="color:#a6e22e">equals&lt;/span>(resolvedName)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> IllegalStateException(&lt;span style="color:#e6db74">&amp;#34;Cannot register resolved alias &amp;#39;&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> resolvedAlias &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#39; (original: &amp;#39;&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> alias &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#39;) for name &amp;#39;&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> resolvedName &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#39;: It is already registered for name &amp;#39;&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> registeredName &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#39;.&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//否则直接从map里移除原来的alias别名就够了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">aliasMap&lt;/span>.&lt;span style="color:#a6e22e">remove&lt;/span>(alias);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//注册解析后的别名--解析后的本名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">checkForAliasCircle&lt;/span>(resolvedName, resolvedAlias);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//注意到这里和普通注册唯一的区别就是这里还要移除原alias&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">aliasMap&lt;/span>.&lt;span style="color:#a6e22e">remove&lt;/span>(alias);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">aliasMap&lt;/span>.&lt;span style="color:#a6e22e">put&lt;/span>(resolvedAlias, resolvedName);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;p>所以总结一下这个处理解析Aliases的目的&lt;/p>
&lt;p>遍历map,每个键值对都解析一遍,&lt;/p>
&lt;p>如果这对能解析出新的一对合法别名&amp;ndash;本名键值对,那么就把之前的那对删掉,注册新的这个解析后的一对,&lt;/p>
&lt;p>此外检验下解析后的别名是不是被占用,如果占用了还指向错了值,就抛异常,&lt;/p>
&lt;p>如果占用了也是指向解析后名字,那就说明解析后的这对已经注册好了,只需删掉旧的那对&lt;/p></description></item><item><title>Spring源码笔记-1.4 获取bean流程之注册BeanDefinition</title><link>https://heeexy.com/posts/spring-note-6-registerbeandefinition/</link><pubDate>Fri, 15 Sep 2017 21:26:00 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-6-registerbeandefinition/</guid><description>&lt;h3 id="本文要看啥">
&lt;a href="#%e6%9c%ac%e6%96%87%e8%a6%81%e7%9c%8b%e5%95%a5" class="header-anchor">#&lt;/a>
本文要看啥
&lt;/h3>&lt;hr>
&lt;p>这个bean总算是解析完了,也装饰完了,等于是说信息我们都提取好了,现在该做的就是去注册啦.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> BeanDefinitionReaderUtils.&lt;span style="color:#a6e22e">registerBeanDefinition&lt;/span>(bdHolder, &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getReaderContext&lt;/span>().&lt;span style="color:#a6e22e">getRegistry&lt;/span>());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>就是这个方法了&lt;/p>
&lt;h3 id="开始进入方法吧">
&lt;a href="#%e5%bc%80%e5%a7%8b%e8%bf%9b%e5%85%a5%e6%96%b9%e6%b3%95%e5%90%a7" class="header-anchor">#&lt;/a>
开始进入方法吧
&lt;/h3>&lt;hr>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">registerBeanDefinition&lt;/span>(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) &lt;span style="color:#66d9ef">throws&lt;/span> BeanDefinitionStoreException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String beanName &lt;span style="color:#f92672">=&lt;/span> definitionHolder.&lt;span style="color:#a6e22e">getBeanName&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registry.&lt;span style="color:#a6e22e">registerBeanDefinition&lt;/span>(beanName, definitionHolder.&lt;span style="color:#a6e22e">getBeanDefinition&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String&lt;span style="color:#f92672">[]&lt;/span> aliases &lt;span style="color:#f92672">=&lt;/span> definitionHolder.&lt;span style="color:#a6e22e">getAliases&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (aliases &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String&lt;span style="color:#f92672">[]&lt;/span> var4 &lt;span style="color:#f92672">=&lt;/span> aliases;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> var5 &lt;span style="color:#f92672">=&lt;/span> aliases.&lt;span style="color:#a6e22e">length&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> var6 &lt;span style="color:#f92672">=&lt;/span> 0; var6 &lt;span style="color:#f92672">&amp;lt;&lt;/span> var5; &lt;span style="color:#f92672">++&lt;/span>var6) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String alias &lt;span style="color:#f92672">=&lt;/span> var4&lt;span style="color:#f92672">[&lt;/span>var6&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> registry.&lt;span style="color:#a6e22e">registerAlias&lt;/span>(beanName, alias);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>
&lt;p>拿到beanName&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用beanName和bd去registry里注册.&lt;/p>
&lt;blockquote>
&lt;p>registry是个接口,具体的实现在4.3.7版本中看到两种,一种是SimpleBeanDefinitionRegistry里,和它名字一样非常简单,就是塞进map, 另外一种就复杂了,稍后我们再来看&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>用beanName和alias去registry里注册&lt;/p>
&lt;blockquote>
&lt;p>注册aliases也是接口 ,BeanDefinitionRegistry还是继承自AliasRegistry的, 4.3.7只看到SimpleAliasRegistry一种实现&lt;/p>
&lt;/blockquote>
&lt;p>注册alias就简单多了, SimpleAliasRegistry里有&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> aliasMap &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ConcurrentHashMap(16);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>稍后我再另开一文把SimpleAliasRegistry来读一遍&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="注册beandefinitionholder">
&lt;a href="#%e6%b3%a8%e5%86%8cbeandefinitionholder" class="header-anchor">#&lt;/a>
注册BeanDefinitionHolder
&lt;/h3>&lt;hr>
&lt;p>除了之前的&lt;code>SimpleBeanDefinitionRegistry&lt;/code> 直接往map里面塞值的注册方式之外,我们还有DefaultListableBeanFactory 这个类来实现注册功能,我们主要来了解一下这种注册方式&lt;/p>
&lt;ol>
&lt;li>
&lt;p>校验空参数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果bdh是&lt;code>AbstractBeanDefinition&lt;/code> ,那就要执行它的&lt;code>validate()&lt;/code> 校验&lt;/p>
&lt;ol>
&lt;li>bdh的methodOverride和它的工厂&lt;strong>不能同时存在&lt;/strong>&lt;/li>
&lt;li>如果它beanClass有值,那就要为方法覆盖做准备 &lt;code>prepareMethodOverrides()&lt;/code> ,遍历它的overrides,找这个Bean的Class里面有几个叫这个名字的方法, &lt;strong>如果0个,就抛错&lt;/strong>,如果1个,就设置重载属性为false表示没重载.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>从这个工厂里面&lt;code>beanDefinitionMap&lt;/code> 拿原来的叫这个beanName的bd出来,如果不为空,进行下列校验及操作&lt;/p>
&lt;blockquote>
&lt;p>书中源码spring 3.2 采用sychronized , 而4.3版本的beanDefinitionMap已经用上了ConcurrentHashMap,并且map的value用了BD,而不是3.2里面的Object&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>如果工厂不允许bean覆盖,那么抛错&lt;/li>
&lt;li>如果旧bean的role值小于新的,或者新旧bd完全相等,或者不相等,各打印一下日志&lt;/li>
&lt;li>把新的bd放入&lt;code>beanDefinitionMap&lt;/code>&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>第一次注册这个bean, 如果本工厂的&lt;code>alreadyCreated&lt;/code> 也是空的话,那就不用加锁,直接&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//map里塞入bd &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">beanDefinitionMap&lt;/span>.&lt;span style="color:#a6e22e">put&lt;/span>(beanName, beanDefinition);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//已注册名字里加入beanName &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">beanDefinitionNames&lt;/span>.&lt;span style="color:#a6e22e">add&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//唯一名册里移出beanName(啥时候加入了???) &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">manualSingletonNames&lt;/span>.&lt;span style="color:#a6e22e">remove&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果本工程已经有创建过bean了,那么接下来一段代码就要加synchronized了&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Map var4 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">beanDefinitionMap&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">synchronized&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">beanDefinitionMap&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//map里塞入bd &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">beanDefinitionMap&lt;/span>.&lt;span style="color:#a6e22e">put&lt;/span>(beanName, beanDefinition);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//注意到后面这段操作其实是新建个数组,加上这次注册beanName,然后替换之前的数组....&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//为什么这么复杂呢???&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> updatedDefinitions &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">beanDefinitionNames&lt;/span>.&lt;span style="color:#a6e22e">size&lt;/span>() &lt;span style="color:#f92672">+&lt;/span> 1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> updatedDefinitions.&lt;span style="color:#a6e22e">addAll&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">beanDefinitionNames&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> updatedDefinitions.&lt;span style="color:#a6e22e">add&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">beanDefinitionNames&lt;/span> &lt;span style="color:#f92672">=&lt;/span> updatedDefinitions;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果唯一名册里包含beanName&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">manualSingletonNames&lt;/span>.&lt;span style="color:#a6e22e">contains&lt;/span>(beanName)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//就移出去,但是这里也和上面一样,搞替换....&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Set&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> updatedSingletons &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> LinkedHashSet(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">manualSingletonNames&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> updatedSingletons.&lt;span style="color:#a6e22e">remove&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">manualSingletonNames&lt;/span> &lt;span style="color:#f92672">=&lt;/span> updatedSingletons;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>疑问: 这里都用了替换,明明&lt;code>beanDefinitionNames&lt;/code> 和&lt;code>manualSingletonNames&lt;/code> 都是volatile声明的,每次读都从主内存取,每次写都都将值写到主内存, 这里为什么还要这么麻烦得去开新的list和set,替换旧的呢?&lt;/p>
&lt;p>答:从网上搜到,volatile修饰的变量如果是对象或数组之类的，其含义是对象或数组的&lt;strong>地址具有可见性&lt;/strong>，但是数组或对象&lt;strong>内部的成员改变不具备可见性&lt;/strong>,那等于就是说非得整个地址替换才行咯.&lt;/p>
&lt;p>很爽,从这本书要跳到我正在读的并发编程相关的内容了,这几天再去研究一波volatile,可以再开一文. &lt;a class="link" href="http://blog.csdn.net/u014108122/article/details/38173201" target="_blank" rel="noopener"
>准备参考地址&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;p>然后&lt;code>this.frozenBeanDefinitionNames = null;&lt;/code> 这个冻结/取消冻结bdNames的功能暂时也不知道干啥的,在注册和删除bd的地方看到了这样的置为null,&lt;/p>
&lt;p>​ 只在&lt;code>freezeConfiguration()&lt;/code> 方法内看到把它置为bdNames转的String[] .&lt;/p>
&lt;p>​ 另外在&lt;code>getBeanDefinitionNames()&lt;/code> 方法里有判断这个&lt;/p>
&lt;p>然后&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//如果有老bd或者 这个bean是单例对象?&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (oldBeanDefinition &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">containsSingleton&lt;/span>(beanName)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//重置bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">resetBeanDefinition&lt;/span>(beanName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>重置的主要内容有&lt;/p>
&lt;ul>
&lt;li>清除mergedBD&lt;/li>
&lt;li>销毁单例&lt;/li>
&lt;li>遍历之前的bean,看新注册的这个bean是谁的爹(parent),那些儿子也都要调用这个方法进行重置&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>不得不说这个&lt;code>DefaultListableBeanFactory&lt;/code> 的成员变量实在太多了,搞不清楚一个个都是要干啥的,后面再次遇到的时候再慢慢看吧&lt;/p>
&lt;/blockquote>
&lt;h3 id="注册alias">
&lt;a href="#%e6%b3%a8%e5%86%8calias" class="header-anchor">#&lt;/a>
注册Alias
&lt;/h3>&lt;hr>
&lt;p>4.3.7版本的实现在&lt;code>SimpleAliasRegistry&lt;/code> 里, 详情见 &lt;a class="link" href="https://heeexy.com/2017/09/15/spring_SimpleAliasRegistry/" >这一篇博文&lt;/a>&lt;/p>
&lt;h3 id="注册完成">
&lt;a href="#%e6%b3%a8%e5%86%8c%e5%ae%8c%e6%88%90" class="header-anchor">#&lt;/a>
注册完成
&lt;/h3>&lt;hr>
&lt;p>其实没有操作了, 但是作者留了个位置在这&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getReaderContext&lt;/span>().&lt;span style="color:#a6e22e">fireComponentRegistered&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> BeanComponentDefinition(bdHolder));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果程序开发人员需要对注册BeanDefinition时间进行监听时,可以通过注册监听器的方式来做.Spring并没有再此做任何逻辑处理&lt;/p>
&lt;h3 id="告一段落">
&lt;a href="#%e5%91%8a%e4%b8%80%e6%ae%b5%e8%90%bd" class="header-anchor">#&lt;/a>
告一段落
&lt;/h3>&lt;hr>
&lt;p>至此,我们的解析注册Bean标签可算是告一段落啦,虽然里面还留下了很多疑问待后续阅读中弄清.&lt;/p>
&lt;p>先想想之前是在哪分叉出去的吧.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">parseDefaultElement&lt;/span>(Element ele, BeanDefinitionParserDelegate delegate) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (delegate.&lt;span style="color:#a6e22e">nodeNameEquals&lt;/span>(ele, &lt;span style="color:#e6db74">&amp;#34;import&amp;#34;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">importBeanDefinitionResource&lt;/span>(ele);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (delegate.&lt;span style="color:#a6e22e">nodeNameEquals&lt;/span>(ele, &lt;span style="color:#e6db74">&amp;#34;alias&amp;#34;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">processAliasRegistration&lt;/span>(ele);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (delegate.&lt;span style="color:#a6e22e">nodeNameEquals&lt;/span>(ele, &lt;span style="color:#e6db74">&amp;#34;bean&amp;#34;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//就是这里啦,我们先去阅读最复杂的bean的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">processBeanDefinition&lt;/span>(ele, delegate);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (delegate.&lt;span style="color:#a6e22e">nodeNameEquals&lt;/span>(ele, &lt;span style="color:#e6db74">&amp;#34;beans&amp;#34;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//这个地方我还记得,beans标签是绕回去解析的,不用看了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">doRegisterBeanDefinitions&lt;/span>(ele);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>再之前呢,&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">protected&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">parseBeanDefinitions&lt;/span>(Element root, BeanDefinitionParserDelegate delegate) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (delegate.&lt;span style="color:#a6e22e">isDefaultNamespace&lt;/span>(root)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NodeList nl &lt;span style="color:#f92672">=&lt;/span> root.&lt;span style="color:#a6e22e">getChildNodes&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> nl.&lt;span style="color:#a6e22e">getLength&lt;/span>(); &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Node node &lt;span style="color:#f92672">=&lt;/span> nl.&lt;span style="color:#a6e22e">item&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (node &lt;span style="color:#66d9ef">instanceof&lt;/span> Element) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Element ele &lt;span style="color:#f92672">=&lt;/span> (Element)node;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (delegate.&lt;span style="color:#a6e22e">isDefaultNamespace&lt;/span>(ele)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//就是这个地方,差不多想起来了,beans标签里面的子元素, 如果是默认命名空间,就按默认方式去解析&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">parseDefaultElement&lt;/span>(ele, delegate);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//这里是个分叉,解析自定义元素,以后再看&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delegate.&lt;span style="color:#a6e22e">parseCustomElement&lt;/span>(ele);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//这和上面一样的分叉,解析自定义元素&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delegate.&lt;span style="color:#a6e22e">parseCustomElement&lt;/span>(root);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>再之前呢&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">protected&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">doRegisterBeanDefinitions&lt;/span>(Element root) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BeanDefinitionParserDelegate parent &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">delegate&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">delegate&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">createDelegate&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getReaderContext&lt;/span>(), root, parent);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">delegate&lt;/span>.&lt;span style="color:#a6e22e">isDefaultNamespace&lt;/span>(root)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String profileSpec &lt;span style="color:#f92672">=&lt;/span> root.&lt;span style="color:#a6e22e">getAttribute&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;profile&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (StringUtils.&lt;span style="color:#a6e22e">hasText&lt;/span>(profileSpec)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String&lt;span style="color:#f92672">[]&lt;/span> specifiedProfiles &lt;span style="color:#f92672">=&lt;/span> StringUtils.&lt;span style="color:#a6e22e">tokenizeToStringArray&lt;/span>(profileSpec, &lt;span style="color:#e6db74">&amp;#34;,; &amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getReaderContext&lt;/span>().&lt;span style="color:#a6e22e">getEnvironment&lt;/span>().&lt;span style="color:#a6e22e">acceptsProfiles&lt;/span>(specifiedProfiles)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">logger&lt;/span>.&lt;span style="color:#a6e22e">isInfoEnabled&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">logger&lt;/span>.&lt;span style="color:#a6e22e">info&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Skipped XML bean definition file due to specified profiles [&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> profileSpec &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;] not matching: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getReaderContext&lt;/span>().&lt;span style="color:#a6e22e">getResource&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">preProcessXml&lt;/span>(root);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//从这里走出去的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">parseBeanDefinitions&lt;/span>(root, &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">delegate&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">postProcessXml&lt;/span>(root);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">delegate&lt;/span> &lt;span style="color:#f92672">=&lt;/span> parent;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>到这还要温习一遍的话,可以去看Spring的&lt;a class="link" href="https://heeexy.com/2017/09/11/spring_note_1/" >第一篇笔记&lt;/a>了&lt;/p>
&lt;p>哈哈,这么点东西,读了一个礼拜,读了后面的忘了前面的,还是在读读记记的情况下,&lt;/p>
&lt;p>要是没有这个笔记,这时候估计已经迷路得要放弃了,不容易啊&lt;/p>
&lt;p>不说了 &lt;a class="link" href="https://heeexy.com/2017/09/15/spring_SimpleAliasRegistry/" >SimpleAliasRegistry&lt;/a> 和&lt;code>volatile&lt;/code> 两篇文章的坑还留着呢,继续&amp;hellip;&lt;/p></description></item><item><title>Spring源码笔记-1.3 获取bean流程之解析bean标签中的自定义标签元素</title><link>https://heeexy.com/posts/spring-note-4-decoratebeandefinitionifrequired/</link><pubDate>Fri, 15 Sep 2017 21:24:00 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-4-decoratebeandefinitionifrequired/</guid><description>&lt;h3 id="本文要看啥">
&lt;a href="#%e6%9c%ac%e6%96%87%e8%a6%81%e7%9c%8b%e5%95%a5" class="header-anchor">#&lt;/a>
本文要看啥
&lt;/h3>&lt;hr>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">protected&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">processBeanDefinition&lt;/span>(Element ele, BeanDefinitionParserDelegate delegate) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BeanDefinitionHolder bdHolder &lt;span style="color:#f92672">=&lt;/span> delegate.&lt;span style="color:#a6e22e">parseBeanDefinitionElement&lt;/span>(ele);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (bdHolder &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bdHolder &lt;span style="color:#f92672">=&lt;/span> delegate.&lt;span style="color:#a6e22e">decorateBeanDefinitionIfRequired&lt;/span>(ele, bdHolder);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BeanDefinitionReaderUtils.&lt;span style="color:#a6e22e">registerBeanDefinition&lt;/span>(bdHolder, &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getReaderContext&lt;/span>().&lt;span style="color:#a6e22e">getRegistry&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (BeanDefinitionStoreException var5) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getReaderContext&lt;/span>().&lt;span style="color:#a6e22e">error&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Failed to register bean definition with name &amp;#39;&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> bdHolder.&lt;span style="color:#a6e22e">getBeanName&lt;/span>() &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#39;&amp;#34;&lt;/span>, ele, var5);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getReaderContext&lt;/span>().&lt;span style="color:#a6e22e">fireComponentRegistered&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> BeanComponentDefinition(bdHolder));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>前面的笔记中,我们已经走完了这个方法中的第一步,感觉第一步就走了很远,眼瞅要迷路了,但无论如何,总归是拿到了我们的bdHolder, 里面已经存放了Bean标签里面的默认的元素.&lt;/p>
&lt;p>如果bdHolder不为空的话,我们可以继续往下走啦.&lt;/p>
&lt;p>今天来研究下这段代码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>bdHolder &lt;span style="color:#f92672">=&lt;/span> delegate.&lt;span style="color:#a6e22e">decorateBeanDefinitionIfRequired&lt;/span>(ele, bdHolder);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>看方法名字就大概知道,这里要做的事情就是 如果有需要的话,装饰我们刚拿到的bdHolder.&lt;/p>
&lt;p>那么何为需要呢?下面这样的场景便是了&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;bean&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;test&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">class=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;test.myClass&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;mybean:user&lt;/span> &lt;span style="color:#a6e22e">username=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;aaa&amp;#34;&lt;/span>&lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;/bean&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的自定义标签和&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;mvc:resources&lt;/span> &lt;span style="color:#a6e22e">mapping=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/img/**&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">location=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;img/&amp;#34;&lt;/span>&lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;aop:config/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;tx:advice&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;transactionAdvice&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">transaction-manager=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;transactionManager&amp;#34;&lt;/span>&lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>并不同,这里的是在bean内的, 而mvc那种标签是在beans里面,与bean同级的&lt;/p>
&lt;h3 id="开始进入方法吧">
&lt;a href="#%e5%bc%80%e5%a7%8b%e8%bf%9b%e5%85%a5%e6%96%b9%e6%b3%95%e5%90%a7" class="header-anchor">#&lt;/a>
开始进入方法吧
&lt;/h3>&lt;hr>
&lt;p>这次要看的主要方法就是 &lt;strong>decorateBeanDefinitionIfRequired&lt;/strong>&lt;/p>
&lt;p>这个方法主要是拆开我们之前的bean,将其各属性和各子节点全部变为node,&lt;/p>
&lt;p>然后带着每个node和之前的bd去 &lt;strong>decorateIfRequired&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> BeanDefinitionHolder &lt;span style="color:#a6e22e">decorateIfRequired&lt;/span>(Node node, BeanDefinitionHolder originalDef, BeanDefinition containingBd) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String namespaceUri &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getNamespaceURI&lt;/span>(node);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//看看是不是默认命名空间, 如果是的话那就不用管了, 在这方法里,我们只需处理自定义的标签&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">isDefaultNamespace&lt;/span>(namespaceUri)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//拿到这个命名空间的解析器 handler&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NamespaceHandler handler &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">readerContext&lt;/span>.&lt;span style="color:#a6e22e">getNamespaceHandlerResolver&lt;/span>().&lt;span style="color:#a6e22e">resolve&lt;/span>(namespaceUri);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果能找到解析器,我们就可以进入装饰方法啦&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (handler &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> handler.&lt;span style="color:#a6e22e">decorate&lt;/span>(node, originalDef, &lt;span style="color:#66d9ef">new&lt;/span> ParserContext(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">readerContext&lt;/span>, &lt;span style="color:#66d9ef">this&lt;/span>, containingBd));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//以下都是没找到解析器的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//命名空间不为null,而且还以spring家的网址开头,那就报错表示找不到spring解析器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (namespaceUri &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> namespaceUri.&lt;span style="color:#a6e22e">startsWith&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;http://www.springframework.org/&amp;#34;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">error&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Unable to locate Spring NamespaceHandler for XML schema namespace [&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> namespaceUri &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;]&amp;#34;&lt;/span>, node);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">logger&lt;/span>.&lt;span style="color:#a6e22e">isDebugEnabled&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果能打日志的话,打个日志完事 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">logger&lt;/span>.&lt;span style="color:#a6e22e">debug&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;No Spring NamespaceHandler found for XML schema namespace [&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> namespaceUri &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;]&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> originalDef;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>具体的用handler解析node会在后面详细学习,这个就先到这吧!&lt;/p>
&lt;blockquote>
&lt;p>前面几篇文章都长得没法看了&amp;hellip;吸取教训 篇幅尽量不要太长了.&lt;/p>
&lt;/blockquote></description></item><item><title>ConstructorArgumentValues 构造器参数值保存器</title><link>https://heeexy.com/posts/spring-note-3-constructorargumentvalues/</link><pubDate>Thu, 14 Sep 2017 21:10:33 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-3-constructorargumentvalues/</guid><description>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer, ConstructorArgumentValues.&lt;span style="color:#a6e22e">ValueHolder&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> indexedArgumentValues &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> LinkedHashMap(0);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>ConstructorArgumentValues.&lt;span style="color:#a6e22e">ValueHolder&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> genericArgumentValues &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> LinkedList();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个保存器的核心就在他的LinkedHashMap和LinkedList&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>疑问: 这里为什么选用linked来储存呢?&lt;/strong>&lt;/p>
&lt;p>答:&lt;/p>
&lt;/blockquote>
&lt;p>添加有index的关键代码如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">addOrMergeIndexedArgumentValue&lt;/span>(Integer key, ConstructorArgumentValues.&lt;span style="color:#a6e22e">ValueHolder&lt;/span> newValue) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//拿当前这个位置的值&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ConstructorArgumentValues.&lt;span style="color:#a6e22e">ValueHolder&lt;/span> currentValue &lt;span style="color:#f92672">=&lt;/span> (ConstructorArgumentValues.&lt;span style="color:#a6e22e">ValueHolder&lt;/span>)&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">indexedArgumentValues&lt;/span>.&lt;span style="color:#a6e22e">get&lt;/span>(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果当前位置有值,并且新值是接受合并的话,那合并一波之后作为新值&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果不接受合并的话,那扔了之前的value不管了,只用新来的value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (currentValue &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> newValue.&lt;span style="color:#a6e22e">getValue&lt;/span>() &lt;span style="color:#66d9ef">instanceof&lt;/span> Mergeable) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Mergeable mergeable &lt;span style="color:#f92672">=&lt;/span> (Mergeable)newValue.&lt;span style="color:#a6e22e">getValue&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (mergeable.&lt;span style="color:#a6e22e">isMergeEnabled&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> newValue.&lt;span style="color:#a6e22e">setValue&lt;/span>(mergeable.&lt;span style="color:#a6e22e">merge&lt;/span>(currentValue.&lt;span style="color:#a6e22e">getValue&lt;/span>()));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//将新值放入LinkedHashMap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">indexedArgumentValues&lt;/span>.&lt;span style="color:#a6e22e">put&lt;/span>(key, newValue);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>&lt;strong>疑问:在获取vh之前我们不就验证过index不能重复么?为什么这里还有可能搞一波合并?是有其它地方也调用这个方法,那里可以合并?&lt;/strong>&lt;/p>
&lt;p>答: 注意到这个类里有个方法,addArgumentValues(ConstructorArgumentValues other),貌似就是专门和其它CAV搞合并的,用CAV做构造参数的那个构造器调用了此方法,这里会有可能需要合并&lt;/p>
&lt;/blockquote>
&lt;p>添加没有index的参数&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">addGenericArgumentValue&lt;/span>(ConstructorArgumentValues.&lt;span style="color:#a6e22e">ValueHolder&lt;/span> newValue) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//校验不为空&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Assert.&lt;span style="color:#a6e22e">notNull&lt;/span>(newValue, &lt;span style="color:#e6db74">&amp;#34;ValueHolder must not be null&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果list内已经含有此value则跳过&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">genericArgumentValues&lt;/span>.&lt;span style="color:#a6e22e">contains&lt;/span>(newValue)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">addOrMergeGenericArgumentValue&lt;/span>(newValue);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//添加或合并VH&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">addOrMergeGenericArgumentValue&lt;/span>(ConstructorArgumentValues.&lt;span style="color:#a6e22e">ValueHolder&lt;/span> newValue) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (newValue.&lt;span style="color:#a6e22e">getName&lt;/span>() &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Iterator it &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">genericArgumentValues&lt;/span>.&lt;span style="color:#a6e22e">iterator&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果新VH有name,那么就要遍历之前的list,找出同名的老VH&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//看新VH接不接受合并,接收就合并下再删,不接受就直接删掉.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(it.&lt;span style="color:#a6e22e">hasNext&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ConstructorArgumentValues.&lt;span style="color:#a6e22e">ValueHolder&lt;/span> currentValue &lt;span style="color:#f92672">=&lt;/span> (ConstructorArgumentValues.&lt;span style="color:#a6e22e">ValueHolder&lt;/span>)it.&lt;span style="color:#a6e22e">next&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (newValue.&lt;span style="color:#a6e22e">getName&lt;/span>().&lt;span style="color:#a6e22e">equals&lt;/span>(currentValue.&lt;span style="color:#a6e22e">getName&lt;/span>())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (newValue.&lt;span style="color:#a6e22e">getValue&lt;/span>() &lt;span style="color:#66d9ef">instanceof&lt;/span> Mergeable) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Mergeable mergeable &lt;span style="color:#f92672">=&lt;/span> (Mergeable)newValue.&lt;span style="color:#a6e22e">getValue&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (mergeable.&lt;span style="color:#a6e22e">isMergeEnabled&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> newValue.&lt;span style="color:#a6e22e">setValue&lt;/span>(mergeable.&lt;span style="color:#a6e22e">merge&lt;/span>(currentValue.&lt;span style="color:#a6e22e">getValue&lt;/span>()));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> it.&lt;span style="color:#a6e22e">remove&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//将新VH塞入list里面&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">genericArgumentValues&lt;/span>.&lt;span style="color:#a6e22e">add&lt;/span>(newValue);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>发现addGenericArgumentValue(Object value) 和addGenericArgumentValue(Object value, String type)就没这么麻烦,因为他们拿Object构造的肯定没name,也不会为null,直接懒得考虑合并,也不去验证list是否已存在这个VH, 直接塞&amp;hellip;有相同的覆盖掉就是了&amp;hellip;&lt;/p>
&lt;p>只是暂时还没看到在哪这么直接地调用这种塞Object的方法&lt;/p>
&lt;/blockquote>
&lt;p>既然都看完了CAV的赋值,干脆来看看它的取值和其它方法吧!&lt;/p>
&lt;ol>
&lt;li>
&lt;p>获取它的list,map都是 &lt;strong>Collections.unmodifiableMap&lt;/strong>(this.indexedArgumentValues);&lt;/p>
&lt;p>&lt;strong>Collections.unmodifiableList&lt;/strong>(this.genericArgumentValues);这样都是返回只读的集合出去,调用set/add/remove的话会报错&lt;/p>
&lt;/li>
&lt;li>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">getArgumentCount&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">indexedArgumentValues&lt;/span>.&lt;span style="color:#a6e22e">size&lt;/span>() &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">genericArgumentValues&lt;/span>.&lt;span style="color:#a6e22e">size&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isEmpty&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">indexedArgumentValues&lt;/span>.&lt;span style="color:#a6e22e">isEmpty&lt;/span>() &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">genericArgumentValues&lt;/span>.&lt;span style="color:#a6e22e">isEmpty&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">clear&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">indexedArgumentValues&lt;/span>.&lt;span style="color:#a6e22e">clear&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">genericArgumentValues&lt;/span>.&lt;span style="color:#a6e22e">clear&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>重头戏,拿参数值,这里又分为3种情况,取Indexed的,取Generic的,拿个index就想直接取的,每种情况里都有不同参数的重载.&lt;/p>
&lt;p>我估计实际使用应该是都用第三种情况吧,因为包括了前两种,&lt;/p>
&lt;p>而且真正构造需要拿参数的时候,肯定是想给个index,按照顺序去CAV里直接拿,不管放入参数时是否indexed&lt;/p>
&lt;p>​&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> ConstructorArgumentValues.&lt;span style="color:#a6e22e">ValueHolder&lt;/span> &lt;span style="color:#a6e22e">getArgumentValue&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> index, Class&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> requiredType, String requiredName, Set&lt;span style="color:#f92672">&amp;lt;&lt;/span>ConstructorArgumentValues.&lt;span style="color:#a6e22e">ValueHolder&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> usedValueHolders) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Assert.&lt;span style="color:#a6e22e">isTrue&lt;/span>(index &lt;span style="color:#f92672">&amp;gt;=&lt;/span> 0, &lt;span style="color:#e6db74">&amp;#34;Index must not be negative&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//先根据index去Map里面找&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ConstructorArgumentValues.&lt;span style="color:#a6e22e">ValueHolder&lt;/span> valueHolder &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getIndexedArgumentValue&lt;/span>(index, requiredType, requiredName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (valueHolder &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果没有的话,就再去list里面找, 从这可以看出,我们在XML里写参数的时候,最好是带上index,在这里找的快一点哦!&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> valueHolder &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getGenericArgumentValue&lt;/span>(requiredType, requiredName, usedValueHolders);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> valueHolder;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;p>从map里面取Indexed的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> ConstructorArgumentValues.&lt;span style="color:#a6e22e">ValueHolder&lt;/span> &lt;span style="color:#a6e22e">getIndexedArgumentValue&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> index, Class&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> requiredType, String requiredName) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Assert.&lt;span style="color:#a6e22e">isTrue&lt;/span>(index &lt;span style="color:#f92672">&amp;gt;=&lt;/span> 0, &lt;span style="color:#e6db74">&amp;#34;Index must not be negative&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ConstructorArgumentValues.&lt;span style="color:#a6e22e">ValueHolder&lt;/span> valueHolder &lt;span style="color:#f92672">=&lt;/span> (ConstructorArgumentValues.&lt;span style="color:#a6e22e">ValueHolder&lt;/span>)&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">indexedArgumentValues&lt;/span>.&lt;span style="color:#a6e22e">get&lt;/span>(index);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//这里一波||&amp;amp;&amp;amp;!简直了...总结一下有哪些情况返回null吧&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 1. 根据这个index取出来的VH就是null
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 2. VH的type不为null,可是( requiredType为null 或者 两者type不匹配)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 3. VH的name不为null,requiredName不为&amp;#34;&amp;#34; 可是( requiredName为null 或者 两者name不匹配)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> valueHolder &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">||&lt;/span> valueHolder.&lt;span style="color:#a6e22e">getType&lt;/span>() &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> (requiredType &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#f92672">!&lt;/span>ClassUtils.&lt;span style="color:#a6e22e">matchesTypeName&lt;/span>(requiredType, valueHolder.&lt;span style="color:#a6e22e">getType&lt;/span>())) &lt;span style="color:#f92672">||&lt;/span> valueHolder.&lt;span style="color:#a6e22e">getName&lt;/span>() &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">equals&lt;/span>(requiredName) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> (requiredName &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#f92672">!&lt;/span>requiredName.&lt;span style="color:#a6e22e">equals&lt;/span>(valueHolder.&lt;span style="color:#a6e22e">getName&lt;/span>())) &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> : valueHolder;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>注意到一个细节,在判断name的时候, requiredName如果给了&amp;quot;&amp;quot; 这个值,就不会拿去判断name是否匹配&amp;hellip;不知这是何用意&amp;hellip;&lt;/p>
&lt;/blockquote>
&lt;p>从list里面取&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> ConstructorArgumentValues.&lt;span style="color:#a6e22e">ValueHolder&lt;/span> &lt;span style="color:#a6e22e">getGenericArgumentValue&lt;/span>(Class&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> requiredType, String requiredName, Set&lt;span style="color:#f92672">&amp;lt;&lt;/span>ConstructorArgumentValues.&lt;span style="color:#a6e22e">ValueHolder&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> usedValueHolders) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Iterator var4 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">genericArgumentValues&lt;/span>.&lt;span style="color:#a6e22e">iterator&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ConstructorArgumentValues.&lt;span style="color:#a6e22e">ValueHolder&lt;/span> valueHolder;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//这里的4层嵌套循环和疯狂的||&amp;amp;&amp;amp;!更是简直了........从里向外一层层看吧&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">do&lt;/span> {&lt;span style="color:#75715e">//最后看这个最外层,如果同时满足下列条件,说明这个VH还不是我们要的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 1.requiredType不是null
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 2.VH的Type却是null
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 3.VH的name也是null
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 4.type校验通不过
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * (第4步校验要通过需要满足以下情况之一
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * a. value==null 且 requiredType不是基本数据类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * b. value不等于null 且 (valueClass继承或实现requiredType
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 或valueClass包装或解包装后能等于requiredType..)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>) {&lt;span style="color:#75715e">//再次 看这层,如果匹配到类型相同的,就说明有可能找到我们需要的参数啦,跳出来到最外层再接受一次校验.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果不匹配的话,继续执行里面的循环找下一个VH吧.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">do&lt;/span> {&lt;span style="color:#75715e">//其次看这层循环,如果VH有name,requiredName不为&amp;#34;&amp;#34;,但rqName为null或者两者不相等,跳过此VH,这说明VH有name的话就很关键,必须相同啊,除非rqName==&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">do&lt;/span> {&lt;span style="color:#75715e">//首先看这里的循环, 取下一个VH,如果取完了,就返回null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>var4.&lt;span style="color:#a6e22e">hasNext&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> valueHolder &lt;span style="color:#f92672">=&lt;/span> (ConstructorArgumentValues.&lt;span style="color:#a6e22e">ValueHolder&lt;/span>)var4.&lt;span style="color:#a6e22e">next&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果set不为空,并且set里已经包含这个VH了就跳过此VH&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">while&lt;/span>(usedValueHolders &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> usedValueHolders.&lt;span style="color:#a6e22e">contains&lt;/span>(valueHolder));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">while&lt;/span>(valueHolder.&lt;span style="color:#a6e22e">getName&lt;/span>() &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">equals&lt;/span>(requiredName) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> (requiredName &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#f92672">!&lt;/span>valueHolder.&lt;span style="color:#a6e22e">getName&lt;/span>().&lt;span style="color:#a6e22e">equals&lt;/span>(requiredName)));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (valueHolder.&lt;span style="color:#a6e22e">getType&lt;/span>() &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">||&lt;/span> requiredType &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> ClassUtils.&lt;span style="color:#a6e22e">matchesTypeName&lt;/span>(requiredType, valueHolder.&lt;span style="color:#a6e22e">getType&lt;/span>())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">while&lt;/span>(requiredType &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> valueHolder.&lt;span style="color:#a6e22e">getType&lt;/span>() &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> valueHolder.&lt;span style="color:#a6e22e">getName&lt;/span>() &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>ClassUtils.&lt;span style="color:#a6e22e">isAssignableValue&lt;/span>(requiredType, valueHolder.&lt;span style="color:#a6e22e">getValue&lt;/span>()));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> valueHolder;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>总而言之,从list里面找到我们需要的那个参数真是非常麻烦,需要这个VH满足下列条件:&lt;/p>
&lt;ol>
&lt;li>不在usedVH的那个set里&lt;/li>
&lt;li>有name且rqName不是&amp;quot;&amp;quot; 就必须name匹配&lt;/li>
&lt;li>有rqType的话,说明必须来满足这个type的匹配,那么type怎么确认是匹配的呢?
&lt;ol>
&lt;li>type不是null,那就直接去匹配&lt;/li>
&lt;li>type是null,如果name也是null,(说明之前用不写name方式绕过了上面的第2步name验证,如果上面第二步用的是&amp;quot;&amp;ldquo;方式就不用管了,直接算通过), 那就必须要value.getClass能去真正的和rqType进行匹配 (继承,实现,包装,解包各种方式能匹配上就OK)&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>这里是真的麻烦,再换个角度再梳理一遍!&lt;/p>
&lt;ol>
&lt;li>如果rqName写了比如&amp;quot;age&amp;rdquo;,VH里name也写了的话,那就必须name也是&amp;quot;age&amp;quot;才通过&lt;/li>
&lt;li>如果rqName写个&amp;quot;&amp;quot;,那就表示name属性完全不管了,都算通过&lt;/li>
&lt;li>如果rqName是null,那有name的VH都不行, 没name的VH可以通过&lt;/li>
&lt;li>如果rqType没写,那就表示type不管了,都算通过(估计实际调用不会name和type全部不管吧&amp;hellip;&amp;hellip;.)&lt;/li>
&lt;li>如果rqType写了,那就表示要验证type啦,从上面放行过来的VH需要校验了
&lt;ol>
&lt;li>如果VHtype为null,但是有name,说明通过1.2放过来的,都算ok (那个&amp;quot;&amp;ldquo;就很坑了,VH随便填个name,不填type就可能全部通过了)&lt;/li>
&lt;li>如果VHtype为null,name也是null,那就去ClassUtils.isAssignableValue校验VHvalue的本质class能否对得上.&lt;/li>
&lt;li>如果VHtype不是null,那就必须type也完全一致&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>我预测正常调用情况应该是rqName和rqType都有明确要求吧,那么正常流程就应该是&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>VH有name最好,匹配上直接通过!&lt;/li>
&lt;li>VH如果没name,有type,那就去匹配type!&lt;/li>
&lt;li>VH如果啥都没有,那就拿VHvalue的class去跟rqType匹配,这总跑不了了吧!&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>这个地方盯着看了几个小时,不知道作者写这么复杂是何居心,调用的时候也准备做这么复杂么?拿构造器参数的时候就不能把requiredName和requiredType都带过来??? 还搞些双引号&amp;quot;&amp;ldquo;这种怪事情???&lt;/p>
&lt;/blockquote></description></item><item><title>Spring源码笔记-1.2 获取bean流程之bean标签的解析及注册</title><link>https://heeexy.com/posts/spring-note-2/</link><pubDate>Tue, 12 Sep 2017 21:41:09 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-2/</guid><description>&lt;p>&lt;img src="http://ots7yt7am.bkt.clouddn.com/blog/spring_parseDefaultElement2.png"
loading="lazy"
>&lt;/p>
&lt;h2 id="1解析beandefinition">
&lt;a href="#1%e8%a7%a3%e6%9e%90beandefinition" class="header-anchor">#&lt;/a>
1.解析BeanDefinition
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>BeanDefinitionHolder bdHolder &lt;span style="color:#f92672">=&lt;/span> delegate.&lt;span style="color:#a6e22e">parseBeanDefinitionElement&lt;/span>(ele);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>作用就是将element封装进bdHolder里面.&lt;/p>
&lt;p>其源码很长,不贴了,但功能流程还很清晰&lt;/p>
&lt;ol>
&lt;li>
&lt;p>处理id,name,aliases. 关键是需要&lt;strong>beanName&lt;/strong> ,&lt;/p>
&lt;p>name分隔开做aliases的list.&lt;/p>
&lt;p>beanName&lt;strong>优先用id&lt;/strong>,没id的话就从aliases里&lt;strong>remove(0&lt;/strong>)出来一个,&lt;/p>
&lt;p>如果有beanName了,校验beanName和aliases唯一性&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>​ 如果还是没beanName,等会再给它用方法生成个&lt;/p>
&lt;ol start="2">
&lt;li>将element解析,放入GenericBeanDefinition里面&lt;/li>
&lt;li>把上一步拿到的bd连带着aliases转String[], beanName一起封装一下成为BeanDefinitionHolder返回;如果上一步返回null,就直接返回null&lt;/li>
&lt;/ol>
&lt;p>这里的关键步骤显然是第二步,element转beanDefinition&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> AbstractBeanDefinition beanDefinition &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">parseBeanDefinitionElement&lt;/span>(ele, beanName, containingBean);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个方法也很长,大概步骤是&lt;/p>
&lt;ol>
&lt;li>this.parseState.push(new BeanEntry(beanName)) 开头push,结尾pop,不明白是做什么???&lt;/li>
&lt;li>获取下className和parent&lt;/li>
&lt;li>拿着className和parent去创建个GenericBeanDefinition bd&lt;/li>
&lt;li>&lt;strong>拿着bd和element进行一系列的解析步骤,把各种值塞入bd&lt;/strong>&lt;/li>
&lt;li>返回bd&lt;/li>
&lt;li>this.parseState.pop();&lt;/li>
&lt;/ol>
&lt;h4 id="解析各种属性">
&lt;a href="#%e8%a7%a3%e6%9e%90%e5%90%84%e7%a7%8d%e5%b1%9e%e6%80%a7" class="header-anchor">#&lt;/a>
解析各种属性
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">parseBeanDefinitionAttributes&lt;/span>(ele, beanName, containingBean, bd);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>这个方法的代码丧心病狂地达到了70行,相比于目前读到的其它源码,确实是最长的一个.&lt;/p>
&lt;p>但是里面的内容其实并不复杂,就是一个个地从element拿属性,塞属性进bd, 各种 get &amp;amp; set .感觉确实不太好重构.&lt;/p>
&lt;/blockquote>
&lt;p>解析了很多属性,包括scope,abstract,lazy-init,autowire&amp;hellip;&lt;/p>
&lt;h4 id="解析子元素meta">
&lt;a href="#%e8%a7%a3%e6%9e%90%e5%ad%90%e5%85%83%e7%b4%a0meta" class="header-anchor">#&lt;/a>
解析子元素meta
&lt;/h4>&lt;p>&lt;img src="http://ots7yt7am.bkt.clouddn.com/blog/spring_parseMeta.png"
loading="lazy"
>&lt;/p>
&lt;h4 id="解析子元素lookup-method">
&lt;a href="#%e8%a7%a3%e6%9e%90%e5%ad%90%e5%85%83%e7%b4%a0lookup-method" class="header-anchor">#&lt;/a>
解析子元素lookup-method
&lt;/h4>&lt;p>解析方法和meta差别很小,这里主要是去了解下lookup-method的功能&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;bean&lt;/span> &lt;span style="color:#a6e22e">class=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;beanClass&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;lookup-method&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;method&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">bean=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;non-singleton-bean&amp;#34;&lt;/span>&lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;/bean&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>method是beanClass中的一个方法，beanClass和method是不是抽象都无所谓，不会影响CGLIB的动态代理，根据项目实际需求去定义。non-singleton-bean指的是lookup-method中bean属性指向的必须是一个&lt;strong>非单例模式&lt;/strong>的bean，当然如果不是也不会报错，只是每次得到的都是相同引用的bean（同一个实例），这样用lookup-method就没有意义了。&lt;/p>
&lt;p>参考: &lt;a class="link" href="http://www.cnblogs.com/ViviChan/p/4981619.html" target="_blank" rel="noopener"
>Spring - lookup-method方式实现依赖注入&lt;/a>&lt;/p>
&lt;h4 id="解析子元素replaced-method">
&lt;a href="#%e8%a7%a3%e6%9e%90%e5%ad%90%e5%85%83%e7%b4%a0replaced-method" class="header-anchor">#&lt;/a>
解析子元素replaced-method
&lt;/h4>&lt;p>这个不仅可以动态地替换返回实体bean,而且还能动态地更改原有方法的逻辑!!!&lt;/p>
&lt;h4 id="解析子元素constructor-arg">
&lt;a href="#%e8%a7%a3%e6%9e%90%e5%ad%90%e5%85%83%e7%b4%a0constructor-arg" class="header-anchor">#&lt;/a>
解析子元素constructor-arg
&lt;/h4>&lt;p>这里提取构造参数的一些属性值就相比之前复杂多了.&lt;/p>
&lt;ol>
&lt;li>提取index,type,name,判断是否有index属性值&lt;/li>
&lt;li>如果有index:
&lt;ol>
&lt;li>构造Entry压入parseState栈&lt;/li>
&lt;li>解析constructor-arg的子元素&lt;/li>
&lt;li>使用ConstructorArgumentValues.ValueHolder类型来封装解析出来的元素&lt;/li>
&lt;li>将index,type,name属性一并封装在ValueHolder中,&lt;/li>
&lt;li>验证index是否用过了,用过则抛错,跳过此条参数&lt;/li>
&lt;li>ValueHolder添加至当前BeanDefinition的construArgumentValues的&lt;strong>indexedArgurmentValues&lt;/strong>属性中.&lt;/li>
&lt;li>弹出栈&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>如果没有index:
&lt;ol>
&lt;li>同上压入栈&lt;/li>
&lt;li>解析constructor-arg的子元素&lt;/li>
&lt;li>使用ConstructorArgumentValues.ValueHolder类型来封装解析出来的元素&lt;/li>
&lt;li>将index,type,name属性一并封装在ValueHolder中,并且添加至当前BeanDefinition的construArgumentValues的&lt;strong>genericArgurmentValues&lt;/strong>属性中.&lt;/li>
&lt;li>弹出栈&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>可以看出,有没有index其实流程没区别,主要在于在bd中保存的位置不同,另外有index的需要验证下index的唯一&lt;/p>
&lt;h5 id="parsepropertyvalue">
&lt;a href="#parsepropertyvalue" class="header-anchor">#&lt;/a>
parsePropertyValue
&lt;/h5>&lt;p>解析constructor-arg的子元素&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Object value &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">parsePropertyValue&lt;/span>(ele, bd, (String)&lt;span style="color:#66d9ef">null&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个方法也很长,里面的关键在于此处解析constructor-arg下面的子元素时,下面三种情况&lt;strong>必须&lt;/strong>且&lt;strong>只能&lt;/strong>占一种&lt;/p>
&lt;ul>
&lt;li>有ref属性&lt;/li>
&lt;li>有value属性&lt;/li>
&lt;li>有子元素(description和meta除外,这两种不用处理),子元素只能列一个&lt;/li>
&lt;/ul>
&lt;p>上面三种情况对应不同的处理方法:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>ref:&lt;/p>
&lt;p>校验下ref的值不能为空,然后&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> RuntimeBeanReference ref &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> RuntimeBeanReference(refName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ref.&lt;span style="color:#a6e22e">setSource&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">extractSource&lt;/span>(ele));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ref;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>用RuntimeBeanReference封装下这个要引用的bean的beanName,塞下resource,返回&lt;/p>
&lt;blockquote>
&lt;p>查看BeanReference源码时注意到有RuntimeBeanReference和RuntimeBeanNameReference两种实现,貌似区别不大,RuntimeBeanReference多个toParent的boolean属性,此处给的也是false值.&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>value:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>TypedStringValue valueHolder &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> TypedStringValue(ele.&lt;span style="color:#a6e22e">getAttribute&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;value&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>valueHolder.&lt;span style="color:#a6e22e">setSource&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">extractSource&lt;/span>(ele));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">return&lt;/span> valueHolder;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>用TypedStringValue封装下value的值 返回&lt;/p>
&lt;blockquote>
&lt;p>TypedStringValue和BeanReference都是实现BeanMetadataElement的,实现了Object getSource();方法&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>子元素&lt;strong>parsePropertySubElement&lt;/strong>: 这个又复杂了,判断10+种情况&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果不是默认命名空间,则按其自定义的方式去解析&lt;/p>
&lt;/li>
&lt;li>
&lt;p>bean元素,按照本文的方式解析,拿到一个BeanDefinitionHolder bdHolder,bdHolder不为空的话,可能还要装饰一下(在这个元素的属性或子元素节点命名空间不为默认情况下, 用自定义方式解析后去装饰),返回最终解析+装饰的结果 bdHolder&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ref: 主要还是拿要引用的beanName, 取值顺序为其属性 bean&amp;ndash;local&amp;ndash;parent,和之前的ref一样,用RuntimeBeanReference封装下这个要引用的bean的beanName,塞下resource,返回&lt;/p>
&lt;/li>
&lt;li>
&lt;p>idref:和ref差不多,取值顺序为bean&amp;ndash;local&lt;/p>
&lt;/li>
&lt;li>
&lt;p>value: 拿文本值,拿type值,没type就用传来的默认typeName,此处为null,然后根据value,typeName和BeanClassLoader来构造一个TypedStringValue,返回&lt;/p>
&lt;/li>
&lt;li>
&lt;p>null:用null来new一个TypedStringValue,返回&lt;/p>
&lt;/li>
&lt;li>
&lt;p>array:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>拿value-type和子节点list&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用type和子节点size构建个ManagedArray&lt;/p>
&lt;blockquote>
&lt;p>ManagedArray继承ManagedList&lt;!-- raw HTML omitted --> 继承ArrayList&lt;!-- raw HTML omitted --> ,&lt;/p>
&lt;p>ManagedList实现Mergeable和BeanMetadataElement ,可以有merge和getSource&lt;/p>
&lt;/blockquote>
&lt;p>然后设置source和merge属性 (此处还多余重复了一遍setElementTypeName(elementType);),&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后 this.parseCollectionElements(nl, target, bd, defaultElementType); 对其子节点进行一个个的再解析子元素,还是调用&lt;strong>parsePropertySubElement&lt;/strong>方法,只是带了个默认类型defaultElementType&lt;/p>
&lt;blockquote>
&lt;p>看到这已经有点晕了, 最初的那个bd都跑了多少路了?? 子元素里的属性也往bd里直接塞,不就丢失父子结构了么???&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>list: 和array没什么差别,仅有的区别在于用ManagedList ,(ManagedArray还是继承自他的)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>set:同上,仅有的区别在于用ManagedSet,继承自LinkedHashSet&lt;/p>
&lt;/li>
&lt;li>
&lt;p>map:这个方法100行,非常长&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;constructor-arg&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;score&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;map&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;entry&lt;/span> &lt;span style="color:#a6e22e">key=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;math&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">value=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;90&amp;#34;&lt;/span>&lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;entry&lt;/span> &lt;span style="color:#a6e22e">key=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;english&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">value=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;85&amp;#34;&lt;/span>&lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/map&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/constructor-arg&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>
&lt;p>拿key-tpye和value-type,子节点entry的list&lt;/p>
&lt;/li>
&lt;li>
&lt;p>构建ManagedMap,设source,KeyTypeName,ValueTypeName,MergeEnable&lt;/p>
&lt;/li>
&lt;li>
&lt;p>遍历entry节点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>拿entry再下一层的子节点,遍历,如果是key节点,则设这个entry的keyEle为此,key只能最多出现一遍, 然后剩下的节点除了description之外最多只能有一个,作为valueEle.所以此处表明这里貌似可以这么写???&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;constructor-arg&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;score&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;map&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;entry&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;key&amp;gt;&lt;/span>哈哈&lt;span style="color:#f92672">&amp;lt;/key&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;vvvaaluue&amp;gt;&lt;/span>这样写value??&lt;span style="color:#f92672">&amp;lt;/vvvaaluue&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;description&amp;gt;&lt;/span>描述随便写,相当于注释&lt;span style="color:#f92672">&amp;lt;/description&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;description&amp;gt;&lt;/span>描述随便写,相当于注释&lt;span style="color:#f92672">&amp;lt;/description&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/entry&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/map&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/constructor-arg&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后又和解析constructor-arg的子元素类似的情况,三种情况&lt;strong>必须&lt;/strong>且&lt;strong>只能&lt;/strong>出现一种:1.&amp;ldquo;key&amp;quot;属性;2.&amp;ldquo;key-ref&amp;quot;属性;3.&amp;ldquo;key&amp;quot;子元素, 三种对应不同的解析&lt;/p>
&lt;p>key:TypedStringValue来封装&lt;/p>
&lt;p>key-ref:RuntimeBeanReference来封装&lt;/p>
&lt;p>key子元素: 里面必须且只能有一个节点,进行parsePropertySubElement,这和在array那看到的一样了&lt;/p>
&lt;p>三种解析后返回的Objext赋值给key&lt;/p>
&lt;p>然后解析value,和上面解析key类似,以下三种&lt;strong>必须&lt;/strong>且&lt;strong>只能&lt;/strong>出现一种:&lt;/p>
&lt;p>(有点区别在于value-ref属性和value-type属性不能并存,&lt;/p>
&lt;p>有value-type时就必须要有value属性或者value子节点)&lt;/p>
&lt;p>value属性:拿value-type,没有就用默认的value-type(map节点下的,当然也可能没有),构建TypedStringValue&lt;/p>
&lt;p>value-ref属性:构建RuntimeBeanReference&lt;/p>
&lt;p>value子节点:老样子,还是parsePropertySubElement这样来继续解析子节点&lt;/p>
&lt;p>key,value都拿到之后,会塞入ManagedMap,最终返回ManagedMap&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>props&lt;/strong>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;constructor-arg&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;props&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;prop&lt;/span> &lt;span style="color:#a6e22e">key=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;firstName&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Rob
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/prop&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;prop&lt;/span> &lt;span style="color:#a6e22e">key=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;secondName&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Harrop
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/prop&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/props&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;/constructor-arg&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个就简单了,无非就是遍历props下面的prop元素,拿key属性,拿文本值的trim(),塞入Properties对象,返回这个properties&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>至此,解析constructor-arg的子元素算是完成了, 都快忘掉这只是解析constructor-arg里的第一步了&amp;hellip;&lt;/p>
&lt;p>总之这一步解析完子元素,返回Object对象回来,作为value&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h5 id="valueholder">
&lt;a href="#valueholder" class="header-anchor">#&lt;/a>
ValueHolder
&lt;/h5>&lt;p>用上一步返回回来的value,构造个ValueHolder&lt;/p>
&lt;blockquote>
&lt;p>ValueHolder类在ConstructorArgumentValues类里,实现了BeanMetadataElement,属性不多,就value,type,name,source,c&lt;strong>onverted&lt;/strong>,&lt;strong>convertedValue&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>然后constructor-arg有type属性就给vh塞type,有name塞name, 塞source&lt;/p>
&lt;p>校验完index唯一之后&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> bd.&lt;span style="color:#a6e22e">getConstructorArgumentValues&lt;/span>().&lt;span style="color:#a6e22e">addIndexedArgumentValue&lt;/span>(index, valueHolder);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>构造器参数塞入bd的constructorArgumentValues,后面无index的处理方式和这里有index的主要区别就是在往这个constructorArgumentValues里面塞的位置不同.&lt;/p>
&lt;p>BeanDefinition里定义了&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> ConstructorArgumentValues &lt;span style="color:#a6e22e">getConstructorArgumentValues&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个接口,在AbstractBeanDefinition里有&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> ConstructorArgumentValues constructorArgumentValues;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>目测专门存放构造器的参数值的&lt;/p>
&lt;p>下面我们来熟悉一下ConstructorArgumentValues这个类吧..&lt;/p>
&lt;p>(这个类实在太麻烦了,写着写着2000多字,重开一文了,&lt;a class="link" href="http://heeexy.com/2017/09/14/spring_note_3_ConstructorArgumentValues/" target="_blank" rel="noopener"
>即下一篇笔记&lt;/a>)&lt;/p>
&lt;h4 id="解析子元素property">
&lt;a href="#%e8%a7%a3%e6%9e%90%e5%ad%90%e5%85%83%e7%b4%a0property" class="header-anchor">#&lt;/a>
解析子元素property
&lt;/h4>&lt;ol>
&lt;li>拿name属性并且校验&lt;/li>
&lt;li>parseState.push()&lt;/li>
&lt;li>校验name在bd.getPropertyValues()里面唯一&lt;/li>
&lt;li>parsePropertyValue 提取出property里面的子元素或者ref或者value,这个步骤和之前的&lt;strong>解析子元素constructor-arg&lt;/strong>里面的parsePropertyValue是同一个方法! 只是这里调用带上了propertyName,这里的name是不可能为空的 ,因为第一步校验了&lt;/li>
&lt;li>拿第4步的结果val和propertyName封装一个PropertyValue ,这个也是继承BeanMetadataAttributeAccessor的,&lt;/li>
&lt;li>然后和之前的解析子元素meta一模一样来解析这里面的meta子元素&lt;/li>
&lt;li>setSource&lt;/li>
&lt;li>propertyValue塞入bd&lt;/li>
&lt;li>parseState.pop()&lt;/li>
&lt;/ol>
&lt;h4 id="解析子元素qualifier">
&lt;a href="#%e8%a7%a3%e6%9e%90%e5%ad%90%e5%85%83%e7%b4%a0qualifier" class="header-anchor">#&lt;/a>
解析子元素Qualifier
&lt;/h4>&lt;p>Qualifier通常都是以注解形式使用的,用于在注入bean时明确指明Bean的名称&lt;/p>
&lt;ol>
&lt;li>
&lt;p>拿type属性并校验&lt;/p>
&lt;/li>
&lt;li>
&lt;p>parseState.push()&lt;/p>
&lt;/li>
&lt;li>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>AutowireCandidateQualifier qualifier &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> AutowireCandidateQualifier(typeName);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>setSource&lt;/p>
&lt;/li>
&lt;li>
&lt;p>拿value属性,如果有的话就塞入qualifier&lt;/p>
&lt;/li>
&lt;li>
&lt;p>遍历子节点,取其name和value(两者都必须存在),new BeanMetadataAttribute ,塞入qualifier&lt;/p>
&lt;/li>
&lt;li>
&lt;p>qualifier塞入bd&lt;/p>
&lt;/li>
&lt;li>
&lt;p>parseState.pop()&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h4 id="bd设好resource和source作为结果成功返回">
&lt;a href="#bd%e8%ae%be%e5%a5%bdresource%e5%92%8csource%e4%bd%9c%e4%b8%ba%e7%bb%93%e6%9e%9c%e6%88%90%e5%8a%9f%e8%bf%94%e5%9b%9e" class="header-anchor">#&lt;/a>
bd设好resource和source,作为结果成功返回.
&lt;/h4>&lt;h2 id="2生成beanname">
&lt;a href="#2%e7%94%9f%e6%88%90beanname" class="header-anchor">#&lt;/a>
2.生成beanName
&lt;/h2>&lt;p>如果这个bean之前没有id或name,那就为它生成个beanName&lt;/p>
&lt;p>其规则也略烦,不过感觉不重要,简单带过一下,有一种生成规则如下&lt;/p>
&lt;p>命名主要根据的属性有&lt;/p>
&lt;p>getBeanClassName&lt;/p>
&lt;p>父bean名+$child&lt;/p>
&lt;p>工厂名+$created&lt;/p>
&lt;blockquote>
&lt;p>&amp;lsquo;class&amp;rsquo; nor &amp;lsquo;parent&amp;rsquo; nor &amp;lsquo;factory-bean&amp;rsquo;&lt;/p>
&lt;/blockquote>
&lt;p>后缀再加上#&lt;/p>
&lt;p>如果是内部bean再就加bd生成的hexString&lt;/p>
&lt;p>如果不是,就再加registry里这种bean的序号 从0开始&lt;/p>
&lt;h2 id="3返回beandefinitionholder">
&lt;a href="#3%e8%bf%94%e5%9b%9ebeandefinitionholder" class="header-anchor">#&lt;/a>
3.返回BeanDefinitionHolder
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#f92672">[]&lt;/span> aliasesArray &lt;span style="color:#f92672">=&lt;/span> StringUtils.&lt;span style="color:#a6e22e">toStringArray&lt;/span>(aliases);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Spring源码笔记-1.1 获取bean流程之容器的基本实现</title><link>https://heeexy.com/posts/spring-note-1/</link><pubDate>Mon, 11 Sep 2017 20:31:00 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-1/</guid><description>&lt;blockquote>
&lt;p>以通过BeanFactory获取bean为例学习,实际项目中更多是使用ApplicationContext&lt;/p>
&lt;p>&lt;img src="http://ots7yt7am.bkt.clouddn.com/blog/springGetBean.png"
loading="lazy"
alt="img"
>&lt;/p>
&lt;p>1.读取配置文件 beanFactoryTest.xml&lt;/p>
&lt;p>2.通过文件资源获取工厂&lt;/p>
&lt;p>3.从工厂中拿bean&lt;/p>
&lt;/blockquote>
&lt;h2 id="读配置">
&lt;a href="#%e8%af%bb%e9%85%8d%e7%bd%ae" class="header-anchor">#&lt;/a>
读配置
&lt;/h2>&lt;h4 id="配置文件封装">
&lt;a href="#%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%e5%b0%81%e8%a3%85" class="header-anchor">#&lt;/a>
配置文件封装
&lt;/h4>&lt;p>ClassPathResource类 继承&amp;ndash;AbstractFileResolvingResource&lt;/p>
&lt;p>​ 继承&amp;ndash;AbstractResource&lt;/p>
&lt;p>​ 实现&amp;ndash;Resource&lt;/p>
&lt;p>​ 继承&amp;ndash;InputStreamSource接口 唯一方法: &lt;strong>getInputStream()&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Resource接口提供了一系列方法来封装底层资源&lt;/strong>,比如 exists() isReadable() getURL() getFile() getDescription() 等等&lt;/p>
&lt;h2 id="xmlbeanfactory的实例化">
&lt;a href="#xmlbeanfactory%e7%9a%84%e5%ae%9e%e4%be%8b%e5%8c%96" class="header-anchor">#&lt;/a>
XmlBeanFactory的实例化
&lt;/h2>&lt;h3 id="大概步骤">
&lt;a href="#%e5%a4%a7%e6%a6%82%e6%ad%a5%e9%aa%a4" class="header-anchor">#&lt;/a>
大概步骤
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">XmlBeanFactory&lt;/span>(Resource resource, BeanFactory parentBeanFactory) &lt;span style="color:#66d9ef">throws&lt;/span> BeansException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">super&lt;/span>(parentBeanFactory);&lt;span style="color:#75715e">//1.设置父工厂(null)...本例未使用到此&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">reader&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> XmlBeanDefinitionReader(&lt;span style="color:#66d9ef">this&lt;/span>);&lt;span style="color:#75715e">//2.实例化XmlBeanDefinitionReader, 注册到此工厂&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">reader&lt;/span>.&lt;span style="color:#a6e22e">loadBeanDefinitions&lt;/span>(resource);&lt;span style="color:#75715e">//3.重要部分,通过resource来加载beanDefinations,bean的一些定义&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>loadBeanDefinitions(resource)方法就是下面的主要要看的&lt;/p>
&lt;p>它做了几件事:&lt;/p>
&lt;ol>
&lt;li>将resource用EncodedResource包装一下,编码要用, 本例没特定的charset和encoding因此都是null&lt;/li>
&lt;li>获取当前正在加载的资源集 Set&lt;!-- raw HTML omitted --> currentResources ,如果currentResources 是null 就初始化个 new HashSet(4), 然后将我们要读的encodedResource加到这个set里面去&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>如果返回false说明正在加载这个xml了,报个错,不继续往下读了&lt;/p>
&lt;p>当读完这个资源后,在finally里面会从set里移出这个encodedResource,如果set空了,还会remove这个currentResources,&lt;/p>
&lt;p>这个set是放ThreadLocal里面的,&lt;/p>
&lt;p>private final ThreadLocal&amp;lt;Set&lt;!-- raw HTML omitted -->&amp;gt; resourcesCurrentlyBeingLoaded;&lt;/p>
&lt;p>是线程安全的,功能是防止同时&lt;strong>循环加载&lt;/strong>同一个xml文件&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>从encodedResouce里取出文件的inputStream 拿去初始化个InputSource(有enconding的话,给inputSource也设个编码,本例为null)然后 inputSource和encodedResouce里面的resouce一起拿去执行doLoadBeanDefinitions(..)方法,稍后重点讲&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> var5 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">doLoadBeanDefinitions&lt;/span>(inputSource, encodedResource.&lt;span style="color:#a6e22e">getResource&lt;/span>());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>关闭资源, 释放currentResources 等&lt;/li>
&lt;/ol>
&lt;h3 id="关键doloadbeandefinitions">
&lt;a href="#%e5%85%b3%e9%94%aedoloadbeandefinitions" class="header-anchor">#&lt;/a>
&lt;strong>关键:doLoadBeanDefinitions&lt;/strong>
&lt;/h3>&lt;h4 id="将资源转为document">
&lt;a href="#%e5%b0%86%e8%b5%84%e6%ba%90%e8%bd%ac%e4%b8%badocument" class="header-anchor">#&lt;/a>
将资源转为Document
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Document doc &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">doLoadDocument&lt;/span>(inputSource, resource);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>获取xml的验证模式 , 里面的核心是自动检测,自动检测的核心是拿着inputStream读,判断是否含有&amp;quot;DOCTYPE&amp;quot;,包含就是DTD,没有就是XSD&lt;/li>
&lt;li>拿到EntityResolver , 这个主要是用来给xml验证时找DTD文件获取路径找得快的, 不用全去spring网站拿dtd,略&lt;/li>
&lt;li>解析document, 创建DocumentBuilderFactory,通过此工厂创建DocumentBuilder,进而解析inputSource来返回document对象. 此为通过SAX(Simple API for XML)来解析的常见方法,略过&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>注意到本方法的参数中又用到resource, 明明inputSource就是从resource里拿inputStream生成出来的啊, 相当于inputSource就是儿子, doLoadDocument方法请了儿子又去请爹,烦不烦?&lt;/p>
&lt;p>其实主要是之前设计的时候, 获取XML验证模式的自动检测方法,用的是Resource接口,isOpen()方法因此不得不用&lt;/p>
&lt;p>isOpen()方法是Resource接口的方法,其实现返回false(比如AbstractResource),有的返回的是true(InputStreamResource).&lt;/p>
&lt;/blockquote>
&lt;h4 id="注册bean">
&lt;a href="#%e6%b3%a8%e5%86%8cbean" class="header-anchor">#&lt;/a>
注册bean
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>registerBeanDefinitions(doc, resource);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>先走流程&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">registerBeanDefinitions&lt;/span>(Document doc, Resource resource) &lt;span style="color:#66d9ef">throws&lt;/span> BeanDefinitionStoreException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BeanDefinitionDocumentReader documentReader &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">createBeanDefinitionDocumentReader&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> countBefore &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getRegistry&lt;/span>().&lt;span style="color:#a6e22e">getBeanDefinitionCount&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> documentReader.&lt;span style="color:#a6e22e">registerBeanDefinitions&lt;/span>(doc, &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">createReaderContext&lt;/span>(resource));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getRegistry&lt;/span>().&lt;span style="color:#a6e22e">getBeanDefinitionCount&lt;/span>() &lt;span style="color:#f92672">-&lt;/span> countBefore;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>创建阅读器documentReader&lt;/li>
&lt;li>记录加载BeanDefinition的个数,&lt;/li>
&lt;li>documentReader来加载注册doc和封装resource而生成的Context&lt;/li>
&lt;/ol>
&lt;p>继续走流程, 在reader内设置context,拿到root元素,重点在最后解析root&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">registerBeanDefinitions&lt;/span>(Document doc, XmlReaderContext readerContext) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">readerContext&lt;/span> &lt;span style="color:#f92672">=&lt;/span> readerContext;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">logger&lt;/span>.&lt;span style="color:#a6e22e">debug&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Loading bean definitions&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Element root &lt;span style="color:#f92672">=&lt;/span> doc.&lt;span style="color:#a6e22e">getDocumentElement&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">doRegisterBeanDefinitions&lt;/span>(root);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="开始核心部分-doregisterbeandefinitions">
&lt;a href="#%e5%bc%80%e5%a7%8b%e6%a0%b8%e5%bf%83%e9%83%a8%e5%88%86-doregisterbeandefinitions" class="header-anchor">#&lt;/a>
开始核心部分 doRegisterBeanDefinitions
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">protected&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">doRegisterBeanDefinitions&lt;/span>(Element root) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 基于原本的detegate,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 加上这里的context和root(XML内容)修饰一遍,作为此处要用的解析代理ParserDelegate
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 方法结束时,会把原来的解析器置换回来
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BeanDefinitionParserDelegate parent &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">delegate&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">delegate&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">createDelegate&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getReaderContext&lt;/span>(), root, parent);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果命名空间为空或者等于&amp;#34;http://www.springframework.org/schema/beans&amp;#34; 就校验里面的一些属性&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">delegate&lt;/span>.&lt;span style="color:#a6e22e">isDefaultNamespace&lt;/span>(root)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果有profile属性,就要去环境变量中去寻找&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String profileSpec &lt;span style="color:#f92672">=&lt;/span> root.&lt;span style="color:#a6e22e">getAttribute&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;profile&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (StringUtils.&lt;span style="color:#a6e22e">hasText&lt;/span>(profileSpec)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String&lt;span style="color:#f92672">[]&lt;/span> specifiedProfiles &lt;span style="color:#f92672">=&lt;/span> StringUtils.&lt;span style="color:#a6e22e">tokenizeToStringArray&lt;/span>(profileSpec, &lt;span style="color:#e6db74">&amp;#34;,; &amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果不是当前环境变量的属性值,就跳过这个xml文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getReaderContext&lt;/span>().&lt;span style="color:#a6e22e">getEnvironment&lt;/span>().&lt;span style="color:#a6e22e">acceptsProfiles&lt;/span>(specifiedProfiles)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">logger&lt;/span>.&lt;span style="color:#a6e22e">isInfoEnabled&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">logger&lt;/span>.&lt;span style="color:#a6e22e">info&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Skipped XML bean definition file due to specified profiles [&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> profileSpec &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;] not matching: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getReaderContext&lt;/span>().&lt;span style="color:#a6e22e">getResource&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//解析前的预处理 默认实现方法是空的..预留给子类进行改造的位置~~~&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">preProcessXml&lt;/span>(root);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//核心解析 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">parseBeanDefinitions&lt;/span>(root, &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">delegate&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//解析后的处理 默认实现方法是空的..预留给子类进行改造的位置~~~&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">postProcessXml&lt;/span>(root);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//将delegate换回去&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">delegate&lt;/span> &lt;span style="color:#f92672">=&lt;/span> parent;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>this.preProcessXml(root); this.postProcessXml(root);此处的预留 &lt;strong>设计模式&amp;mdash;模板方法模式&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>profile&lt;/strong>
&lt;img src="http://ots7yt7am.bkt.clouddn.com/blog/spring_profile.png"
loading="lazy"
>&lt;/p>
&lt;p>关于profile属性书中讲用途讲的很清楚,从源码中我了解到&lt;/p>
&lt;ol>
&lt;li>
&lt;p>profile可以同时指定多个属性,比如 &lt;!-- raw HTML omitted --> 只需当前环境变量里值满足其中一种就OK&lt;/p>
&lt;/li>
&lt;li>
&lt;p>多个属性可以支持多种分隔符 逗号 分号 空格 源码是&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#f92672">[]&lt;/span> specifiedProfiles &lt;span style="color:#f92672">=&lt;/span> StringUtils.&lt;span style="color:#a6e22e">tokenizeToStringArray&lt;/span>(profileSpec, &lt;span style="color:#e6db74">&amp;#34;,; &amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>可以用一个感叹号修饰属性 比如 &lt;!-- raw HTML omitted --> 表示&amp;quot;非&amp;quot; , 不可多个感叹号&lt;/p>
&lt;/li>
&lt;li>
&lt;p>读取并设置spring.profiles.active属性时还加了sychronized&lt;/p>
&lt;/li>
&lt;li>
&lt;p>spring.profiles.active属性值可以多个 ,用逗号隔开&lt;/p>
&lt;/li>
&lt;li>
&lt;p>判断过程其实是&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> currentActiveProfiles.&lt;span style="color:#a6e22e">contains&lt;/span>(profile) &lt;span style="color:#f92672">||&lt;/span> currentActiveProfiles.&lt;span style="color:#a6e22e">isEmpty&lt;/span>() &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">doGetDefaultProfiles&lt;/span>().&lt;span style="color:#a6e22e">contains&lt;/span>(profile);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>spring.profiles.active里包含这个属性, 或者spring.profiles.active为空,但是spring.profiles.default里包含这个属性&lt;/p>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>ps.这个属性看明白很有成就感,书上没解释源码, 看到这段之前先是自己埋着头进去钻源码,莫名其妙卡了很久,并不知道整段的功能是啥,继续看书看到此处,了解了这个profile 的功能,再回头结合源码,就恍然大悟:)&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>判断是不是默认命名空间&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isDefaultNamespace&lt;/span>(String namespaceUri) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">!&lt;/span>StringUtils.&lt;span style="color:#a6e22e">hasLength&lt;/span>(namespaceUri) &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#e6db74">&amp;#34;http://www.springframework.org/schema/beans&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">equals&lt;/span>(namespaceUri);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isDefaultNamespace&lt;/span>(Node node) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">isDefaultNamespace&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getNamespaceURI&lt;/span>(node));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>node获取命名空间方法 getNamespaceURI()主要在 rt.jar里有很多种不同的实现,返回字符串,就不再去深究了&lt;/p>
&lt;h5 id="再深一层-parsebeandefinitions">
&lt;a href="#%e5%86%8d%e6%b7%b1%e4%b8%80%e5%b1%82-parsebeandefinitions" class="header-anchor">#&lt;/a>
再深一层 parseBeanDefinitions
&lt;/h5>&lt;p>不贴源码了,这个方法主要是先判断这个节点是不是默认命名空间 ,不是就按自定义的方式解析,&lt;/p>
&lt;p>是的话就遍历节点,解析每个节点.&lt;/p>
&lt;p>每个节点解析之前都还会去判断一遍是否默认命名空间,&lt;/p>
&lt;p>如果不是就按自定义方式解析,如果是就才按默认方式解析&lt;/p>
&lt;p>默认标签如&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;bean&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;test&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">class=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;test.testBean&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>自定义标签如&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;tx:annotation-driven/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>好,书的第二章到此为止,第三章将继续深入默认标签的解析&lt;/p></description></item></channel></rss>