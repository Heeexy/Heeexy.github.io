<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Java on 网站标题</title><link>https://heeexy.com/tags/java/</link><description>Recent content in Java on 网站标题</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 03 Feb 2020 19:57:00 +0000</lastBuildDate><atom:link href="https://heeexy.com/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>JDBC为什么不需要Class.forName()</title><link>https://heeexy.com/posts/drivermaneger/</link><pubDate>Mon, 03 Feb 2020 19:57:00 +0000</pubDate><guid>https://heeexy.com/posts/drivermaneger/</guid><description>DriverManager 在初学JDBC时，总是记得开头就要来这么一句
Class.forName(&amp;#34;com.mysql.jdbc.Driver&amp;#34;); 然而今天学习类加载机制时偶然知道不需要这句也同样可以正常运行，测试的确如此，看了一眼源码，看似原因很简单，因为无论写不写那段Class.forName，在触发加载DriverManager时，会运行
/** * Load the initial JDBC drivers by checking the System property * jdbc.properties and then use the {@code ServiceLoader} mechanism */ static { loadInitialDrivers(); println(&amp;#34;JDBC DriverManager initialized&amp;#34;); } 都会扫描到这个Driver，注册到registeredDrivers中。
如果只要回答这个问题，可能上面的答案就已经足够了。
然而兴趣来了，总想把源码继续看下去到底扫描了啥，咋扫描的，明明
ServiceLoader&amp;lt;Driver&amp;gt; loadedDrivers = ServiceLoader.load(Driver.class); 这里是 java.sql.Driver 接口，上哪找出来的实现类？
我们就一层层的往下看吧。
ServiceLoader 主要做了两点
设置ClassLoader为当前线程的。（破坏双亲委派，让它rt.jar包中的类可以通过AppClassLoader获取到外部的类，很多讲双亲委派机制的文章已经大书特书过了） 初始化了一个懒加载的迭代器 lookupIterator = new LazyIterator(service, loader);。正是这个迭代器中最终帮我们找到了各种driver注册进去。 LazyIterator 既然是迭代器，最重要的当然是hasNext()和next()方法。
在next()方法中，已经拿到了nextName完整的&amp;quot;com.mysql.cj.jdbc.Driver&amp;quot;类名，说明还是hasNext()方法干了真正的扫描工作。
hasNext()方法的主要工作也都放在了hasNextService()中
private boolean hasNextService() { if (nextName != null) { return true; } if (configs == null) { try { //此处拼出了全名为 META-INF/services/java.</description></item><item><title>使用MyBatis时为什么Dao层不需要@Repository</title><link>https://heeexy.com/posts/%E4%BD%BF%E7%94%A8mybatis%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88dao%E5%B1%82%E4%B8%8D%E9%9C%80%E8%A6%81-repository/</link><pubDate>Tue, 03 Apr 2018 17:07:46 +0000</pubDate><guid>https://heeexy.com/posts/%E4%BD%BF%E7%94%A8mybatis%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88dao%E5%B1%82%E4%B8%8D%E9%9C%80%E8%A6%81-repository/</guid><description>问题 Service层注入Dao时， Intellij 总会以红色波浪线提示我们
@Autowired private UserDao userDao; Could not autowire. No beans of &amp;lsquo;UserDao&amp;rsquo; type found. Checks autowiring problems in a bean class.
尽管我们都知道 Dao 层的 Bean 实际上都是有的，并且可以设置关闭这恼人的提示，但是我们有没有想过为什么 Intellij 就找不到这个 Bean 呢？甚至有人有这种做法
@Repository public interface UserDao { } 来避免提示，但是这种做法正确么？
所以今天我们的疑问就是
为什么 Dao 层不需要加 @Repository 注解，源码里到底做了什么？ 加了 @Repository 注解有什么影响？ 答案 关键在于 ClassPathMapperScanner 对指定包的扫描，并且扫描过程对 Spring 原本的扫描 Bean 的步骤 &amp;ldquo;加了料” ，Spring 本身只扫实现类，但 MyBatis 的扫描器扫了接口 。并且扫完接口之后，为接口配了个 BeanDefinition ,并且这个 bd 的 BeanClass 是 MapperFactoryBean 。</description></item><item><title>极简 Spring 框架 -- 浅析循环依赖</title><link>https://heeexy.com/posts/spring-note-18-ioc/</link><pubDate>Sun, 28 Jan 2018 13:37:32 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-18-ioc/</guid><description>从网上看到一篇博文 徒手撸框架&amp;ndash;实现IoC ，写得很棒，作者抛开了 Spring 源码中复杂的校验，拓展等功能，实现了一个极简的 IoC 框架，让 Spring 源码初学者可以清楚的看到 IOC 的实现流程。
本文就借其框架，略加改造，再次介绍一下 Spring 是如何处理循环依赖的。
了解本项目核心代码需要先参考原作者的博文 徒手撸框架&amp;ndash;实现IoC 。
循环依赖 其实很好理解，A 类依赖 B，B 又依赖 A。
说具体点就是 ，我们要 getBean(&amp;ldquo;a&amp;rdquo;)， A 在实例化时需要为类型为 B 的成员变量赋值，因此去 getBean(&amp;ldquo;b&amp;rdquo;)，而 getBean(&amp;ldquo;b&amp;rdquo;) 的时候又需要为其类型为A 的成员变量赋值，此时又会回过头去实例化 A ，导致无限循环。
用代码展示就是
public class A { @AutoWired private B b; } public class B { @AutoWired private A a; } 代码改造 最主要的代码改造在于 BeanFactoryImpl 内， 添加了成员变量
private final Map&amp;lt;String, Object&amp;gt; earlySingletonObjects = new HashMap&amp;lt;String, Object&amp;gt;(16); 用于缓存正在创建中的，提前暴露出来的单例 bean。</description></item><item><title>Spring 源码笔记-2.8 根据类型寻找 bean--找出所有匹配类型的 beanName</title><link>https://heeexy.com/posts/spring-note-16-beannamesfortypeincludingancestors/</link><pubDate>Wed, 24 Jan 2018 09:48:02 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-16-beannamesfortypeincludingancestors/</guid><description>前文
源码解析 入参说明
includeNonSingletons：是否包括非单例的 bean，比如 prototype scope allowEagerInit：为了这个检查（找出所有匹配类型的 beanName），是否初始化 lazy-init 单例和由 FactoryBeans 创建的对象。此处我们传入的值为 true。 public static String[] beanNamesForTypeIncludingAncestors( ListableBeanFactory lbf, Class&amp;lt;?&amp;gt; type, boolean includeNonSingletons, boolean allowEagerInit) { Assert.notNull(lbf, &amp;#34;ListableBeanFactory must not be null&amp;#34;); //方法主干还是在这行 getBeanNamesForType String[] result = lbf.getBeanNamesForType(type, includeNonSingletons, allowEagerInit); //下面的内容就是从 bf 的 parent 中找， if (lbf instanceof HierarchicalBeanFactory) { HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf; if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) { //此处以 parent 再来调此方法，合并结果。 String[] parentResult = beanNamesForTypeIncludingAncestors( (ListableBeanFactory) hbf.</description></item><item><title>Spring 源码笔记-2.7 根据类型寻找 bean</title><link>https://heeexy.com/posts/spring-note-15-findautowirecandidates/</link><pubDate>Tue, 23 Jan 2018 09:00:22 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-15-findautowirecandidates/</guid><description>前言 Spring 装配 bean 有两种类型：autowireByName 和 autowireByType 。
autowireByName 通过名称查找很直接，就是我们一直在学的 getBean() 。
而 autowireByType 根据类型查找相比起来就要复杂一些了，《 Spring 源码深度解析 》 中有介绍过的部分我就不再重复贴了，但是书中遗漏了一处重要的部分&amp;mdash;&amp;mdash; findAutowireCandidates 查找所有合适的 bean，还有一处新版本 Spring 中升级的部分&amp;mdash;&amp;mdash;如果只需要一个但是找出多个 bean 该怎么处理，今天我们先来学习第一部分。
正文 本函数要做什么 @RestController @RequestMapping(&amp;#34;/article&amp;#34;) public class ArticleController { @Autowired private ArticleService articleService; } 在初始化 ArticleController 的过程中，我们要为其装配 ArticleService 。
忽略掉外面代码一层一层的包裹之后，我们走到 DefaultListableBeanFactory.findAutowireCandidates 这个函数中，要寻找合适的候选 bean 。由于可能会找到多个，因此返回结果是候选 bean 的名称和其对应实例构成的 Map 。
源码解析 //三个参数的含义依次是 // 正在解析的 beanName, 本例中即 &amp;#34;articleController&amp;#34; // 需要装配的 bean 类型, 本例中即 ArticleService.class // 对当前依赖关系的解析类，记录了 ArticleController 和 ArticleService 的依赖关系 protected Map&amp;lt;String, Object&amp;gt; findAutowireCandidates(String beanName, Class&amp;lt;?</description></item><item><title>Spring 源码笔记-2.6 BeanWrapper 对比 MyBatis</title><link>https://heeexy.com/posts/spring-note-14-beanwrapper/</link><pubDate>Fri, 19 Jan 2018 15:21:58 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-14-beanwrapper/</guid><description>Spring vs MyBatis Spring 和 MyBatis 中都有 BeanWrapper , Spring 中为接口， 实现类为 BeanWrapperImpl , 为了方便后面区分，本文用 SB 指代 Spring 的 BeanWrapperImpl ，用 MB 指代 MyBatis 中的 BeanWrapper。
功能 BeanWrapper 都属于各自框架的反射工具箱的重要组成部分。都是创建实例并且为其属性赋值的。以 SB 为例，下面的代码应该很容易看明白它的功能。
BeanWrapper company = BeanWrapperImpl(new Company()); // setting the company name.. company.setPropertyValue(&amp;#34;name&amp;#34;, &amp;#34;Some Company Inc.&amp;#34;); // ... can also be done like this: PropertyValue value = new PropertyValue(&amp;#34;name&amp;#34;, &amp;#34;Some Company Inc.&amp;#34;); company.setPropertyValue(value); // ok, let&amp;#39;s create the director and tie it to the company: BeanWrapper jim = BeanWrapperImpl(new Employee()); jim.</description></item><item><title>Spring源码笔记-2.5 createBean</title><link>https://heeexy.com/posts/spring-note-13-createbean/</link><pubDate>Thu, 18 Jan 2018 14:22:06 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-13-createbean/</guid><description>此方法交给了 AbstractBeanFactory 的子类 AbstractAutowireCapableBeanFactory 去实现。
并且不管这个bean是单例还是 prototype 还是其它 scope ,最终都是会走到此处，只是前后的一些验证、处理有区别。比如单例的就要先去缓存中获取，prototype 就不需要。
源码阅读到这里，我们已经习惯了一层一层剥。createBean 依然还是没有直接地把 bean 创建出来（当然我所期望的看到创建 bean 就是看到它的反射源码为止）。
createBean 的大致步骤为:
根据 RootBeanDefinition 来获取要创建 bean 的 class 。这 class 还有可能为 null。 prepareMethodOverrides 。准备 override 方法，对 override 属性进行验证。 给后处理器一个机会来返回代理，替代真正的 bean. doCreateBean 创建真正的 bean 实例。 prepareMethodOverrides 首先去温习一遍 lookup-method 和 replace-method 吧。博文
其实就是通过配置把原本 bean 中的某个方法给替代掉。
此处我们先只是确认一遍指定的替代方法存在于要生成的 bean 中。
顺带看一看这个方法有没有重载overload)，做个标记。
resolveBeforeInstantiation 经过一波预处理器InstantiationAwareBeanPostProcessor ，如果生产出了 bean，再经过一波后处理器。
一旦生产出 bean，则立即将此 bean 返回。
此处就是留下了一个拓展点，经过此方法之后，bean可能已经不是我们认为的 bean 了，而可能已经变成了一个经过处理的代理 bean 。
循环依赖 构造器循环依赖 如果是 prototype，无法解决，只能抛错。</description></item><item><title>MyBatis 的日志设计--适配器模式 &amp; 工厂模式</title><link>https://heeexy.com/posts/mybatis%E6%97%A5%E5%BF%97--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 14 Dec 2017 14:45:47 +0000</pubDate><guid>https://heeexy.com/posts/mybatis%E6%97%A5%E5%BF%97--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid><description>​ MyBatis 想要打印日志，时不时想要来句 log.debug() 、log.error() ，需要个打印机 ，可是自己又不想去实现（而且跟着整个项目用同样的打印系统才是王道啊），需要去用别人家的打印机，要用别人家的产品啊，那问题可就来了。
问题 1 ​ 市面上各家的打印机 slf4j、java.util.logging、log4j 甚至 System.out 都是各种不同的用法，这使用起来就太麻烦了。
思路 ​ 不管市面上打印机有多少型号，我家 MyBatis 包里的类只用自家的统一接口，我家的类只管 log.debug()、log.error()&amp;hellip;
​ 定义好了接口，就需要实现类 impl 来实现这些 debug()、error() 方法了 , 咱假装是自己来实现，其实去调用真正打印机 slf4、log4j 的方法，这样就把别人家的打印机和咱自家的接口关联起来啦。
​ 这就是适配器模式。
​ 我家的每个实现类其实就是一个适配器，每个适配器去适配一种打印机。比如 slf4jLoggerImpl 就完成了对 slf4j 打印机的适配，slf4jLoggerImpl .debug() 调用了slf4j.Logger.debug()。
​ 这样市面上每多一种打印机，比如想用 log4j2 了，我就只需要加一种适配器 log4j2LoggerImpl 去适配它就可以了。
代码 ​ 定义接口
public interface Log { boolean isDebugEnabled(); void debug(String s); ... } ​ 在实现类里完成适配，比如适配 slf4j 的 Slf4jLoggerImpl
import org.apache.ibatis.logging.Log; import org.slf4j.Logger; class Slf4jLoggerImpl implements Log { private final Logger log; //注意这个地方，入参为 org.</description></item><item><title>前后端分离实践小结</title><link>https://heeexy.com/posts/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%AE%9E%E8%B7%B5/</link><pubDate>Sun, 29 Oct 2017 00:27:05 +0000</pubDate><guid>https://heeexy.com/posts/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%AE%9E%E8%B7%B5/</guid><description>背景 ​ 公司项目转型,要开新的运营管理平台,我提议借此开新项目的机会,进行前后端分离,由我负责带领小组新技术学习/分享,探坑填坑.
分离原因 最关键一点,受不了jsp/freemarker里一塌糊涂的代码,分离之后,代码按规范写,简洁,好管理 原本我们后端就一直在给Android/iOS提供接口,本次分离,可以方便以后H5端的项目重构,实现Android+iOS+H5的统一,一套接口可以供三端同时使用,大量节省工作量,也可以更好地保证公司产品质量的统一性. 方便后端专心处理数据,前端实现页面效果.而不是前端仅仅画页面写css,后端还需要复制粘贴过来,套数据,修改已有页面时,前端更是不方便插手. 技术选型 ​ 组员后端技术都是SSM,前端都只是略接触过AngularJS/Vue.
​ 我之前接触了一下Spring Boot,感觉配置很清爽,搭框架轻松,业务写起来快,可以让组员无缝切过来,无需费时学习,因此后端框架选定Spring Boot.而登录控制与权限管理一直是公司以前几个项目的弱项,因此本次决定引入shiro,而组员无一对shiro熟悉的,研究shiro的任务自然由我承担.
​ 前端框架是本次前后端分离的重点,由于我们组无人熟悉前端的新框架,所以这次势必每个人都需要学习许多新的前端知识.我拿公司的H5项目的几个页面进行过搭建vue框架重构练手,认为vue文档清晰,资料丰富,相关开源方案够多,我们这次可以放心学习,使用.(当然最主要的还是因为坑全都得由我来填,得挑个熟悉的)
目前进展 ​ 后端:Spring Boot框架搭建完成,shiro可以进行权限管理,自定义拦截器,常用工具类完成,对常用的增删改查,返回结果,异常处理都可以快速搞定.
​ 前端:数据交互封装完毕,路由熟悉,前端权限管理初步熟悉,选用饿了么开源的Element框架,常用的增删改查的页面元素及工具方法都已让大家掌握.
​ 本周一开始教组员使用Intellij IDEA,教前端快速铺页面的方法,介绍前后端我封装的各种小轮子.经过一周时间,全部都已熟悉这套新的前后端框架,每个人都可以独立快速地推出常用页面.
接口端小技巧 ​ 因为后端全部返回统一json格式的接口,所以我设计了一些小的工具方法,方便快速推出新接口,节省重复代码.
使用JSONObject而不是实体类
​ 因为后端业务不算复杂,所以舍弃了实体类的语义性,转而使用阿里的fastjson的JSONObject接收MyBatis返回的结果.比如一个简单的查询只需要
&amp;lt;select id=&amp;#34;getSimple&amp;#34; resultType=&amp;#34;com.alibaba.fastjson.JSONObject&amp;#34;&amp;gt; SELECT s.order_id shopOrderId, s.operation operation, date_format(s.create_time, &amp;#39;%Y.%m.%d %H:%i:%s&amp;#39;) createTime FROM shop_order_log s WHERE s.user_delete_status = &amp;#34;1&amp;#34; &amp;lt;/select&amp;gt; 就可以将三个字段shopOrderId,operation,createTime放入json内,字段名称更加灵活,也免去了大量的建实体类,写resultMap的代码.
​ 更好的一点是,不使用实体类,可以在返回结果中避免掉很多空的需不要的字段.
​ 还有,因为所有的接口层都返回JSONObject,所以编写工具方法,快速返回成功/失败结果也很简单,我写了多个工具方法,包括入参转json,入参非空校验,返回成功/失败结果,分页,这里就不一一贴出代码了.
自定义Exception
public class CommonJsonException extends RuntimeException { private JSONObject resultJson; /** * 调用时可以在任何代码处直接throws这个Exception, * 都会统一被拦截,并封装好json返回给前台 * * @param errorEnum 以错误的ErrorEnum做参数 */ public CommonJsonException(ErrorEnum errorEnum) { JSONObject jsonObject = new JSONObject(); CommonUtil.</description></item><item><title>搭建springboot-shiro-vue框架时遇到的坑</title><link>https://heeexy.com/posts/build-springboot-shiro/</link><pubDate>Sun, 22 Oct 2017 11:19:33 +0000</pubDate><guid>https://heeexy.com/posts/build-springboot-shiro/</guid><description>​ 最近在做前后端分离的新框架,选用了后端springboot+shiro,前端vue+elementUI,第一次搭SSM之外的非demo项目,尤其shiro更是之前从未接触,折腾了很多天,遇到很多问题,大部分能百度出来,剩下的非常费时的问题且称之为坑吧.
跨域 ​ 一大部分问题就是跨域造成的,本身vue-cli搭建的项目可以用
// 1. axios的baseURL设置为/api // 2. 如下设置 proxyTable: { &amp;#39;/api&amp;#39;: { target: &amp;#39;http://127.0.0.1:8080/&amp;#39;, changeOrigin: true, pathRewrite: { &amp;#39;^/api&amp;#39;: &amp;#39;/&amp;#39; } } }, 来解决开发环境跨域的问题,生产环境反正可以打包静态文件到springboot项目中直接跑.
而我还是脑抽得选择了强行跨域,假装自己要把静态文件单独放个服务器跑&amp;hellip;为此遇到很多问题,折腾好几天.
因此强力推荐上面的方案,简单快捷地解决跨域!
如果生产环境真的需要跨域的话,再按下面方法设置
大部分跨域的配置都能百度搜出来:
axios要 withCredentials: true
用session而不用啥特殊的token之类的话,就不用 config.headers['X-Token'] = getToken() ,这句是vueAdmin-template 中带的,需要删掉.
后端需要配置允许跨域
@Configuration public class CorsConfig { private CorsConfiguration buildConfig() { CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOrigin(&amp;#34;*&amp;#34;); // 1 设置访问源地址 corsConfiguration.addAllowedHeader(&amp;#34;*&amp;#34;); // 2 设置访问源请求头 corsConfiguration.addAllowedMethod(&amp;#34;*&amp;#34;); // 3 设置访问源请求方法 corsConfiguration.setAllowCredentials(true); return corsConfiguration; } @Bean public CorsFilter corsFilter() { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.</description></item><item><title>Spring源码笔记-2.4 获取单例</title><link>https://heeexy.com/posts/spring-note-12-%E8%8E%B7%E5%8F%96%E5%8D%95%E4%BE%8B/</link><pubDate>Fri, 29 Sep 2017 22:49:00 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-12-%E8%8E%B7%E5%8F%96%E5%8D%95%E4%BE%8B/</guid><description>获取单例bean getSingleton 明明之前一篇已经讲过了获取单例,为什么这里又是获取单例bean呢?
两天不看书,果断又忘了.前面学的是从缓存中获取,这里是真正的获取.
DefaultSingletonBeanRegistry 中重载此方法,第二参数为ObjectFactory
public Object getSingleton(String beanName, ObjectFactory&amp;lt;?&amp;gt; singletonFactory) { Assert.notNull(beanName, &amp;#34;&amp;#39;beanName&amp;#39; must not be null&amp;#34;); //这里再次看到了这个singletonObjects,上篇文章介绍过,是维护了单例对象 //书中说法是:用于保存BeanName和创建bean实例之间的关系 Map var3 = this.singletonObjects; synchronized(this.singletonObjects) { Object singletonObject = this.singletonObjects.get(beanName); //首先获取一遍,如果不存在,才去创建 if (singletonObject == null) { //工厂如果正在销毁,这时候获取bean就会报错 if (this.singletonsCurrentlyInDestruction) { throw new BeanCreationNotAllowedException(beanName, &amp;#34;Singleton bean creation not allowed while the singletons of this factory are in destruction (Do not request a bean from a BeanFactory in a destroy method implementation!</description></item><item><title>Spring源码笔记-2.3 缓存中获取单例bean及获取对象</title><link>https://heeexy.com/posts/spring-note-11-getsingleton/</link><pubDate>Tue, 26 Sep 2017 23:28:00 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-11-getsingleton/</guid><description>缓存中获取单例bean getSingleton DefaultSingletonBeanRegistry 中实现此方法
//这个map维护了单例对象 private final Map&amp;lt;String, Object&amp;gt; singletonObjects = new ConcurrentHashMap(256); //当前正在创建中的单例对象 private final Set&amp;lt;String&amp;gt; singletonsCurrentlyInCreation = Collections.newSetFromMap(new ConcurrentHashMap(16)); //早期单例对象 private final Map&amp;lt;String, Object&amp;gt; earlySingletonObjects = new HashMap(16); //单例工厂? private final Map&amp;lt;String, ObjectFactory&amp;lt;?&amp;gt;&amp;gt; singletonFactories = new HashMap(16); protected Object getSingleton(String beanName, boolean allowEarlyReference) { Object singletonObject = this.singletonObjects.get(beanName); //如果根据这个beanName没取到对象,但发现这个对象还在创建中..... if (singletonObject == null &amp;amp;&amp;amp; this.isSingletonCurrentlyInCreation(beanName)) { Map var4 = this.singletonObjects; synchronized(this.singletonObjects) { singletonObject = this.earlySingletonObjects.get(beanName); //如果早期单例对象中没有此bean,并且允许早期依赖 if (singletonObject == null &amp;amp;&amp;amp; allowEarlyReference) { //当某些方法需要提前初始化的时候则会调用 addSingletonFactory方法将对应的ObjectFactory初始化策略存储在singletonFactories ObjectFactory&amp;lt;?</description></item><item><title>Spring源码笔记-2.2 FactoryBean</title><link>https://heeexy.com/posts/spring-note-10-factorybean/</link><pubDate>Tue, 26 Sep 2017 14:47:00 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-10-factorybean/</guid><description>package org.springframework.beans.factory; public interface FactoryBean&amp;lt;T&amp;gt; { //返回由FactoryBean创建的bean实例,如果isSingleton()返回true,则该实例会放到Spring容器中单实例缓存池中 T getObject() throws Exception; //返回FactoryBean创建的bean类型 Class&amp;lt;?&amp;gt; getObjectType(); //返回bean实例的作用域是singleton还是prototype boolean isSingleton(); } ​ 当配置文件的class属性配置的实现类是FactoryBean 时,通过getBean() 方法返回的不是FactoryBean 本身,而是FactoryBean.getObject() 方法所返回的对象.
​ 相当于FactoryBean.getObject() 代理了getBean() 方法.
​ 例如,如果使用传统方式配置Car的bean,Car的每个属性对应一个 元素标签
public class Car { private int maxSpeed; private String brand; private double price; //get/set } ​ 如果使用FactoryBean的方式就会灵活一些,下面通过逗号分隔符的方式一次性地为Car的所有属性指定配置值:
public class CarFactoryBean implements FactoryBean&amp;lt;Car&amp;gt; { private String carInfo; @Override public Car getObject() throws Exception { Car car = new Car(); String[] infos = carInfo.</description></item><item><title>Spring源码笔记-2.1 bean的加载初探</title><link>https://heeexy.com/posts/spring-note-9-beanload/</link><pubDate>Tue, 26 Sep 2017 11:16:00 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-9-beanload/</guid><description>本文要看啥? ​ 前面已经了解了bean从配置文件到解析成BDHolder到注册的流程,我们已经将bean的信息封装好,塞入了map中,这个map可能在不同的实现里面,前面重点学的就是DefaultListableBeanFactory里的beanDefinitionMap.
​ 我们现在要探索bean的加载,围绕最初的示例代码:
MyTestBean bean =(MyTestBean)bf.getBean(&amp;#34;myTestBean&amp;#34;); ​ BeanFactory是个接口,其下实现关系很复杂, getBean方法的实现主要是在AbstractBeanFactory 这一层.
​ 本文就是先来快速体验一下加载bean的大体流程
进入代码吧 protected &amp;lt;T&amp;gt; T doGetBean(String name, Class&amp;lt;T&amp;gt; requiredType, final Object[] args, boolean typeCheckOnly) throws BeansException { //转换beanName final String beanName = this.transformedBeanName(name); //根据beanName找其单例 Object sharedInstance = this.getSingleton(beanName); Object bean; if (sharedInstance != null &amp;amp;&amp;amp; args == null) { if (this.logger.isDebugEnabled()) { if (this.isSingletonCurrentlyInCreation(beanName)) { this.logger.debug(&amp;#34;Returning eagerly cached instance of singleton bean &amp;#39;&amp;#34; + beanName + &amp;#34;&amp;#39; that is not fully initialized yet - a consequence of a circular reference&amp;#34;); } else { this.</description></item><item><title>Spring源码笔记-1.6 自定义标签的解析</title><link>https://heeexy.com/posts/spring-note-8-custom-element/</link><pubDate>Tue, 19 Sep 2017 19:33:23 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-8-custom-element/</guid><description>自定义标签的使用 主要内容都在书上,p80
关键的部分为
创建XSD文件 创建类 继承AbstractSingleBeanDefinitionParser , 其继承关系最主要是实现了BeanDefinitionParser 接口,顾名思义,可以用来解析bean. 创建Handler文件, 继承自 NamespaceHandlerSupport ,目的是将上面的组件注册到Spring容器内 编写Spring.handlers 和 Spring.schemas文件. 这样,自定义的配置就结束了.
Spring加载自定义bean的流程主要就是遇到自定义标签后就去Spring.handlers和Spring.schemas中取找对应的handler 和 XSD .从而可以拿到parser
而代码里的主要步骤为
拿到标签对应的命名空间 根据命名空间找到对应的handler 调用handler的parse方法 获取标签的命名空间 调用org.w3c.dom.Node中的getNamespaceURI()
提取自定义标签处理器 NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); 这个resolve方法是接口,由DefaultNamespaceHandlerResolver 默认命名空间解析器来实现,其实现里面的第一步便是
Map&amp;lt;String, Object&amp;gt; handlerMappings = this.getHandlerMappings(); 原来handlerMappings 是个map,想必是在注册时肯定把解析器添加到这个map里面来,用namespaceUri做key,这样找的时候就很好找了.
取出结果如果是NamespaceHandler 便可以返回,往下读我们发现,之所以这么爽取出来就是handler,是因为已经做过这个解析,把找出的handler塞入了map,相当于是缓存了.
否则就是类名 className, 我们需要把它转为handler
//使用反射,将类路径转化为类 Class&amp;lt;?&amp;gt; handlerClass = ClassUtils.forName(className, this.classLoader); if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) { throw new FatalBeanException(&amp;#34;Class [&amp;#34; + className + &amp;#34;] for namespace [&amp;#34; + namespaceUri + &amp;#34;] does not implement the [&amp;#34; + NamespaceHandler.</description></item><item><title>Spring源码笔记-1.5 其它标签解析</title><link>https://heeexy.com/posts/spring-note-7-other-default-elements/</link><pubDate>Tue, 19 Sep 2017 19:33:04 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-7-other-default-elements/</guid><description>本文要看啥 之前我们看解析默认标签,从最核心的bean开始看的
private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) { if (delegate.nodeNameEquals(ele, &amp;#34;import&amp;#34;)) { this.importBeanDefinitionResource(ele); } else if (delegate.nodeNameEquals(ele, &amp;#34;alias&amp;#34;)) { this.processAliasRegistration(ele); } else if (delegate.nodeNameEquals(ele, &amp;#34;bean&amp;#34;)) { this.processBeanDefinition(ele, delegate); } else if (delegate.nodeNameEquals(ele, &amp;#34;beans&amp;#34;)) { this.doRegisterBeanDefinitions(ele); } } 现在主要就剩下alias和import啦, beans其实就是迭代解析.
alias标签的解析 为bean定义别名,除了之前我们接触过的
&amp;lt;bean id=&amp;#34;testBean&amp;#34; name=&amp;#34;aliasTestBean&amp;#34; class=&amp;#34;com.test&amp;#34;/&amp;gt; 还可以直接用alias标签
&amp;lt;alias name=&amp;#34;testBean&amp;#34; alias=&amp;#34;aliasTestBean&amp;#34;/&amp;gt; 解析步骤即使不看源码也知道很简单,因为之前我们已经深入研究过了SimpleAliasRegistry
校验 name alias 两个属性不能为空 this.getReaderContext().getRegistry().registerAlias(name, alias); 这个getRegistry() 然后registerAlias() 果然就是我们之前学过的SimpleAliasRegistry 里面的注册别名的方法.
impory标签的解析 import标签和bean标签一样是我们最常见的标签,对于分模块管理配置文件很关键.
解析步骤 取出并校验resource 属性作为地址location
将地址中的系统属性 如 &amp;ldquo;${user.dir}&amp;rdquo;
判断location是绝对路径还是相对路径</description></item><item><title>test_volatile_object</title><link>https://heeexy.com/posts/test-volatile-object/</link><pubDate>Mon, 18 Sep 2017 22:28:29 +0000</pubDate><guid>https://heeexy.com/posts/test-volatile-object/</guid><description>本文要看啥 先不细谈volatile的基本原理,在读(写)这篇文章时,都是假设我们已经粗略了解了一点volatile的原理和作用的,主要就是 &amp;ldquo;读写都走主内存,保证任意线程对这个变量的可见性&amp;rdquo;
在查看spring源码的时候,注意到spring在处理并发的操作List时, 虽然对list使用了volatile, 然而向list里面添加元素时,用的还是新建一个list,复制全部旧值,增加新元素,然后将旧的list地址指向新的list.
List&amp;lt;String&amp;gt; updatedDefinitions = new ArrayList(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); this.beanDefinitionNames = updatedDefinitions; 这么麻烦的操作,第一反应就是,volatile修饰的list, 直接添加元素依然不安全么?
去网上搜了一下相关问题, 参考博文地址 ,发现不止list, 对象也是一样的.
本文就是要来用代码直观地看看volatile 到底有什么效果,怎么用才有效果.
开始代码吧 线程共享对象里的boolean 注意代码要以**-server模式**运行，强制虚拟机开启优化
public class VolatileObjectTest implements Runnable { // 加上volatile 就可以正常结束While循环了 private ObjectA a; public VolatileObjectTest(ObjectA a) { this.a = a; } public void stop() { a.setFlag(false); } @Override public void run() { long i = 0; while (a.isFlag()) { i++; /** 注意这里的sysout,如果有调用的话,即使没有volatile,子线程也经常能拿到a.flag, 结合后面的测试,发现sysout 或者 sysout(a.</description></item><item><title>SimpleAliasRegistry</title><link>https://heeexy.com/posts/spring-note-5-simplealiasregistry/</link><pubDate>Fri, 15 Sep 2017 21:27:09 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-5-simplealiasregistry/</guid><description>功能:注册/存放别名
唯一成员变量为
private final Map&amp;lt;String, String&amp;gt; aliasMap = new ConcurrentHashMap(16); 这Map&amp;lt;String,String&amp;gt; 其实key是alias,value是name. 刚开始没注意可能搞反了呢
注册别名registerAlias() 举例来说 我们要注册的beanName为myTestBean , 别名为mtb
校验name和alias都不为空
如果name和alias一样,那map里删了这条name,结束
依据alias 即 mtb去map里面取已注册的name,如果真的有已注册过的话:
registeredName 和name相等的话,那就不用管,结束. 如果他俩不相等,这个工厂又不允许重写alias,那就抛异常! (allowAliasOverriding() 这个方法在SimpleAliasRegistry的子类里面有的会被重写. 如果前面都通过了,this.checkForAliasCircle(name, alias); 再次循环检查一遍,判断是否hasAlias(),如果是true的话,就报错,不是的话,走第5步. 具体hasAlias()流程如下:
循环找出registeredName 为myTestBean的那组键值对 (这里和上面的遍历不一样哦,这里是根据直接找重复的beanName的,上面是找重复的alias的 如果这个键值对的key即alias也是等于mtb的话,报错 (但是实际我们这第三步也查过这种情况) 如果这个myTestBean找出来的alias是&amp;quot;myTB&amp;quot;,那就还要走一遍hasAlias(&amp;quot;myTB&amp;quot;,&amp;quot;mtb&amp;quot;) ,换句话说,就是要看一看是不是有哪个bean名字叫myTB,别名叫mtb的,如果真的有,就返回true 第四步的hasAlias() 这种判断是啥意思呢?
想注册 mtb&amp;ndash;myTestBean (别名&amp;ndash;本名)
如果已存在 mtb&amp;ndash;myTestBean ,那么返回true
如果已存在 myTB&amp;ndash;myTestBean,
​ 且存在 mtb&amp;ndash;myTB ,
那就构成了 mtb&amp;ndash;myTB&amp;ndash;myTestBean 也返回true
如果已存在 myTB&amp;ndash;myTestBean,
​ 且存在 mta&amp;ndash;myTB
​ 且存在 mtb&amp;ndash;mta ,
那就构成了 mtb&amp;ndash;mta&amp;ndash;myTB&amp;ndash;myTestBean 还是返回true
.
这下看明白了吧,</description></item><item><title>Spring源码笔记-1.4 获取bean流程之注册BeanDefinition</title><link>https://heeexy.com/posts/spring-note-6-registerbeandefinition/</link><pubDate>Fri, 15 Sep 2017 21:26:00 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-6-registerbeandefinition/</guid><description>本文要看啥 这个bean总算是解析完了,也装饰完了,等于是说信息我们都提取好了,现在该做的就是去注册啦.
BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, this.getReaderContext().getRegistry()); 就是这个方法了
开始进入方法吧 public static void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException { String beanName = definitionHolder.getBeanName(); registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition()); String[] aliases = definitionHolder.getAliases(); if (aliases != null) { String[] var4 = aliases; int var5 = aliases.length; for(int var6 = 0; var6 &amp;lt; var5; ++var6) { String alias = var4[var6]; registry.registerAlias(beanName, alias); } } } 拿到beanName
用beanName和bd去registry里注册.
registry是个接口,具体的实现在4.3.7版本中看到两种,一种是SimpleBeanDefinitionRegistry里,和它名字一样非常简单,就是塞进map, 另外一种就复杂了,稍后我们再来看
用beanName和alias去registry里注册
注册aliases也是接口 ,BeanDefinitionRegistry还是继承自AliasRegistry的, 4.3.7只看到SimpleAliasRegistry一种实现
注册alias就简单多了, SimpleAliasRegistry里有
private final Map&amp;lt;String, String&amp;gt; aliasMap = new ConcurrentHashMap(16); 稍后我再另开一文把SimpleAliasRegistry来读一遍</description></item><item><title>Spring源码笔记-1.3 获取bean流程之解析bean标签中的自定义标签元素</title><link>https://heeexy.com/posts/spring-note-4-decoratebeandefinitionifrequired/</link><pubDate>Fri, 15 Sep 2017 21:24:00 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-4-decoratebeandefinitionifrequired/</guid><description>本文要看啥 protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) { BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) { bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try { BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, this.getReaderContext().getRegistry()); } catch (BeanDefinitionStoreException var5) { this.getReaderContext().error(&amp;#34;Failed to register bean definition with name &amp;#39;&amp;#34; + bdHolder.getBeanName() + &amp;#34;&amp;#39;&amp;#34;, ele, var5); } this.getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); } } 前面的笔记中,我们已经走完了这个方法中的第一步,感觉第一步就走了很远,眼瞅要迷路了,但无论如何,总归是拿到了我们的bdHolder, 里面已经存放了Bean标签里面的默认的元素.
如果bdHolder不为空的话,我们可以继续往下走啦.
今天来研究下这段代码
bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); 看方法名字就大概知道,这里要做的事情就是 如果有需要的话,装饰我们刚拿到的bdHolder.
那么何为需要呢?下面这样的场景便是了
&amp;lt;bean id=&amp;#34;test&amp;#34; class=&amp;#34;test.myClass&amp;#34;&amp;gt; &amp;lt;mybean:user username=&amp;#34;aaa&amp;#34;/&amp;gt; &amp;lt;/bean&amp;gt; 这里的自定义标签和
&amp;lt;mvc:resources mapping=&amp;#34;/img/**&amp;#34; location=&amp;#34;img/&amp;#34;/&amp;gt; &amp;lt;aop:config/&amp;gt; &amp;lt;tx:advice id=&amp;#34;transactionAdvice&amp;#34; transaction-manager=&amp;#34;transactionManager&amp;#34;/&amp;gt; 并不同,这里的是在bean内的, 而mvc那种标签是在beans里面,与bean同级的</description></item><item><title>ConstructorArgumentValues 构造器参数值保存器</title><link>https://heeexy.com/posts/spring-note-3-constructorargumentvalues/</link><pubDate>Thu, 14 Sep 2017 21:10:33 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-3-constructorargumentvalues/</guid><description>private final Map&amp;lt;Integer, ConstructorArgumentValues.ValueHolder&amp;gt; indexedArgumentValues = new LinkedHashMap(0); private final List&amp;lt;ConstructorArgumentValues.ValueHolder&amp;gt; genericArgumentValues = new LinkedList(); 这个保存器的核心就在他的LinkedHashMap和LinkedList
疑问: 这里为什么选用linked来储存呢?
答:
添加有index的关键代码如下
private void addOrMergeIndexedArgumentValue(Integer key, ConstructorArgumentValues.ValueHolder newValue) { //拿当前这个位置的值 ConstructorArgumentValues.ValueHolder currentValue = (ConstructorArgumentValues.ValueHolder)this.indexedArgumentValues.get(key); //如果当前位置有值,并且新值是接受合并的话,那合并一波之后作为新值 //如果不接受合并的话,那扔了之前的value不管了,只用新来的value if (currentValue != null &amp;amp;&amp;amp; newValue.getValue() instanceof Mergeable) { Mergeable mergeable = (Mergeable)newValue.getValue(); if (mergeable.isMergeEnabled()) { newValue.setValue(mergeable.merge(currentValue.getValue())); } } //将新值放入LinkedHashMap this.indexedArgumentValues.put(key, newValue); } 疑问:在获取vh之前我们不就验证过index不能重复么?为什么这里还有可能搞一波合并?是有其它地方也调用这个方法,那里可以合并?
答: 注意到这个类里有个方法,addArgumentValues(ConstructorArgumentValues other),貌似就是专门和其它CAV搞合并的,用CAV做构造参数的那个构造器调用了此方法,这里会有可能需要合并
添加没有index的参数
public void addGenericArgumentValue(ConstructorArgumentValues.ValueHolder newValue) { //校验不为空 Assert.notNull(newValue, &amp;#34;ValueHolder must not be null&amp;#34;); //如果list内已经含有此value则跳过 if (!</description></item><item><title>Spring源码笔记-1.2 获取bean流程之bean标签的解析及注册</title><link>https://heeexy.com/posts/spring-note-2/</link><pubDate>Tue, 12 Sep 2017 21:41:09 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-2/</guid><description>1.解析BeanDefinition BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); 作用就是将element封装进bdHolder里面.
其源码很长,不贴了,但功能流程还很清晰
处理id,name,aliases. 关键是需要beanName ,
name分隔开做aliases的list.
beanName优先用id,没id的话就从aliases里remove(0)出来一个,
如果有beanName了,校验beanName和aliases唯一性
​ 如果还是没beanName,等会再给它用方法生成个
将element解析,放入GenericBeanDefinition里面 把上一步拿到的bd连带着aliases转String[], beanName一起封装一下成为BeanDefinitionHolder返回;如果上一步返回null,就直接返回null 这里的关键步骤显然是第二步,element转beanDefinition
AbstractBeanDefinition beanDefinition = this.parseBeanDefinitionElement(ele, beanName, containingBean); 这个方法也很长,大概步骤是
this.parseState.push(new BeanEntry(beanName)) 开头push,结尾pop,不明白是做什么??? 获取下className和parent 拿着className和parent去创建个GenericBeanDefinition bd 拿着bd和element进行一系列的解析步骤,把各种值塞入bd 返回bd this.parseState.pop(); 解析各种属性 this.parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); 这个方法的代码丧心病狂地达到了70行,相比于目前读到的其它源码,确实是最长的一个.
但是里面的内容其实并不复杂,就是一个个地从element拿属性,塞属性进bd, 各种 get &amp;amp; set .感觉确实不太好重构.
解析了很多属性,包括scope,abstract,lazy-init,autowire&amp;hellip;
解析子元素meta 解析子元素lookup-method 解析方法和meta差别很小,这里主要是去了解下lookup-method的功能
&amp;lt;bean class=&amp;#34;beanClass&amp;#34;&amp;gt; &amp;lt;lookup-method name=&amp;#34;method&amp;#34; bean=&amp;#34;non-singleton-bean&amp;#34;/&amp;gt; &amp;lt;/bean&amp;gt; method是beanClass中的一个方法，beanClass和method是不是抽象都无所谓，不会影响CGLIB的动态代理，根据项目实际需求去定义。non-singleton-bean指的是lookup-method中bean属性指向的必须是一个非单例模式的bean，当然如果不是也不会报错，只是每次得到的都是相同引用的bean（同一个实例），这样用lookup-method就没有意义了。
参考: Spring - lookup-method方式实现依赖注入
解析子元素replaced-method 这个不仅可以动态地替换返回实体bean,而且还能动态地更改原有方法的逻辑!!!
解析子元素constructor-arg 这里提取构造参数的一些属性值就相比之前复杂多了.
提取index,type,name,判断是否有index属性值 如果有index: 构造Entry压入parseState栈 解析constructor-arg的子元素 使用ConstructorArgumentValues.</description></item><item><title>Spring源码笔记-1.1 获取bean流程之容器的基本实现</title><link>https://heeexy.com/posts/spring-note-1/</link><pubDate>Mon, 11 Sep 2017 20:31:00 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-1/</guid><description>以通过BeanFactory获取bean为例学习,实际项目中更多是使用ApplicationContext
1.读取配置文件 beanFactoryTest.xml
2.通过文件资源获取工厂
3.从工厂中拿bean
读配置 配置文件封装 ClassPathResource类 继承&amp;ndash;AbstractFileResolvingResource
​ 继承&amp;ndash;AbstractResource
​ 实现&amp;ndash;Resource
​ 继承&amp;ndash;InputStreamSource接口 唯一方法: getInputStream()
Resource接口提供了一系列方法来封装底层资源,比如 exists() isReadable() getURL() getFile() getDescription() 等等
XmlBeanFactory的实例化 大概步骤 public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException { super(parentBeanFactory);//1.设置父工厂(null)...本例未使用到此 this.reader = new XmlBeanDefinitionReader(this);//2.实例化XmlBeanDefinitionReader, 注册到此工厂 this.reader.loadBeanDefinitions(resource);//3.重要部分,通过resource来加载beanDefinations,bean的一些定义 } loadBeanDefinitions(resource)方法就是下面的主要要看的
它做了几件事:
将resource用EncodedResource包装一下,编码要用, 本例没特定的charset和encoding因此都是null 获取当前正在加载的资源集 Set currentResources ,如果currentResources 是null 就初始化个 new HashSet(4), 然后将我们要读的encodedResource加到这个set里面去 如果返回false说明正在加载这个xml了,报个错,不继续往下读了
当读完这个资源后,在finally里面会从set里移出这个encodedResource,如果set空了,还会remove这个currentResources,
这个set是放ThreadLocal里面的,
private final ThreadLocal&amp;lt;Set&amp;gt; resourcesCurrentlyBeingLoaded;
是线程安全的,功能是防止同时循环加载同一个xml文件
从encodedResouce里取出文件的inputStream 拿去初始化个InputSource(有enconding的话,给inputSource也设个编码,本例为null)然后 inputSource和encodedResouce里面的resouce一起拿去执行doLoadBeanDefinitions(..)方法,稍后重点讲 var5 = this.doLoadBeanDefinitions(inputSource, encodedResource.</description></item></channel></rss>