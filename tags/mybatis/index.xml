<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>MyBatis on 网站标题</title><link>https://heeexy.com/tags/mybatis/</link><description>Recent content in MyBatis on 网站标题</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 03 Apr 2018 17:07:46 +0000</lastBuildDate><atom:link href="https://heeexy.com/tags/mybatis/index.xml" rel="self" type="application/rss+xml"/><item><title>使用MyBatis时为什么Dao层不需要@Repository</title><link>https://heeexy.com/posts/%E4%BD%BF%E7%94%A8mybatis%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88dao%E5%B1%82%E4%B8%8D%E9%9C%80%E8%A6%81-repository/</link><pubDate>Tue, 03 Apr 2018 17:07:46 +0000</pubDate><guid>https://heeexy.com/posts/%E4%BD%BF%E7%94%A8mybatis%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88dao%E5%B1%82%E4%B8%8D%E9%9C%80%E8%A6%81-repository/</guid><description>问题 Service层注入Dao时， Intellij 总会以红色波浪线提示我们
@Autowired private UserDao userDao; Could not autowire. No beans of &amp;lsquo;UserDao&amp;rsquo; type found. Checks autowiring problems in a bean class.
尽管我们都知道 Dao 层的 Bean 实际上都是有的，并且可以设置关闭这恼人的提示，但是我们有没有想过为什么 Intellij 就找不到这个 Bean 呢？甚至有人有这种做法
@Repository public interface UserDao { } 来避免提示，但是这种做法正确么？
所以今天我们的疑问就是
为什么 Dao 层不需要加 @Repository 注解，源码里到底做了什么？ 加了 @Repository 注解有什么影响？ 答案 关键在于 ClassPathMapperScanner 对指定包的扫描，并且扫描过程对 Spring 原本的扫描 Bean 的步骤 &amp;ldquo;加了料” ，Spring 本身只扫实现类，但 MyBatis 的扫描器扫了接口 。并且扫完接口之后，为接口配了个 BeanDefinition ,并且这个 bd 的 BeanClass 是 MapperFactoryBean 。</description></item><item><title>MyBatis 对未知数据类型的转换(二)TypeHandlerRegistry</title><link>https://heeexy.com/posts/typehandlerregistry/</link><pubDate>Thu, 04 Jan 2018 21:22:33 +0000</pubDate><guid>https://heeexy.com/posts/typehandlerregistry/</guid><description>问题 上一篇我们讲到，对于未知数据类型的解析，UnknownTypeHandler 把部分任务交给了 TypeHandlerRegistry ,甚至可能仅仅只丢了一个 javaType 过来就要求返回一个合适的解析器回去 。TypeHandlerRegistry 到底里面做了啥可以找到合适的解析器呢？
功能 从类的名字我们就知道这个类的功能大概就是个注册表，而且很可能是全局共用的，记录各种 javaType,jdbcType,TypeHandler 的映射关系。实际这个类的核心也就是维护了几个 map 。
核心字段 JDBC_TYPE_HANDLER_MAP private final Map&amp;lt;JdbcType, TypeHandler&amp;lt;?&amp;gt;&amp;gt; JDBC_TYPE_HANDLER_MAP = new EnumMap&amp;lt;JdbcType, TypeHandler&amp;lt;?&amp;gt;&amp;gt;(JdbcType.class); 这个很直观，就是注册 jdbcType 和解析器的对应关系。
TYPE_HANDLER_MAP private final Map&amp;lt;Type, Map&amp;lt;JdbcType, TypeHandler&amp;lt;?&amp;gt;&amp;gt;&amp;gt; TYPE_HANDLER_MAP = new ConcurrentHashMap&amp;lt;Type, Map&amp;lt;JdbcType, TypeHandler&amp;lt;?&amp;gt;&amp;gt;&amp;gt;(); 书上原文是：“记录了 java 类型向指定的 JdbcType 转换时，需要使用的 TypeHandler 对象。例如：Java 类型中的 String 转换成数据库的 char 、varchar 等多种类型，所以存在一对多关系”。
Type 是 java.lang.reflect 包下的接口，Class 类实现了此接口。所以此 map 的 key 值是 javaType ,比如 String.class 。
UNKNOWN_TYPE_HANDLER 就是上一篇文章学习过的 UnknownTypeHandler 的实例，主要用在 Object.</description></item><item><title>MyBatis 对未知数据类型的转换(一)TypeHandler</title><link>https://heeexy.com/posts/mybatis%E5%AF%B9%E6%9C%AA%E7%9F%A5%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/</link><pubDate>Tue, 02 Jan 2018 22:35:52 +0000</pubDate><guid>https://heeexy.com/posts/mybatis%E5%AF%B9%E6%9C%AA%E7%9F%A5%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/</guid><description>问题 前面说到，我们可以用 JSONObject 替代习惯使用的 JavaBean ，而之所以能用 JSONObject 主要就是因为它实现了 Map&amp;lt;String,Object&amp;gt; 。
实际使用我们就会发现，MyBatis 使用JSONObject 封装返回结果的时候很“智能”，数据库里字段是 varchar 类型，JSONObject 中返回值就是 String 类型，数据库字段是 int/float 类型，JSONObject 中返回值就是对应的数值类型。甚至通过 debug 发现数据库中保存了datetime 类型的数据，JSONObject 中保存的是 java.sql.timestamp 类型，而timestamp 类型继承了常见的 java.util.Date 。
为什么 MyBatis 可以用得这么爽呢？我们实现可完全没声明需要此字段的 javaType 呢。而且用得爽了，类型转换会不会导致程序性能大打折扣呢？
今天我们就从深入源码，探究一番 MyBatis 到底是怎样做到对未明确声明的字段处理返回类型的。
TypeHandler MyBatis 类型转换的核心就是这个接口，定义的方法可以看做就两种 setParameter 和 getResult ,很好理解，我们传参和接收 sql 结果时就调用这个。
public interface TypeHandler&amp;lt;T&amp;gt; { void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException; T getResult(ResultSet rs, String columnName) throws SQLException; T getResult(ResultSet rs, int columnIndex) throws SQLException; T getResult(CallableStatement cs, int columnIndex) throws SQLException; } 抽象类 BaseTypeHandler 部分实现了 TypeHandler ,主要完成了对空值的处理。 非空值的处理全部交给了子类完成。</description></item><item><title>MyBatis 中使用 JSONObject 处理一对多结果</title><link>https://heeexy.com/posts/one2many/</link><pubDate>Sun, 31 Dec 2017 12:11:29 +0000</pubDate><guid>https://heeexy.com/posts/one2many/</guid><description>问题 在上一文介绍了 JSONObject 接受 MyBatis 的结果集的简单用法，但是在处理一对多的情况时，单纯的JSONObject就不好使了。
比如要查询一个角色下的多个用户，resultMap如下定义
&amp;lt;resultMap id=&amp;#34;roleMap&amp;#34; type=&amp;#34;com.alibaba.fastjson.JSONObject&amp;#34;&amp;gt; &amp;lt;id column=&amp;#34;roleId&amp;#34; property=&amp;#34;roleId&amp;#34;/&amp;gt; &amp;lt;result column=&amp;#34;roleName&amp;#34; property=&amp;#34;roleName&amp;#34;/&amp;gt; &amp;lt;collection property=&amp;#34;users&amp;#34; ofType=&amp;#34;com.alibaba.fastjson.JSONObject&amp;#34;&amp;gt; &amp;lt;id column=&amp;#34;userId&amp;#34; property=&amp;#34;userId&amp;#34;/&amp;gt; &amp;lt;result column=&amp;#34;nickname&amp;#34; property=&amp;#34;nickname&amp;#34;/&amp;gt; &amp;lt;/collection&amp;gt; &amp;lt;/resultMap&amp;gt; 期望查出来的users 属性对应着一个数组,
然而实际查出来只是一个对象，只有一条数据。
解决方案 只需要建一个实体类继承 JSONObject ,里面有你要的集合类型的成员变量，就足够了。
比如我建的 One2Many 类：
public class One2Many extends JSONObject { private List&amp;lt;JSONObject&amp;gt; users; } 然后xml改为
&amp;lt;resultMap id=&amp;#34;roleMap&amp;#34; type=&amp;#34;com.heeexy.example.util.model.One2Many&amp;#34;&amp;gt; &amp;lt;id column=&amp;#34;roleId&amp;#34; property=&amp;#34;roleId&amp;#34;/&amp;gt; &amp;lt;result column=&amp;#34;roleName&amp;#34; property=&amp;#34;roleName&amp;#34;/&amp;gt; &amp;lt;collection property=&amp;#34;users&amp;#34; ofType=&amp;#34;com.alibaba.fastjson.JSONObject&amp;#34;&amp;gt; &amp;lt;id column=&amp;#34;userId&amp;#34; property=&amp;#34;userId&amp;#34;/&amp;gt; &amp;lt;result column=&amp;#34;nickname&amp;#34; property=&amp;#34;nickname&amp;#34;/&amp;gt; &amp;lt;/collection&amp;gt; &amp;lt;/resultMap&amp;gt; 是不是非常简单？
更棒的是，这个 One2Many 类是可以复用的，里面再添加其它的成员变量就 OK 了。而且 Dao 层不需要改动，外面正常的还是用 JSONObject 就可以了。</description></item><item><title>MyBatis 中使用 JSONObject 替代 JavaBean</title><link>https://heeexy.com/posts/mybatis%E4%B8%AD%E4%BD%BF%E7%94%A8jsonobject%E6%9B%BF%E4%BB%A3javabean/</link><pubDate>Sat, 30 Dec 2017 21:51:55 +0000</pubDate><guid>https://heeexy.com/posts/mybatis%E4%B8%AD%E4%BD%BF%E7%94%A8jsonobject%E6%9B%BF%E4%BB%A3javabean/</guid><description>问题背景 项目后端与前端全部使用 JSON 进行数据交互，比如查询用户列表，通常后端从数据库查出的数据放入实体类再转为 JSON 返回给前端，但是前端的小伙伴表示明明只需要 nickname,avatar,userId 三个字段，为什么传过来的数据多出 phone,address ,profile 之类十几个字段，里面都 null,0 等值？
其实是因为 User 实体类定义了太多字段，转为 JSON 的时候都被包括进去了。稍微多几个还能忍，但通常 User/Order 这些实体类字段特别多，对调试开发实在非常不友好。
因此本次任务就是：确保每个接口返回字段都与接口文档上一模一样，去除冗余字段。
解决过程就省略了，直接抛出我最后的解决方案吧：就是 MyBatis 的返回值几乎完全抛弃实体类，全部使用com.alibaba.fastjson.JSONObject 。
使用 JSONObject 先最简化直观的看一下 JSONObject 的使用吧。
Controller:
@GetMapping(&amp;#34;/list&amp;#34;) public JSONObject listUser(@RequestBody JSONObject requestJson){ return userService.listUser(requestJson); } Service:
JSONObject listUser(JSONObject jsonObject); ServiceImpl:
@Override public JSONObject listUser(JSONObject jsonObject) { //fillPageParam是自定义的封装分页参数 CommonUtil.fillPageParam(jsonObject); int count = userDao.countUser(jsonObject); List&amp;lt;JSONObject&amp;gt; list = userDao.listUser(jsonObject); //自定义successPage封装分页结果 return CommonUtil.successPage(jsonObject, list, count); } Dao:
public interface UserDao { int countUser(JSONObject jsonObject); List&amp;lt;JSONObject&amp;gt; listUser(JSONObject jsonObject); } UserMapper.</description></item><item><title>MyBatis 的日志设计--适配器模式 &amp; 工厂模式</title><link>https://heeexy.com/posts/mybatis%E6%97%A5%E5%BF%97--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><pubDate>Thu, 14 Dec 2017 14:45:47 +0000</pubDate><guid>https://heeexy.com/posts/mybatis%E6%97%A5%E5%BF%97--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid><description>​ MyBatis 想要打印日志，时不时想要来句 log.debug() 、log.error() ，需要个打印机 ，可是自己又不想去实现（而且跟着整个项目用同样的打印系统才是王道啊），需要去用别人家的打印机，要用别人家的产品啊，那问题可就来了。
问题 1 ​ 市面上各家的打印机 slf4j、java.util.logging、log4j 甚至 System.out 都是各种不同的用法，这使用起来就太麻烦了。
思路 ​ 不管市面上打印机有多少型号，我家 MyBatis 包里的类只用自家的统一接口，我家的类只管 log.debug()、log.error()&amp;hellip;
​ 定义好了接口，就需要实现类 impl 来实现这些 debug()、error() 方法了 , 咱假装是自己来实现，其实去调用真正打印机 slf4、log4j 的方法，这样就把别人家的打印机和咱自家的接口关联起来啦。
​ 这就是适配器模式。
​ 我家的每个实现类其实就是一个适配器，每个适配器去适配一种打印机。比如 slf4jLoggerImpl 就完成了对 slf4j 打印机的适配，slf4jLoggerImpl .debug() 调用了slf4j.Logger.debug()。
​ 这样市面上每多一种打印机，比如想用 log4j2 了，我就只需要加一种适配器 log4j2LoggerImpl 去适配它就可以了。
代码 ​ 定义接口
public interface Log { boolean isDebugEnabled(); void debug(String s); ... } ​ 在实现类里完成适配，比如适配 slf4j 的 Slf4jLoggerImpl
import org.apache.ibatis.logging.Log; import org.slf4j.Logger; class Slf4jLoggerImpl implements Log { private final Logger log; //注意这个地方，入参为 org.</description></item></channel></rss>