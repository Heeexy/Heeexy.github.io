<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>笔记 on 网站标题</title><link>https://heeexy.com/tags/%E7%AC%94%E8%AE%B0/</link><description>Recent content in 笔记 on 网站标题</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 28 Jan 2018 13:37:32 +0000</lastBuildDate><atom:link href="https://heeexy.com/tags/%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml"/><item><title>极简 Spring 框架 -- 浅析循环依赖</title><link>https://heeexy.com/posts/spring-note-18-ioc/</link><pubDate>Sun, 28 Jan 2018 13:37:32 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-18-ioc/</guid><description>从网上看到一篇博文 徒手撸框架&amp;ndash;实现IoC ，写得很棒，作者抛开了 Spring 源码中复杂的校验，拓展等功能，实现了一个极简的 IoC 框架，让 Spring 源码初学者可以清楚的看到 IOC 的实现流程。
本文就借其框架，略加改造，再次介绍一下 Spring 是如何处理循环依赖的。
了解本项目核心代码需要先参考原作者的博文 徒手撸框架&amp;ndash;实现IoC 。
循环依赖 其实很好理解，A 类依赖 B，B 又依赖 A。
说具体点就是 ，我们要 getBean(&amp;ldquo;a&amp;rdquo;)， A 在实例化时需要为类型为 B 的成员变量赋值，因此去 getBean(&amp;ldquo;b&amp;rdquo;)，而 getBean(&amp;ldquo;b&amp;rdquo;) 的时候又需要为其类型为A 的成员变量赋值，此时又会回过头去实例化 A ，导致无限循环。
用代码展示就是
public class A { @AutoWired private B b; } public class B { @AutoWired private A a; } 代码改造 最主要的代码改造在于 BeanFactoryImpl 内， 添加了成员变量
private final Map&amp;lt;String, Object&amp;gt; earlySingletonObjects = new HashMap&amp;lt;String, Object&amp;gt;(16); 用于缓存正在创建中的，提前暴露出来的单例 bean。</description></item><item><title>Spring 源码笔记-2.8 根据类型寻找 bean--找出所有匹配类型的 beanName</title><link>https://heeexy.com/posts/spring-note-16-beannamesfortypeincludingancestors/</link><pubDate>Wed, 24 Jan 2018 09:48:02 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-16-beannamesfortypeincludingancestors/</guid><description>前文
源码解析 入参说明
includeNonSingletons：是否包括非单例的 bean，比如 prototype scope allowEagerInit：为了这个检查（找出所有匹配类型的 beanName），是否初始化 lazy-init 单例和由 FactoryBeans 创建的对象。此处我们传入的值为 true。 public static String[] beanNamesForTypeIncludingAncestors( ListableBeanFactory lbf, Class&amp;lt;?&amp;gt; type, boolean includeNonSingletons, boolean allowEagerInit) { Assert.notNull(lbf, &amp;#34;ListableBeanFactory must not be null&amp;#34;); //方法主干还是在这行 getBeanNamesForType String[] result = lbf.getBeanNamesForType(type, includeNonSingletons, allowEagerInit); //下面的内容就是从 bf 的 parent 中找， if (lbf instanceof HierarchicalBeanFactory) { HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf; if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) { //此处以 parent 再来调此方法，合并结果。 String[] parentResult = beanNamesForTypeIncludingAncestors( (ListableBeanFactory) hbf.</description></item><item><title>Spring 源码笔记-2.7 根据类型寻找 bean</title><link>https://heeexy.com/posts/spring-note-15-findautowirecandidates/</link><pubDate>Tue, 23 Jan 2018 09:00:22 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-15-findautowirecandidates/</guid><description>前言 Spring 装配 bean 有两种类型：autowireByName 和 autowireByType 。
autowireByName 通过名称查找很直接，就是我们一直在学的 getBean() 。
而 autowireByType 根据类型查找相比起来就要复杂一些了，《 Spring 源码深度解析 》 中有介绍过的部分我就不再重复贴了，但是书中遗漏了一处重要的部分&amp;mdash;&amp;mdash; findAutowireCandidates 查找所有合适的 bean，还有一处新版本 Spring 中升级的部分&amp;mdash;&amp;mdash;如果只需要一个但是找出多个 bean 该怎么处理，今天我们先来学习第一部分。
正文 本函数要做什么 @RestController @RequestMapping(&amp;#34;/article&amp;#34;) public class ArticleController { @Autowired private ArticleService articleService; } 在初始化 ArticleController 的过程中，我们要为其装配 ArticleService 。
忽略掉外面代码一层一层的包裹之后，我们走到 DefaultListableBeanFactory.findAutowireCandidates 这个函数中，要寻找合适的候选 bean 。由于可能会找到多个，因此返回结果是候选 bean 的名称和其对应实例构成的 Map 。
源码解析 //三个参数的含义依次是 // 正在解析的 beanName, 本例中即 &amp;#34;articleController&amp;#34; // 需要装配的 bean 类型, 本例中即 ArticleService.class // 对当前依赖关系的解析类，记录了 ArticleController 和 ArticleService 的依赖关系 protected Map&amp;lt;String, Object&amp;gt; findAutowireCandidates(String beanName, Class&amp;lt;?</description></item><item><title>Spring 源码笔记-2.6 BeanWrapper 对比 MyBatis</title><link>https://heeexy.com/posts/spring-note-14-beanwrapper/</link><pubDate>Fri, 19 Jan 2018 15:21:58 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-14-beanwrapper/</guid><description>Spring vs MyBatis Spring 和 MyBatis 中都有 BeanWrapper , Spring 中为接口， 实现类为 BeanWrapperImpl , 为了方便后面区分，本文用 SB 指代 Spring 的 BeanWrapperImpl ，用 MB 指代 MyBatis 中的 BeanWrapper。
功能 BeanWrapper 都属于各自框架的反射工具箱的重要组成部分。都是创建实例并且为其属性赋值的。以 SB 为例，下面的代码应该很容易看明白它的功能。
BeanWrapper company = BeanWrapperImpl(new Company()); // setting the company name.. company.setPropertyValue(&amp;#34;name&amp;#34;, &amp;#34;Some Company Inc.&amp;#34;); // ... can also be done like this: PropertyValue value = new PropertyValue(&amp;#34;name&amp;#34;, &amp;#34;Some Company Inc.&amp;#34;); company.setPropertyValue(value); // ok, let&amp;#39;s create the director and tie it to the company: BeanWrapper jim = BeanWrapperImpl(new Employee()); jim.</description></item><item><title>Spring源码笔记-2.5 createBean</title><link>https://heeexy.com/posts/spring-note-13-createbean/</link><pubDate>Thu, 18 Jan 2018 14:22:06 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-13-createbean/</guid><description>此方法交给了 AbstractBeanFactory 的子类 AbstractAutowireCapableBeanFactory 去实现。
并且不管这个bean是单例还是 prototype 还是其它 scope ,最终都是会走到此处，只是前后的一些验证、处理有区别。比如单例的就要先去缓存中获取，prototype 就不需要。
源码阅读到这里，我们已经习惯了一层一层剥。createBean 依然还是没有直接地把 bean 创建出来（当然我所期望的看到创建 bean 就是看到它的反射源码为止）。
createBean 的大致步骤为:
根据 RootBeanDefinition 来获取要创建 bean 的 class 。这 class 还有可能为 null。 prepareMethodOverrides 。准备 override 方法，对 override 属性进行验证。 给后处理器一个机会来返回代理，替代真正的 bean. doCreateBean 创建真正的 bean 实例。 prepareMethodOverrides 首先去温习一遍 lookup-method 和 replace-method 吧。博文
其实就是通过配置把原本 bean 中的某个方法给替代掉。
此处我们先只是确认一遍指定的替代方法存在于要生成的 bean 中。
顺带看一看这个方法有没有重载overload)，做个标记。
resolveBeforeInstantiation 经过一波预处理器InstantiationAwareBeanPostProcessor ，如果生产出了 bean，再经过一波后处理器。
一旦生产出 bean，则立即将此 bean 返回。
此处就是留下了一个拓展点，经过此方法之后，bean可能已经不是我们认为的 bean 了，而可能已经变成了一个经过处理的代理 bean 。
循环依赖 构造器循环依赖 如果是 prototype，无法解决，只能抛错。</description></item><item><title>Spring源码笔记-2.4 获取单例</title><link>https://heeexy.com/posts/spring-note-12-%E8%8E%B7%E5%8F%96%E5%8D%95%E4%BE%8B/</link><pubDate>Fri, 29 Sep 2017 22:49:00 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-12-%E8%8E%B7%E5%8F%96%E5%8D%95%E4%BE%8B/</guid><description>获取单例bean getSingleton 明明之前一篇已经讲过了获取单例,为什么这里又是获取单例bean呢?
两天不看书,果断又忘了.前面学的是从缓存中获取,这里是真正的获取.
DefaultSingletonBeanRegistry 中重载此方法,第二参数为ObjectFactory
public Object getSingleton(String beanName, ObjectFactory&amp;lt;?&amp;gt; singletonFactory) { Assert.notNull(beanName, &amp;#34;&amp;#39;beanName&amp;#39; must not be null&amp;#34;); //这里再次看到了这个singletonObjects,上篇文章介绍过,是维护了单例对象 //书中说法是:用于保存BeanName和创建bean实例之间的关系 Map var3 = this.singletonObjects; synchronized(this.singletonObjects) { Object singletonObject = this.singletonObjects.get(beanName); //首先获取一遍,如果不存在,才去创建 if (singletonObject == null) { //工厂如果正在销毁,这时候获取bean就会报错 if (this.singletonsCurrentlyInDestruction) { throw new BeanCreationNotAllowedException(beanName, &amp;#34;Singleton bean creation not allowed while the singletons of this factory are in destruction (Do not request a bean from a BeanFactory in a destroy method implementation!</description></item><item><title>Spring源码笔记-2.3 缓存中获取单例bean及获取对象</title><link>https://heeexy.com/posts/spring-note-11-getsingleton/</link><pubDate>Tue, 26 Sep 2017 23:28:00 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-11-getsingleton/</guid><description>缓存中获取单例bean getSingleton DefaultSingletonBeanRegistry 中实现此方法
//这个map维护了单例对象 private final Map&amp;lt;String, Object&amp;gt; singletonObjects = new ConcurrentHashMap(256); //当前正在创建中的单例对象 private final Set&amp;lt;String&amp;gt; singletonsCurrentlyInCreation = Collections.newSetFromMap(new ConcurrentHashMap(16)); //早期单例对象 private final Map&amp;lt;String, Object&amp;gt; earlySingletonObjects = new HashMap(16); //单例工厂? private final Map&amp;lt;String, ObjectFactory&amp;lt;?&amp;gt;&amp;gt; singletonFactories = new HashMap(16); protected Object getSingleton(String beanName, boolean allowEarlyReference) { Object singletonObject = this.singletonObjects.get(beanName); //如果根据这个beanName没取到对象,但发现这个对象还在创建中..... if (singletonObject == null &amp;amp;&amp;amp; this.isSingletonCurrentlyInCreation(beanName)) { Map var4 = this.singletonObjects; synchronized(this.singletonObjects) { singletonObject = this.earlySingletonObjects.get(beanName); //如果早期单例对象中没有此bean,并且允许早期依赖 if (singletonObject == null &amp;amp;&amp;amp; allowEarlyReference) { //当某些方法需要提前初始化的时候则会调用 addSingletonFactory方法将对应的ObjectFactory初始化策略存储在singletonFactories ObjectFactory&amp;lt;?</description></item><item><title>Spring源码笔记-2.2 FactoryBean</title><link>https://heeexy.com/posts/spring-note-10-factorybean/</link><pubDate>Tue, 26 Sep 2017 14:47:00 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-10-factorybean/</guid><description>package org.springframework.beans.factory; public interface FactoryBean&amp;lt;T&amp;gt; { //返回由FactoryBean创建的bean实例,如果isSingleton()返回true,则该实例会放到Spring容器中单实例缓存池中 T getObject() throws Exception; //返回FactoryBean创建的bean类型 Class&amp;lt;?&amp;gt; getObjectType(); //返回bean实例的作用域是singleton还是prototype boolean isSingleton(); } ​ 当配置文件的class属性配置的实现类是FactoryBean 时,通过getBean() 方法返回的不是FactoryBean 本身,而是FactoryBean.getObject() 方法所返回的对象.
​ 相当于FactoryBean.getObject() 代理了getBean() 方法.
​ 例如,如果使用传统方式配置Car的bean,Car的每个属性对应一个 元素标签
public class Car { private int maxSpeed; private String brand; private double price; //get/set } ​ 如果使用FactoryBean的方式就会灵活一些,下面通过逗号分隔符的方式一次性地为Car的所有属性指定配置值:
public class CarFactoryBean implements FactoryBean&amp;lt;Car&amp;gt; { private String carInfo; @Override public Car getObject() throws Exception { Car car = new Car(); String[] infos = carInfo.</description></item><item><title>Spring源码笔记-2.1 bean的加载初探</title><link>https://heeexy.com/posts/spring-note-9-beanload/</link><pubDate>Tue, 26 Sep 2017 11:16:00 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-9-beanload/</guid><description>本文要看啥? ​ 前面已经了解了bean从配置文件到解析成BDHolder到注册的流程,我们已经将bean的信息封装好,塞入了map中,这个map可能在不同的实现里面,前面重点学的就是DefaultListableBeanFactory里的beanDefinitionMap.
​ 我们现在要探索bean的加载,围绕最初的示例代码:
MyTestBean bean =(MyTestBean)bf.getBean(&amp;#34;myTestBean&amp;#34;); ​ BeanFactory是个接口,其下实现关系很复杂, getBean方法的实现主要是在AbstractBeanFactory 这一层.
​ 本文就是先来快速体验一下加载bean的大体流程
进入代码吧 protected &amp;lt;T&amp;gt; T doGetBean(String name, Class&amp;lt;T&amp;gt; requiredType, final Object[] args, boolean typeCheckOnly) throws BeansException { //转换beanName final String beanName = this.transformedBeanName(name); //根据beanName找其单例 Object sharedInstance = this.getSingleton(beanName); Object bean; if (sharedInstance != null &amp;amp;&amp;amp; args == null) { if (this.logger.isDebugEnabled()) { if (this.isSingletonCurrentlyInCreation(beanName)) { this.logger.debug(&amp;#34;Returning eagerly cached instance of singleton bean &amp;#39;&amp;#34; + beanName + &amp;#34;&amp;#39; that is not fully initialized yet - a consequence of a circular reference&amp;#34;); } else { this.</description></item><item><title>Spring源码笔记-1.6 自定义标签的解析</title><link>https://heeexy.com/posts/spring-note-8-custom-element/</link><pubDate>Tue, 19 Sep 2017 19:33:23 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-8-custom-element/</guid><description>自定义标签的使用 主要内容都在书上,p80
关键的部分为
创建XSD文件 创建类 继承AbstractSingleBeanDefinitionParser , 其继承关系最主要是实现了BeanDefinitionParser 接口,顾名思义,可以用来解析bean. 创建Handler文件, 继承自 NamespaceHandlerSupport ,目的是将上面的组件注册到Spring容器内 编写Spring.handlers 和 Spring.schemas文件. 这样,自定义的配置就结束了.
Spring加载自定义bean的流程主要就是遇到自定义标签后就去Spring.handlers和Spring.schemas中取找对应的handler 和 XSD .从而可以拿到parser
而代码里的主要步骤为
拿到标签对应的命名空间 根据命名空间找到对应的handler 调用handler的parse方法 获取标签的命名空间 调用org.w3c.dom.Node中的getNamespaceURI()
提取自定义标签处理器 NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); 这个resolve方法是接口,由DefaultNamespaceHandlerResolver 默认命名空间解析器来实现,其实现里面的第一步便是
Map&amp;lt;String, Object&amp;gt; handlerMappings = this.getHandlerMappings(); 原来handlerMappings 是个map,想必是在注册时肯定把解析器添加到这个map里面来,用namespaceUri做key,这样找的时候就很好找了.
取出结果如果是NamespaceHandler 便可以返回,往下读我们发现,之所以这么爽取出来就是handler,是因为已经做过这个解析,把找出的handler塞入了map,相当于是缓存了.
否则就是类名 className, 我们需要把它转为handler
//使用反射,将类路径转化为类 Class&amp;lt;?&amp;gt; handlerClass = ClassUtils.forName(className, this.classLoader); if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) { throw new FatalBeanException(&amp;#34;Class [&amp;#34; + className + &amp;#34;] for namespace [&amp;#34; + namespaceUri + &amp;#34;] does not implement the [&amp;#34; + NamespaceHandler.</description></item><item><title>Spring源码笔记-1.5 其它标签解析</title><link>https://heeexy.com/posts/spring-note-7-other-default-elements/</link><pubDate>Tue, 19 Sep 2017 19:33:04 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-7-other-default-elements/</guid><description>本文要看啥 之前我们看解析默认标签,从最核心的bean开始看的
private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) { if (delegate.nodeNameEquals(ele, &amp;#34;import&amp;#34;)) { this.importBeanDefinitionResource(ele); } else if (delegate.nodeNameEquals(ele, &amp;#34;alias&amp;#34;)) { this.processAliasRegistration(ele); } else if (delegate.nodeNameEquals(ele, &amp;#34;bean&amp;#34;)) { this.processBeanDefinition(ele, delegate); } else if (delegate.nodeNameEquals(ele, &amp;#34;beans&amp;#34;)) { this.doRegisterBeanDefinitions(ele); } } 现在主要就剩下alias和import啦, beans其实就是迭代解析.
alias标签的解析 为bean定义别名,除了之前我们接触过的
&amp;lt;bean id=&amp;#34;testBean&amp;#34; name=&amp;#34;aliasTestBean&amp;#34; class=&amp;#34;com.test&amp;#34;/&amp;gt; 还可以直接用alias标签
&amp;lt;alias name=&amp;#34;testBean&amp;#34; alias=&amp;#34;aliasTestBean&amp;#34;/&amp;gt; 解析步骤即使不看源码也知道很简单,因为之前我们已经深入研究过了SimpleAliasRegistry
校验 name alias 两个属性不能为空 this.getReaderContext().getRegistry().registerAlias(name, alias); 这个getRegistry() 然后registerAlias() 果然就是我们之前学过的SimpleAliasRegistry 里面的注册别名的方法.
impory标签的解析 import标签和bean标签一样是我们最常见的标签,对于分模块管理配置文件很关键.
解析步骤 取出并校验resource 属性作为地址location
将地址中的系统属性 如 &amp;ldquo;${user.dir}&amp;rdquo;
判断location是绝对路径还是相对路径</description></item><item><title>test_volatile_object</title><link>https://heeexy.com/posts/test-volatile-object/</link><pubDate>Mon, 18 Sep 2017 22:28:29 +0000</pubDate><guid>https://heeexy.com/posts/test-volatile-object/</guid><description>本文要看啥 先不细谈volatile的基本原理,在读(写)这篇文章时,都是假设我们已经粗略了解了一点volatile的原理和作用的,主要就是 &amp;ldquo;读写都走主内存,保证任意线程对这个变量的可见性&amp;rdquo;
在查看spring源码的时候,注意到spring在处理并发的操作List时, 虽然对list使用了volatile, 然而向list里面添加元素时,用的还是新建一个list,复制全部旧值,增加新元素,然后将旧的list地址指向新的list.
List&amp;lt;String&amp;gt; updatedDefinitions = new ArrayList(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); this.beanDefinitionNames = updatedDefinitions; 这么麻烦的操作,第一反应就是,volatile修饰的list, 直接添加元素依然不安全么?
去网上搜了一下相关问题, 参考博文地址 ,发现不止list, 对象也是一样的.
本文就是要来用代码直观地看看volatile 到底有什么效果,怎么用才有效果.
开始代码吧 线程共享对象里的boolean 注意代码要以**-server模式**运行，强制虚拟机开启优化
public class VolatileObjectTest implements Runnable { // 加上volatile 就可以正常结束While循环了 private ObjectA a; public VolatileObjectTest(ObjectA a) { this.a = a; } public void stop() { a.setFlag(false); } @Override public void run() { long i = 0; while (a.isFlag()) { i++; /** 注意这里的sysout,如果有调用的话,即使没有volatile,子线程也经常能拿到a.flag, 结合后面的测试,发现sysout 或者 sysout(a.</description></item><item><title>SimpleAliasRegistry</title><link>https://heeexy.com/posts/spring-note-5-simplealiasregistry/</link><pubDate>Fri, 15 Sep 2017 21:27:09 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-5-simplealiasregistry/</guid><description>功能:注册/存放别名
唯一成员变量为
private final Map&amp;lt;String, String&amp;gt; aliasMap = new ConcurrentHashMap(16); 这Map&amp;lt;String,String&amp;gt; 其实key是alias,value是name. 刚开始没注意可能搞反了呢
注册别名registerAlias() 举例来说 我们要注册的beanName为myTestBean , 别名为mtb
校验name和alias都不为空
如果name和alias一样,那map里删了这条name,结束
依据alias 即 mtb去map里面取已注册的name,如果真的有已注册过的话:
registeredName 和name相等的话,那就不用管,结束. 如果他俩不相等,这个工厂又不允许重写alias,那就抛异常! (allowAliasOverriding() 这个方法在SimpleAliasRegistry的子类里面有的会被重写. 如果前面都通过了,this.checkForAliasCircle(name, alias); 再次循环检查一遍,判断是否hasAlias(),如果是true的话,就报错,不是的话,走第5步. 具体hasAlias()流程如下:
循环找出registeredName 为myTestBean的那组键值对 (这里和上面的遍历不一样哦,这里是根据直接找重复的beanName的,上面是找重复的alias的 如果这个键值对的key即alias也是等于mtb的话,报错 (但是实际我们这第三步也查过这种情况) 如果这个myTestBean找出来的alias是&amp;quot;myTB&amp;quot;,那就还要走一遍hasAlias(&amp;quot;myTB&amp;quot;,&amp;quot;mtb&amp;quot;) ,换句话说,就是要看一看是不是有哪个bean名字叫myTB,别名叫mtb的,如果真的有,就返回true 第四步的hasAlias() 这种判断是啥意思呢?
想注册 mtb&amp;ndash;myTestBean (别名&amp;ndash;本名)
如果已存在 mtb&amp;ndash;myTestBean ,那么返回true
如果已存在 myTB&amp;ndash;myTestBean,
​ 且存在 mtb&amp;ndash;myTB ,
那就构成了 mtb&amp;ndash;myTB&amp;ndash;myTestBean 也返回true
如果已存在 myTB&amp;ndash;myTestBean,
​ 且存在 mta&amp;ndash;myTB
​ 且存在 mtb&amp;ndash;mta ,
那就构成了 mtb&amp;ndash;mta&amp;ndash;myTB&amp;ndash;myTestBean 还是返回true
.
这下看明白了吧,</description></item><item><title>Spring源码笔记-1.4 获取bean流程之注册BeanDefinition</title><link>https://heeexy.com/posts/spring-note-6-registerbeandefinition/</link><pubDate>Fri, 15 Sep 2017 21:26:00 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-6-registerbeandefinition/</guid><description>本文要看啥 这个bean总算是解析完了,也装饰完了,等于是说信息我们都提取好了,现在该做的就是去注册啦.
BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, this.getReaderContext().getRegistry()); 就是这个方法了
开始进入方法吧 public static void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException { String beanName = definitionHolder.getBeanName(); registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition()); String[] aliases = definitionHolder.getAliases(); if (aliases != null) { String[] var4 = aliases; int var5 = aliases.length; for(int var6 = 0; var6 &amp;lt; var5; ++var6) { String alias = var4[var6]; registry.registerAlias(beanName, alias); } } } 拿到beanName
用beanName和bd去registry里注册.
registry是个接口,具体的实现在4.3.7版本中看到两种,一种是SimpleBeanDefinitionRegistry里,和它名字一样非常简单,就是塞进map, 另外一种就复杂了,稍后我们再来看
用beanName和alias去registry里注册
注册aliases也是接口 ,BeanDefinitionRegistry还是继承自AliasRegistry的, 4.3.7只看到SimpleAliasRegistry一种实现
注册alias就简单多了, SimpleAliasRegistry里有
private final Map&amp;lt;String, String&amp;gt; aliasMap = new ConcurrentHashMap(16); 稍后我再另开一文把SimpleAliasRegistry来读一遍</description></item><item><title>Spring源码笔记-1.3 获取bean流程之解析bean标签中的自定义标签元素</title><link>https://heeexy.com/posts/spring-note-4-decoratebeandefinitionifrequired/</link><pubDate>Fri, 15 Sep 2017 21:24:00 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-4-decoratebeandefinitionifrequired/</guid><description>本文要看啥 protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) { BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) { bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try { BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, this.getReaderContext().getRegistry()); } catch (BeanDefinitionStoreException var5) { this.getReaderContext().error(&amp;#34;Failed to register bean definition with name &amp;#39;&amp;#34; + bdHolder.getBeanName() + &amp;#34;&amp;#39;&amp;#34;, ele, var5); } this.getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); } } 前面的笔记中,我们已经走完了这个方法中的第一步,感觉第一步就走了很远,眼瞅要迷路了,但无论如何,总归是拿到了我们的bdHolder, 里面已经存放了Bean标签里面的默认的元素.
如果bdHolder不为空的话,我们可以继续往下走啦.
今天来研究下这段代码
bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); 看方法名字就大概知道,这里要做的事情就是 如果有需要的话,装饰我们刚拿到的bdHolder.
那么何为需要呢?下面这样的场景便是了
&amp;lt;bean id=&amp;#34;test&amp;#34; class=&amp;#34;test.myClass&amp;#34;&amp;gt; &amp;lt;mybean:user username=&amp;#34;aaa&amp;#34;/&amp;gt; &amp;lt;/bean&amp;gt; 这里的自定义标签和
&amp;lt;mvc:resources mapping=&amp;#34;/img/**&amp;#34; location=&amp;#34;img/&amp;#34;/&amp;gt; &amp;lt;aop:config/&amp;gt; &amp;lt;tx:advice id=&amp;#34;transactionAdvice&amp;#34; transaction-manager=&amp;#34;transactionManager&amp;#34;/&amp;gt; 并不同,这里的是在bean内的, 而mvc那种标签是在beans里面,与bean同级的</description></item><item><title>ConstructorArgumentValues 构造器参数值保存器</title><link>https://heeexy.com/posts/spring-note-3-constructorargumentvalues/</link><pubDate>Thu, 14 Sep 2017 21:10:33 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-3-constructorargumentvalues/</guid><description>private final Map&amp;lt;Integer, ConstructorArgumentValues.ValueHolder&amp;gt; indexedArgumentValues = new LinkedHashMap(0); private final List&amp;lt;ConstructorArgumentValues.ValueHolder&amp;gt; genericArgumentValues = new LinkedList(); 这个保存器的核心就在他的LinkedHashMap和LinkedList
疑问: 这里为什么选用linked来储存呢?
答:
添加有index的关键代码如下
private void addOrMergeIndexedArgumentValue(Integer key, ConstructorArgumentValues.ValueHolder newValue) { //拿当前这个位置的值 ConstructorArgumentValues.ValueHolder currentValue = (ConstructorArgumentValues.ValueHolder)this.indexedArgumentValues.get(key); //如果当前位置有值,并且新值是接受合并的话,那合并一波之后作为新值 //如果不接受合并的话,那扔了之前的value不管了,只用新来的value if (currentValue != null &amp;amp;&amp;amp; newValue.getValue() instanceof Mergeable) { Mergeable mergeable = (Mergeable)newValue.getValue(); if (mergeable.isMergeEnabled()) { newValue.setValue(mergeable.merge(currentValue.getValue())); } } //将新值放入LinkedHashMap this.indexedArgumentValues.put(key, newValue); } 疑问:在获取vh之前我们不就验证过index不能重复么?为什么这里还有可能搞一波合并?是有其它地方也调用这个方法,那里可以合并?
答: 注意到这个类里有个方法,addArgumentValues(ConstructorArgumentValues other),貌似就是专门和其它CAV搞合并的,用CAV做构造参数的那个构造器调用了此方法,这里会有可能需要合并
添加没有index的参数
public void addGenericArgumentValue(ConstructorArgumentValues.ValueHolder newValue) { //校验不为空 Assert.notNull(newValue, &amp;#34;ValueHolder must not be null&amp;#34;); //如果list内已经含有此value则跳过 if (!</description></item><item><title>Spring源码笔记-1.2 获取bean流程之bean标签的解析及注册</title><link>https://heeexy.com/posts/spring-note-2/</link><pubDate>Tue, 12 Sep 2017 21:41:09 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-2/</guid><description>1.解析BeanDefinition BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); 作用就是将element封装进bdHolder里面.
其源码很长,不贴了,但功能流程还很清晰
处理id,name,aliases. 关键是需要beanName ,
name分隔开做aliases的list.
beanName优先用id,没id的话就从aliases里remove(0)出来一个,
如果有beanName了,校验beanName和aliases唯一性
​ 如果还是没beanName,等会再给它用方法生成个
将element解析,放入GenericBeanDefinition里面 把上一步拿到的bd连带着aliases转String[], beanName一起封装一下成为BeanDefinitionHolder返回;如果上一步返回null,就直接返回null 这里的关键步骤显然是第二步,element转beanDefinition
AbstractBeanDefinition beanDefinition = this.parseBeanDefinitionElement(ele, beanName, containingBean); 这个方法也很长,大概步骤是
this.parseState.push(new BeanEntry(beanName)) 开头push,结尾pop,不明白是做什么??? 获取下className和parent 拿着className和parent去创建个GenericBeanDefinition bd 拿着bd和element进行一系列的解析步骤,把各种值塞入bd 返回bd this.parseState.pop(); 解析各种属性 this.parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); 这个方法的代码丧心病狂地达到了70行,相比于目前读到的其它源码,确实是最长的一个.
但是里面的内容其实并不复杂,就是一个个地从element拿属性,塞属性进bd, 各种 get &amp;amp; set .感觉确实不太好重构.
解析了很多属性,包括scope,abstract,lazy-init,autowire&amp;hellip;
解析子元素meta 解析子元素lookup-method 解析方法和meta差别很小,这里主要是去了解下lookup-method的功能
&amp;lt;bean class=&amp;#34;beanClass&amp;#34;&amp;gt; &amp;lt;lookup-method name=&amp;#34;method&amp;#34; bean=&amp;#34;non-singleton-bean&amp;#34;/&amp;gt; &amp;lt;/bean&amp;gt; method是beanClass中的一个方法，beanClass和method是不是抽象都无所谓，不会影响CGLIB的动态代理，根据项目实际需求去定义。non-singleton-bean指的是lookup-method中bean属性指向的必须是一个非单例模式的bean，当然如果不是也不会报错，只是每次得到的都是相同引用的bean（同一个实例），这样用lookup-method就没有意义了。
参考: Spring - lookup-method方式实现依赖注入
解析子元素replaced-method 这个不仅可以动态地替换返回实体bean,而且还能动态地更改原有方法的逻辑!!!
解析子元素constructor-arg 这里提取构造参数的一些属性值就相比之前复杂多了.
提取index,type,name,判断是否有index属性值 如果有index: 构造Entry压入parseState栈 解析constructor-arg的子元素 使用ConstructorArgumentValues.</description></item><item><title>Spring源码笔记-1.1 获取bean流程之容器的基本实现</title><link>https://heeexy.com/posts/spring-note-1/</link><pubDate>Mon, 11 Sep 2017 20:31:00 +0000</pubDate><guid>https://heeexy.com/posts/spring-note-1/</guid><description>以通过BeanFactory获取bean为例学习,实际项目中更多是使用ApplicationContext
1.读取配置文件 beanFactoryTest.xml
2.通过文件资源获取工厂
3.从工厂中拿bean
读配置 配置文件封装 ClassPathResource类 继承&amp;ndash;AbstractFileResolvingResource
​ 继承&amp;ndash;AbstractResource
​ 实现&amp;ndash;Resource
​ 继承&amp;ndash;InputStreamSource接口 唯一方法: getInputStream()
Resource接口提供了一系列方法来封装底层资源,比如 exists() isReadable() getURL() getFile() getDescription() 等等
XmlBeanFactory的实例化 大概步骤 public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) throws BeansException { super(parentBeanFactory);//1.设置父工厂(null)...本例未使用到此 this.reader = new XmlBeanDefinitionReader(this);//2.实例化XmlBeanDefinitionReader, 注册到此工厂 this.reader.loadBeanDefinitions(resource);//3.重要部分,通过resource来加载beanDefinations,bean的一些定义 } loadBeanDefinitions(resource)方法就是下面的主要要看的
它做了几件事:
将resource用EncodedResource包装一下,编码要用, 本例没特定的charset和encoding因此都是null 获取当前正在加载的资源集 Set currentResources ,如果currentResources 是null 就初始化个 new HashSet(4), 然后将我们要读的encodedResource加到这个set里面去 如果返回false说明正在加载这个xml了,报个错,不继续往下读了
当读完这个资源后,在finally里面会从set里移出这个encodedResource,如果set空了,还会remove这个currentResources,
这个set是放ThreadLocal里面的,
private final ThreadLocal&amp;lt;Set&amp;gt; resourcesCurrentlyBeingLoaded;
是线程安全的,功能是防止同时循环加载同一个xml文件
从encodedResouce里取出文件的inputStream 拿去初始化个InputSource(有enconding的话,给inputSource也设个编码,本例为null)然后 inputSource和encodedResouce里面的resouce一起拿去执行doLoadBeanDefinitions(..)方法,稍后重点讲 var5 = this.doLoadBeanDefinitions(inputSource, encodedResource.</description></item></channel></rss>