<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>笔记 | 网站标题</title>
<meta name=keywords content><meta name=description content><meta name=author content><link rel=canonical href=https://heeexy.com/tags/%E7%AC%94%E8%AE%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://heeexy.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://heeexy.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://heeexy.com/favicon-32x32.png><link rel=apple-touch-icon href=https://heeexy.com/apple-touch-icon.png><link rel=mask-icon href=https://heeexy.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://heeexy.com/tags/%E7%AC%94%E8%AE%B0/index.xml><link rel=alternate hreflang=en href=https://heeexy.com/tags/%E7%AC%94%E8%AE%B0/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="笔记"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://heeexy.com/tags/%E7%AC%94%E8%AE%B0/"><meta name=twitter:card content="summary"><meta name=twitter:title content="笔记"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://heeexy.com/ accesskey=h title="网站标题 (Alt + H)">网站标题</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><header class=page-header><h1>笔记</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>极简 Spring 框架 -- 浅析循环依赖</h2></header><div class=entry-content><p>从网上看到一篇博文 徒手撸框架–实现IoC ，写得很棒，作者抛开了 Spring 源码中复杂的校验，拓展等功能，实现了一个极简的 IoC 框架，让 Spring 源码初学者可以清楚的看到 IOC 的实现流程。
本文就借其框架，略加改造，再次介绍一下 Spring 是如何处理循环依赖的。
了解本项目核心代码需要先参考原作者的博文 徒手撸框架–实现IoC 。
循环依赖 其实很好理解，A 类依赖 B，B 又依赖 A。
说具体点就是 ，我们要 getBean(“a”)， A 在实例化时需要为类型为 B 的成员变量赋值，因此去 getBean(“b”)，而 getBean(“b”) 的时候又需要为其类型为A 的成员变量赋值，此时又会回过头去实例化 A ，导致无限循环。
用代码展示就是
public class A { @AutoWired private B b; } public class B { @AutoWired private A a; } 代码改造 最主要的代码改造在于 BeanFactoryImpl 内， 添加了成员变量
private final Map&lt;String, Object> earlySingletonObjects = new HashMap&lt;String, Object>(16); 用于缓存正在创建中的，提前暴露出来的单例 bean。...</p></div><footer class=entry-footer><span title='2018-01-28 13:37:32 +0000 UTC'>January 28, 2018</span></footer><a class=entry-link aria-label="post link to 极简 Spring 框架 -- 浅析循环依赖" href=https://heeexy.com/posts/spring-note-18-ioc/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Spring 源码笔记-2.8 根据类型寻找 bean--找出所有匹配类型的 beanName</h2></header><div class=entry-content><p>前文
源码解析 入参说明
includeNonSingletons：是否包括非单例的 bean，比如 prototype scope allowEagerInit：为了这个检查（找出所有匹配类型的 beanName），是否初始化 lazy-init 单例和由 FactoryBeans 创建的对象。此处我们传入的值为 true。 public static String[] beanNamesForTypeIncludingAncestors( ListableBeanFactory lbf, Class&lt;?> type, boolean includeNonSingletons, boolean allowEagerInit) { Assert.notNull(lbf, "ListableBeanFactory must not be null"); //方法主干还是在这行 getBeanNamesForType String[] result = lbf.getBeanNamesForType(type, includeNonSingletons, allowEagerInit); //下面的内容就是从 bf 的 parent 中找， if (lbf instanceof HierarchicalBeanFactory) { HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf; if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) { //此处以 parent 再来调此方法，合并结果。 String[] parentResult = beanNamesForTypeIncludingAncestors( (ListableBeanFactory) hbf....</p></div><footer class=entry-footer><span title='2018-01-24 09:48:02 +0000 UTC'>January 24, 2018</span></footer><a class=entry-link aria-label="post link to Spring 源码笔记-2.8 根据类型寻找 bean--找出所有匹配类型的 beanName" href=https://heeexy.com/posts/spring-note-16-beannamesfortypeincludingancestors/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Spring 源码笔记-2.7 根据类型寻找 bean</h2></header><div class=entry-content><p>前言 Spring 装配 bean 有两种类型：autowireByName 和 autowireByType 。
autowireByName 通过名称查找很直接，就是我们一直在学的 getBean() 。
而 autowireByType 根据类型查找相比起来就要复杂一些了，《 Spring 源码深度解析 》 中有介绍过的部分我就不再重复贴了，但是书中遗漏了一处重要的部分—— findAutowireCandidates 查找所有合适的 bean，还有一处新版本 Spring 中升级的部分——如果只需要一个但是找出多个 bean 该怎么处理，今天我们先来学习第一部分。
正文 本函数要做什么 @RestController @RequestMapping("/article") public class ArticleController { @Autowired private ArticleService articleService; } 在初始化 ArticleController 的过程中，我们要为其装配 ArticleService 。
忽略掉外面代码一层一层的包裹之后，我们走到 DefaultListableBeanFactory.findAutowireCandidates 这个函数中，要寻找合适的候选 bean 。由于可能会找到多个，因此返回结果是候选 bean 的名称和其对应实例构成的 Map 。
源码解析 //三个参数的含义依次是 // 正在解析的 beanName, 本例中即 "articleController" // 需要装配的 bean 类型, 本例中即 ArticleService.class // 对当前依赖关系的解析类，记录了 ArticleController 和 ArticleService 的依赖关系 protected Map&lt;String, Object> findAutowireCandidates(String beanName, Class&lt;?...</p></div><footer class=entry-footer><span title='2018-01-23 09:00:22 +0000 UTC'>January 23, 2018</span></footer><a class=entry-link aria-label="post link to Spring 源码笔记-2.7 根据类型寻找 bean" href=https://heeexy.com/posts/spring-note-15-findautowirecandidates/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Spring 源码笔记-2.6 BeanWrapper 对比 MyBatis</h2></header><div class=entry-content><p>Spring vs MyBatis Spring 和 MyBatis 中都有 BeanWrapper , Spring 中为接口， 实现类为 BeanWrapperImpl , 为了方便后面区分，本文用 SB 指代 Spring 的 BeanWrapperImpl ，用 MB 指代 MyBatis 中的 BeanWrapper。
功能 BeanWrapper 都属于各自框架的反射工具箱的重要组成部分。都是创建实例并且为其属性赋值的。以 SB 为例，下面的代码应该很容易看明白它的功能。
BeanWrapper company = BeanWrapperImpl(new Company()); // setting the company name.. company.setPropertyValue("name", "Some Company Inc."); // ... can also be done like this: PropertyValue value = new PropertyValue("name", "Some Company Inc."); company.setPropertyValue(value); // ok, let's create the director and tie it to the company: BeanWrapper jim = BeanWrapperImpl(new Employee()); jim....</p></div><footer class=entry-footer><span title='2018-01-19 15:21:58 +0000 UTC'>January 19, 2018</span></footer><a class=entry-link aria-label="post link to Spring 源码笔记-2.6 BeanWrapper 对比 MyBatis" href=https://heeexy.com/posts/spring-note-14-beanwrapper/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Spring源码笔记-2.5 createBean</h2></header><div class=entry-content><p>此方法交给了 AbstractBeanFactory 的子类 AbstractAutowireCapableBeanFactory 去实现。
并且不管这个bean是单例还是 prototype 还是其它 scope ,最终都是会走到此处，只是前后的一些验证、处理有区别。比如单例的就要先去缓存中获取，prototype 就不需要。
源码阅读到这里，我们已经习惯了一层一层剥。createBean 依然还是没有直接地把 bean 创建出来（当然我所期望的看到创建 bean 就是看到它的反射源码为止）。
createBean 的大致步骤为:
根据 RootBeanDefinition 来获取要创建 bean 的 class 。这 class 还有可能为 null。 prepareMethodOverrides 。准备 override 方法，对 override 属性进行验证。 给后处理器一个机会来返回代理，替代真正的 bean. doCreateBean 创建真正的 bean 实例。 prepareMethodOverrides 首先去温习一遍 lookup-method 和 replace-method 吧。博文
其实就是通过配置把原本 bean 中的某个方法给替代掉。
此处我们先只是确认一遍指定的替代方法存在于要生成的 bean 中。
顺带看一看这个方法有没有重载overload)，做个标记。
resolveBeforeInstantiation 经过一波预处理器InstantiationAwareBeanPostProcessor ，如果生产出了 bean，再经过一波后处理器。
一旦生产出 bean，则立即将此 bean 返回。
此处就是留下了一个拓展点，经过此方法之后，bean可能已经不是我们认为的 bean 了，而可能已经变成了一个经过处理的代理 bean 。
循环依赖 构造器循环依赖 如果是 prototype，无法解决，只能抛错。...</p></div><footer class=entry-footer><span title='2018-01-18 14:22:06 +0000 UTC'>January 18, 2018</span></footer><a class=entry-link aria-label="post link to Spring源码笔记-2.5 createBean" href=https://heeexy.com/posts/spring-note-13-createbean/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Spring源码笔记-2.4 获取单例</h2></header><div class=entry-content><p>获取单例bean getSingleton 明明之前一篇已经讲过了获取单例,为什么这里又是获取单例bean呢?
两天不看书,果断又忘了.前面学的是从缓存中获取,这里是真正的获取.
DefaultSingletonBeanRegistry 中重载此方法,第二参数为ObjectFactory
public Object getSingleton(String beanName, ObjectFactory&lt;?> singletonFactory) { Assert.notNull(beanName, "'beanName' must not be null"); //这里再次看到了这个singletonObjects,上篇文章介绍过,是维护了单例对象 //书中说法是:用于保存BeanName和创建bean实例之间的关系 Map var3 = this.singletonObjects; synchronized(this.singletonObjects) { Object singletonObject = this.singletonObjects.get(beanName); //首先获取一遍,如果不存在,才去创建 if (singletonObject == null) { //工厂如果正在销毁,这时候获取bean就会报错 if (this.singletonsCurrentlyInDestruction) { throw new BeanCreationNotAllowedException(beanName, "Singleton bean creation not allowed while the singletons of this factory are in destruction (Do not request a bean from a BeanFactory in a destroy method implementation!...</p></div><footer class=entry-footer><span title='2017-09-29 22:49:00 +0000 UTC'>September 29, 2017</span></footer><a class=entry-link aria-label="post link to Spring源码笔记-2.4 获取单例" href=https://heeexy.com/posts/spring-note-12-%E8%8E%B7%E5%8F%96%E5%8D%95%E4%BE%8B/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Spring源码笔记-2.3 缓存中获取单例bean及获取对象</h2></header><div class=entry-content><p>缓存中获取单例bean getSingleton DefaultSingletonBeanRegistry 中实现此方法
//这个map维护了单例对象 private final Map&lt;String, Object> singletonObjects = new ConcurrentHashMap(256); //当前正在创建中的单例对象 private final Set&lt;String> singletonsCurrentlyInCreation = Collections.newSetFromMap(new ConcurrentHashMap(16)); //早期单例对象 private final Map&lt;String, Object> earlySingletonObjects = new HashMap(16); //单例工厂? private final Map&lt;String, ObjectFactory&lt;?>> singletonFactories = new HashMap(16); protected Object getSingleton(String beanName, boolean allowEarlyReference) { Object singletonObject = this.singletonObjects.get(beanName); //如果根据这个beanName没取到对象,但发现这个对象还在创建中..... if (singletonObject == null && this.isSingletonCurrentlyInCreation(beanName)) { Map var4 = this.singletonObjects; synchronized(this.singletonObjects) { singletonObject = this.earlySingletonObjects.get(beanName); //如果早期单例对象中没有此bean,并且允许早期依赖 if (singletonObject == null && allowEarlyReference) { //当某些方法需要提前初始化的时候则会调用 addSingletonFactory方法将对应的ObjectFactory初始化策略存储在singletonFactories ObjectFactory&lt;?...</p></div><footer class=entry-footer><span title='2017-09-26 23:28:00 +0000 UTC'>September 26, 2017</span></footer><a class=entry-link aria-label="post link to Spring源码笔记-2.3 缓存中获取单例bean及获取对象" href=https://heeexy.com/posts/spring-note-11-getsingleton/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Spring源码笔记-2.2 FactoryBean</h2></header><div class=entry-content><p>package org.springframework.beans.factory; public interface FactoryBean&lt;T> { //返回由FactoryBean创建的bean实例,如果isSingleton()返回true,则该实例会放到Spring容器中单实例缓存池中 T getObject() throws Exception; //返回FactoryBean创建的bean类型 Class&lt;?> getObjectType(); //返回bean实例的作用域是singleton还是prototype boolean isSingleton(); } ​ 当配置文件的class属性配置的实现类是FactoryBean 时,通过getBean() 方法返回的不是FactoryBean 本身,而是FactoryBean.getObject() 方法所返回的对象.
​ 相当于FactoryBean.getObject() 代理了getBean() 方法.
​ 例如,如果使用传统方式配置Car的bean,Car的每个属性对应一个 元素标签
public class Car { private int maxSpeed; private String brand; private double price; //get/set } ​ 如果使用FactoryBean的方式就会灵活一些,下面通过逗号分隔符的方式一次性地为Car的所有属性指定配置值:
public class CarFactoryBean implements FactoryBean&lt;Car> { private String carInfo; @Override public Car getObject() throws Exception { Car car = new Car(); String[] infos = carInfo....</p></div><footer class=entry-footer><span title='2017-09-26 14:47:00 +0000 UTC'>September 26, 2017</span></footer><a class=entry-link aria-label="post link to Spring源码笔记-2.2 FactoryBean" href=https://heeexy.com/posts/spring-note-10-factorybean/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Spring源码笔记-2.1 bean的加载初探</h2></header><div class=entry-content><p>本文要看啥? ​ 前面已经了解了bean从配置文件到解析成BDHolder到注册的流程,我们已经将bean的信息封装好,塞入了map中,这个map可能在不同的实现里面,前面重点学的就是DefaultListableBeanFactory里的beanDefinitionMap.
​ 我们现在要探索bean的加载,围绕最初的示例代码:
MyTestBean bean =(MyTestBean)bf.getBean("myTestBean"); ​ BeanFactory是个接口,其下实现关系很复杂, getBean方法的实现主要是在AbstractBeanFactory 这一层.
​ 本文就是先来快速体验一下加载bean的大体流程
进入代码吧 protected &lt;T> T doGetBean(String name, Class&lt;T> requiredType, final Object[] args, boolean typeCheckOnly) throws BeansException { //转换beanName final String beanName = this.transformedBeanName(name); //根据beanName找其单例 Object sharedInstance = this.getSingleton(beanName); Object bean; if (sharedInstance != null && args == null) { if (this.logger.isDebugEnabled()) { if (this.isSingletonCurrentlyInCreation(beanName)) { this.logger.debug("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference"); } else { this....</p></div><footer class=entry-footer><span title='2017-09-26 11:16:00 +0000 UTC'>September 26, 2017</span></footer><a class=entry-link aria-label="post link to Spring源码笔记-2.1 bean的加载初探" href=https://heeexy.com/posts/spring-note-9-beanload/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Spring源码笔记-1.6 自定义标签的解析</h2></header><div class=entry-content><p>自定义标签的使用 主要内容都在书上,p80
关键的部分为
创建XSD文件 创建类 继承AbstractSingleBeanDefinitionParser , 其继承关系最主要是实现了BeanDefinitionParser 接口,顾名思义,可以用来解析bean. 创建Handler文件, 继承自 NamespaceHandlerSupport ,目的是将上面的组件注册到Spring容器内 编写Spring.handlers 和 Spring.schemas文件. 这样,自定义的配置就结束了.
Spring加载自定义bean的流程主要就是遇到自定义标签后就去Spring.handlers和Spring.schemas中取找对应的handler 和 XSD .从而可以拿到parser
而代码里的主要步骤为
拿到标签对应的命名空间 根据命名空间找到对应的handler 调用handler的parse方法 获取标签的命名空间 调用org.w3c.dom.Node中的getNamespaceURI()
提取自定义标签处理器 NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); 这个resolve方法是接口,由DefaultNamespaceHandlerResolver 默认命名空间解析器来实现,其实现里面的第一步便是
Map&lt;String, Object> handlerMappings = this.getHandlerMappings(); 原来handlerMappings 是个map,想必是在注册时肯定把解析器添加到这个map里面来,用namespaceUri做key,这样找的时候就很好找了.
取出结果如果是NamespaceHandler 便可以返回,往下读我们发现,之所以这么爽取出来就是handler,是因为已经做过这个解析,把找出的handler塞入了map,相当于是缓存了.
否则就是类名 className, 我们需要把它转为handler
//使用反射,将类路径转化为类 Class&lt;?> handlerClass = ClassUtils.forName(className, this.classLoader); if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) { throw new FatalBeanException("Class [" + className + "] for namespace [" + namespaceUri + "] does not implement the [" + NamespaceHandler....</p></div><footer class=entry-footer><span title='2017-09-19 19:33:23 +0000 UTC'>September 19, 2017</span></footer><a class=entry-link aria-label="post link to Spring源码笔记-1.6 自定义标签的解析" href=https://heeexy.com/posts/spring-note-8-custom-element/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://heeexy.com/tags/%E7%AC%94%E8%AE%B0/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://heeexy.com/>网站标题</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>